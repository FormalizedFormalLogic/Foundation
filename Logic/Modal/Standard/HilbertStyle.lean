import Logic.Logic.HilbertStyle.Supplemental
import Logic.Modal.Standard.System

namespace LO.System

variable {F : Type*} [StandardModalLogicalConnective F] [NegDefinition F] [DecidableEq F]
variable {S : Type*} [System F S]
variable {p q r : F} {Œì Œî : List F}

variable {ùì¢ : S}
variable [Classical ùì¢]

open FiniteContext

open Necessitation



variable [Necessitation ùì¢]

lemma Necessitation.nec! : ùì¢ ‚ä¢! p ‚Üí ùì¢ ‚ä¢! ‚ñ°p := by rintro ‚ü®hp‚ü©; exact ‚ü®nec hp‚ü©

def Necessitation.multinec : ùì¢ ‚ä¢ p ‚Üí ùì¢ ‚ä¢ ‚ñ°^[n]p := by
  intro h;
  induction n with
  | zero => simpa;
  | succ n ih => simpa using nec ih;

lemma Necessitation.multinec! : ùì¢ ‚ä¢! p ‚Üí ùì¢ ‚ä¢! ‚ñ°^[n]p := by rintro ‚ü®hp‚ü©; exact ‚ü®multinec hp‚ü©


variable [HasAxiomK ùì¢]

def axiomK [HasAxiomK ùì¢] : ùì¢ ‚ä¢ ‚ñ°(p ‚ü∂ q) ‚ü∂ ‚ñ°p ‚ü∂ ‚ñ°q := HasAxiomK.K _ _
@[simp] lemma axiomK! [HasAxiomK ùì¢] : ùì¢ ‚ä¢! ‚ñ°(p ‚ü∂ q) ‚ü∂ ‚ñ°p ‚ü∂ ‚ñ°q := ‚ü®axiomK‚ü©

instance [HasAxiomK ùì¢] (Œì : FiniteContext F ùì¢) : HasAxiomK Œì := ‚ü®fun _ _ ‚Ü¶ FiniteContext.of axiomK‚ü©
instance [HasAxiomK ùì¢] (Œì : Context F ùì¢) : HasAxiomK Œì := ‚ü®fun _ _ ‚Ü¶ Context.of axiomK‚ü©

variable [HasAxiomK ùì¢]

def axiomK' (h : ùì¢ ‚ä¢ ‚ñ°(p ‚ü∂ q)) : ùì¢ ‚ä¢ ‚ñ°p ‚ü∂ ‚ñ°q := axiomK ‚®Ä h
@[simp] lemma axiomK'! (h : ùì¢ ‚ä¢! ‚ñ°(p ‚ü∂ q)) : ùì¢ ‚ä¢! ‚ñ°p ‚ü∂ ‚ñ°q := ‚ü®axiomK' h.some‚ü©

def axiomK'' (h‚ÇÅ : ùì¢ ‚ä¢ ‚ñ°(p ‚ü∂ q)) (h‚ÇÇ : ùì¢ ‚ä¢ ‚ñ°p) : ùì¢ ‚ä¢ ‚ñ°q := axiomK' h‚ÇÅ ‚®Ä h‚ÇÇ
@[simp] lemma axiomK''! (h‚ÇÅ : ùì¢ ‚ä¢! ‚ñ°(p ‚ü∂ q)) (h‚ÇÇ : ùì¢ ‚ä¢! ‚ñ°p) : ùì¢ ‚ä¢! ‚ñ°q := ‚ü®axiomK'' h‚ÇÅ.some h‚ÇÇ.some‚ü©

def multibox_axiomK : ùì¢ ‚ä¢ ‚ñ°^[n](p ‚ü∂ q) ‚ü∂ ‚ñ°^[n]p ‚ü∂ ‚ñ°^[n]q := by
  induction n with
  | zero => simp; apply impId;
  | succ n ih => simpa using impTrans (axiomK' $ nec ih) (by apply axiomK);

@[simp] lemma multibox_axiomK! : ùì¢ ‚ä¢! ‚ñ°^[n](p ‚ü∂ q) ‚ü∂ ‚ñ°^[n]p ‚ü∂ ‚ñ°^[n]q := ‚ü®multibox_axiomK‚ü©

def multibox_axiomK' (h : ùì¢ ‚ä¢ ‚ñ°^[n](p ‚ü∂ q)) : ùì¢ ‚ä¢ ‚ñ°^[n]p ‚ü∂ ‚ñ°^[n]q := multibox_axiomK ‚®Ä h
@[simp] lemma multibox_axiomK'! (h : ùì¢ ‚ä¢! ‚ñ°^[n](p ‚ü∂ q)) : ùì¢ ‚ä¢! ‚ñ°^[n]p ‚ü∂ ‚ñ°^[n]q := ‚ü®multibox_axiomK' h.some‚ü©

alias multiboxedImplyDistribute := multibox_axiomK'
alias multiboxed_imply_distribute! := multibox_axiomK'!


def boxIff' (h : ùì¢ ‚ä¢ p ‚ü∑ q) : ùì¢ ‚ä¢ (‚ñ°p ‚ü∑ ‚ñ°q) := by
  apply iffIntro;
  . exact axiomK' $ nec $ conj‚ÇÅ' h;
  . exact axiomK' $ nec $ conj‚ÇÇ' h;
@[simp] lemma box_iff! (h : ùì¢ ‚ä¢! p ‚ü∑ q) : ùì¢ ‚ä¢! ‚ñ°p ‚ü∑ ‚ñ°q := ‚ü®boxIff' h.some‚ü©

def multiboxIff' (h : ùì¢ ‚ä¢ p ‚ü∑ q) : ùì¢ ‚ä¢ ‚ñ°^[n]p ‚ü∑ ‚ñ°^[n]q := by
  induction n with
  | zero => simpa;
  | succ n ih => simpa using boxIff' ih;
@[simp] lemma multibox_iff! (h : ùì¢ ‚ä¢! p ‚ü∑ q) : ùì¢ ‚ä¢! ‚ñ°^[n]p ‚ü∑ ‚ñ°^[n]q := ‚ü®multiboxIff' h.some‚ü©

def negIff' (h : ùì¢ ‚ä¢ p ‚ü∑ q) : ùì¢ ‚ä¢ (~p ‚ü∑ ~q) := conj‚ÇÉ' (contra‚ÇÄ' $ conj‚ÇÇ' h) (contra‚ÇÄ' $ conj‚ÇÅ' h)
@[simp] lemma neg_iff! (h : ùì¢ ‚ä¢! p ‚ü∑ q) : ùì¢ ‚ä¢! ~p ‚ü∑ ~q := ‚ü®negIff' h.some‚ü©

def diaIff' (h : ùì¢ ‚ä¢ p ‚ü∑ q) : ùì¢ ‚ä¢ (‚óáp ‚ü∑ ‚óáq) := by
  simp only [StandardModalLogicalConnective.duality'];
  apply negIff';
  apply boxIff';
  apply negIff';
  assumption
@[simp] lemma dia_iff! (h : ùì¢ ‚ä¢! p ‚ü∑ q) : ùì¢ ‚ä¢! ‚óáp ‚ü∑ ‚óáq := ‚ü®diaIff' h.some‚ü©

def multidiaIff' (h : ùì¢ ‚ä¢ p ‚ü∑ q) : ùì¢ ‚ä¢ ‚óá^[n]p ‚ü∑ ‚óá^[n]q := by
  induction n with
  | zero => simpa;
  | succ n ih => simpa using diaIff' ih;
@[simp] lemma multidia_iff! (h : ùì¢ ‚ä¢! p ‚ü∑ q) : ùì¢ ‚ä¢! ‚óá^[n]p ‚ü∑ ‚óá^[n]q := ‚ü®multidiaIff' h.some‚ü©


def multiboxDuality : ùì¢ ‚ä¢ ‚ñ°^[n]p ‚ü∑ ~(‚óá^[n](~p)) := by
  induction n with
  | zero => simp; apply dn;
  | succ n ih =>
    simp [StandardModalLogicalConnective.duality'];
    exact iffTrans (boxIff' ih) dn
@[simp] lemma multiboxDuality! : ùì¢ ‚ä¢! ‚ñ°^[n]p ‚ü∑ ~(‚óá^[n](~p)) := ‚ü®multiboxDuality‚ü©

def boxDuality : ùì¢ ‚ä¢ ‚ñ°p ‚ü∑ ~(‚óá~p) := multiboxDuality (n := 1)
@[simp] lemma boxDuality! : ùì¢ ‚ä¢! ‚ñ°p ‚ü∑ ~(‚óá~p) := ‚ü®boxDuality‚ü©

lemma multiboxDuality'! : ùì¢ ‚ä¢! ‚ñ°^[n]p ‚Üî ùì¢ ‚ä¢! ~(‚óá^[n](~p)) := by
  constructor;
  . intro h; exact (conj‚ÇÅ'! multiboxDuality!) ‚®Ä h;
  . intro h; exact (conj‚ÇÇ'! multiboxDuality!) ‚®Ä h;

lemma boxDuality'! : ùì¢ ‚ä¢! ‚ñ°p ‚Üî ùì¢ ‚ä¢! ~(‚óá~p) := multiboxDuality'! (n := 1)


def multidiaDuality : ùì¢ ‚ä¢ ‚óá^[n]p ‚ü∑ ~(‚ñ°^[n](~p)) := by
  induction n with
  | zero => simp; apply dn;
  | succ n ih =>
    simp [StandardModalLogicalConnective.duality'];
    apply neg_iff';
    apply boxIff';
    exact iffTrans (negIff' ih) (iffComm' dn)
@[simp] lemma multidiaDuality! : ùì¢ ‚ä¢! ‚óá^[n]p ‚ü∑ ~(‚ñ°^[n](~p)) := ‚ü®multidiaDuality‚ü©

def diaDuality : ùì¢ ‚ä¢ ‚óáp ‚ü∑ ~(‚ñ°~p) := multidiaDuality (n := 1)
@[simp] lemma diaDuality! : ùì¢ ‚ä¢! ‚óáp ‚ü∑ ~(‚ñ°~p) := ‚ü®diaDuality‚ü©

lemma multidiaDuality'! : ùì¢ ‚ä¢! ‚óá^[n]p ‚Üî ùì¢ ‚ä¢! ~(‚ñ°^[n](~p)) := by
  constructor;
  . intro h; exact (conj‚ÇÅ'! multidiaDuality!) ‚®Ä h;
  . intro h; exact (conj‚ÇÇ'! multidiaDuality!) ‚®Ä h;
lemma diaDuality'! : ùì¢ ‚ä¢! ‚óáp ‚Üî ùì¢ ‚ä¢! ~(‚ñ°~p) := multidiaDuality'! (n := 1)


def multiboxverum : ùì¢ ‚ä¢ (‚ñ°^[n]‚ä§ : F) := multinec verum
@[simp] lemma multiboxverum! : ùì¢ ‚ä¢! (‚ñ°^[n]‚ä§ : F) := ‚ü®multiboxverum‚ü©

def boxverum : ùì¢ ‚ä¢ (‚ñ°‚ä§ : F) := multiboxverum (n := 1)
@[simp] lemma boxverum! : ùì¢ ‚ä¢! (‚ñ°‚ä§ : F) := ‚ü®boxverum‚ü©


def implyMultiboxDistribute' (h : ùì¢ ‚ä¢ p ‚ü∂ q) : ùì¢ ‚ä¢ ‚ñ°^[n]p ‚ü∂ ‚ñ°^[n]q := multibox_axiomK' $ multinec h
lemma imply_multibox_distribute'! (h : ùì¢ ‚ä¢! p ‚ü∂ q) : ùì¢ ‚ä¢! ‚ñ°^[n]p ‚ü∂ ‚ñ°^[n]q := ‚ü®implyMultiboxDistribute' h.some‚ü©

def implyBoxDistribute' (h : ùì¢ ‚ä¢ p ‚ü∂ q) : ùì¢ ‚ä¢ ‚ñ°p ‚ü∂ ‚ñ°q := implyMultiboxDistribute' (n := 1) h
lemma imply_box_distribute'! (h : ùì¢ ‚ä¢! p ‚ü∂ q) : ùì¢ ‚ä¢! ‚ñ°p ‚ü∂ ‚ñ°q := ‚ü®implyBoxDistribute' h.some‚ü©


def distribute_multibox_and : ùì¢ ‚ä¢ ‚ñ°^[n](p ‚ãè q) ‚ü∂ ‚ñ°^[n]p ‚ãè ‚ñ°^[n]q := implyRightAnd (implyMultiboxDistribute' conj‚ÇÅ) (implyMultiboxDistribute' conj‚ÇÇ)
@[simp] lemma distribute_multibox_and! : ùì¢ ‚ä¢! ‚ñ°^[n](p ‚ãè q) ‚ü∂ ‚ñ°^[n]p ‚ãè ‚ñ°^[n]q := ‚ü®distribute_multibox_and‚ü©

def distribute_box_and : ùì¢ ‚ä¢ ‚ñ°(p ‚ãè q) ‚ü∂ ‚ñ°p ‚ãè ‚ñ°q := distribute_multibox_and (n := 1)
@[simp] lemma distribute_box_and! : ùì¢ ‚ä¢! ‚ñ°(p ‚ãè q) ‚ü∂ ‚ñ°p ‚ãè ‚ñ°q := ‚ü®distribute_box_and‚ü©

def distribute_multibox_and' (h : ùì¢ ‚ä¢ ‚ñ°^[n](p ‚ãè q)) : ùì¢ ‚ä¢ ‚ñ°^[n]p ‚ãè ‚ñ°^[n]q := distribute_multibox_and ‚®Ä h
lemma distribute_multibox_and'! (d : ùì¢ ‚ä¢! ‚ñ°^[n](p ‚ãè q)) : ùì¢ ‚ä¢! ‚ñ°^[n]p ‚ãè ‚ñ°^[n]q := ‚ü®distribute_multibox_and' d.some‚ü©

def distribute_box_and' (h : ùì¢ ‚ä¢ ‚ñ°(p ‚ãè q)) : ùì¢ ‚ä¢ ‚ñ°p ‚ãè ‚ñ°q := distribute_multibox_and' (n := 1) h
lemma distribute_box_and'! (d : ùì¢ ‚ä¢! ‚ñ°(p ‚ãè q)) : ùì¢ ‚ä¢! ‚ñ°p ‚ãè ‚ñ°q := ‚ü®distribute_box_and' d.some‚ü©


def collect_multibox_and : ùì¢ ‚ä¢ ‚ñ°^[n]p ‚ãè ‚ñ°^[n]q ‚ü∂ ‚ñ°^[n](p ‚ãè q) := by
  have d‚ÇÅ : ùì¢ ‚ä¢ ‚ñ°^[n]p ‚ü∂ ‚ñ°^[n](q ‚ü∂ p ‚ãè q) := implyMultiboxDistribute' conj‚ÇÉ;
  have d‚ÇÇ : ùì¢ ‚ä¢ ‚ñ°^[n](q ‚ü∂ p ‚ãè q) ‚ü∂ (‚ñ°^[n]q ‚ü∂ ‚ñ°^[n](p ‚ãè q)) := multibox_axiomK;
  exact (conj‚ÇÇ' (andImplyIffImplyImply _ _ _)) ‚®Ä (impTrans d‚ÇÅ d‚ÇÇ);
@[simp] lemma collect_multibox_and! : ùì¢ ‚ä¢! ‚ñ°^[n]p ‚ãè ‚ñ°^[n]q ‚ü∂ ‚ñ°^[n](p ‚ãè q) := ‚ü®collect_multibox_and‚ü©

def collect_box_and : ùì¢ ‚ä¢ ‚ñ°p ‚ãè ‚ñ°q ‚ü∂ ‚ñ°(p ‚ãè q) := collect_multibox_and (n := 1)
@[simp] lemma collect_box_and! : ùì¢ ‚ä¢! ‚ñ°p ‚ãè ‚ñ°q ‚ü∂ ‚ñ°(p ‚ãè q) := ‚ü®collect_box_and‚ü©

def collect_multibox_and' (h : ùì¢ ‚ä¢ ‚ñ°^[n]p ‚ãè ‚ñ°^[n]q) : ùì¢ ‚ä¢ ‚ñ°^[n](p ‚ãè q) := collect_multibox_and ‚®Ä h
lemma collect_multibox_and'! (h : ùì¢ ‚ä¢! ‚ñ°^[n]p ‚ãè ‚ñ°^[n]q) : ùì¢ ‚ä¢! ‚ñ°^[n](p ‚ãè q) := ‚ü®collect_multibox_and' h.some‚ü©

def collect_box_and' (h : ùì¢ ‚ä¢ ‚ñ°p ‚ãè ‚ñ°q) : ùì¢ ‚ä¢ ‚ñ°(p ‚ãè q) := collect_multibox_and' (n := 1) h
lemma collect_box_and'! (h : ùì¢ ‚ä¢! ‚ñ°p ‚ãè ‚ñ°q) : ùì¢ ‚ä¢! ‚ñ°(p ‚ãè q) := ‚ü®collect_box_and' h.some‚ü©


lemma iff_conj'multibox_multiboxconj'! : ùì¢ ‚ä¢! ‚ñ°^[n](Œì.conj') ‚Üî ùì¢ ‚ä¢! (‚ñ°^[n]Œì).conj' := by
  induction Œì using List.induction_with_singleton with
  | hnil => simp;
  | hsingle => simp;
  | hcons p Œì h ih =>
    simp only [(List.conj'_cons_nonempty h)];
    have e := List.conj'_cons_nonempty (a := ‚ñ°^[n]p) (as := ‚ñ°^[n]Œì) (by simpa)
    constructor;
    . intro h;
      simp [e];
      have d := distribute_multibox_and'! h;
      exact conj‚ÇÉ'! (conj‚ÇÅ'! d) (ih.mp $ conj‚ÇÇ'! d);
    . intro h;
      simp [e] at h;
      exact collect_multibox_and'! $ conj‚ÇÉ'! (conj‚ÇÅ'! h) (ih.mpr $ conj‚ÇÇ'! h);
lemma iff_conj'box_boxconj'! : ùì¢ ‚ä¢! ‚ñ°(Œì.conj') ‚Üî ùì¢ ‚ä¢! (‚ñ°Œì).conj' := iff_conj'multibox_multiboxconj'! (n := 1)

lemma imply_multiboxconj'_conj'multibox! : ùì¢ ‚ä¢! (‚ñ°^[n]Œì).conj' ‚ü∂ ‚ñ°^[n]Œì.conj' := by
  induction Œì using List.induction_with_singleton with
  | hnil => simp only [List.map_nil, List.conj'_nil]; exact dhyp! multiboxverum!;
  | hsingle => simp only [List.map_cons, List.map_nil, List.conj'_singleton, imp_id!, dn_collect_imply'!, dne'!];
  | hcons p Œì h ih =>
    simp [
      (List.conj'_cons_nonempty h),
      (List.conj'_cons_nonempty (a := ‚ñ°^[n]p) (as := ‚ñ°^[n]Œì) (by simpa)),
    ];
    exact imp_trans! (andReplaceRight! ih) collect_multibox_and!;
lemma imply_boxconj'_conj'box! : ùì¢ ‚ä¢! (‚ñ°Œì).conj' ‚ü∂ ‚ñ°Œì.conj' := imply_multiboxconj'_conj'multibox! (n := 1)

lemma multiboxConj'_iff! : ùì¢ ‚ä¢! ‚ñ°^[n](Œì.conj') ‚Üî ‚àÄ p ‚àà Œì, ùì¢ ‚ä¢! ‚ñ°^[n]p := by
  induction Œì using List.induction_with_singleton with
  | hnil => simp;
  | hsingle => simp;
  | hcons p Œì h ih =>
    simp_all;
    constructor;
    . intro h;
      have := distribute_multibox_and'! h;
      constructor;
      . exact conj‚ÇÅ'! this;
      . exact ih.mp (conj‚ÇÇ'! this);
    . rintro ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©;
      exact collect_multibox_and'! $ conj‚ÇÉ'! h‚ÇÅ (ih.mpr h‚ÇÇ);
lemma boxConj'_iff! : ùì¢ ‚ä¢! ‚ñ°(Œì.conj') ‚Üî ‚àÄ p ‚àà Œì, ùì¢ ‚ä¢! ‚ñ°p := multiboxConj'_iff! (n := 1)



def collect_multibox_or : ùì¢ ‚ä¢ ‚ñ°^[n]p ‚ãé ‚ñ°^[n]q ‚ü∂ ‚ñ°^[n](p ‚ãé q) := disj‚ÇÉ'' (multibox_axiomK' $ multinec disj‚ÇÅ) (multibox_axiomK' $ multinec disj‚ÇÇ)
@[simp] lemma collect_multibox_or! : ùì¢ ‚ä¢! ‚ñ°^[n]p ‚ãé ‚ñ°^[n]q ‚ü∂ ‚ñ°^[n](p ‚ãé q) := ‚ü®collect_multibox_or‚ü©

def collect_box_or : ùì¢ ‚ä¢ ‚ñ°p ‚ãé ‚ñ°q ‚ü∂ ‚ñ°(p ‚ãé q) := collect_multibox_or (n := 1)
@[simp] lemma collect_box_or! : ùì¢ ‚ä¢! ‚ñ°p ‚ãé ‚ñ°q ‚ü∂ ‚ñ°(p ‚ãé q) := ‚ü®collect_box_or‚ü©

def collect_multibox_or' (h : ùì¢ ‚ä¢ ‚ñ°^[n]p ‚ãé ‚ñ°^[n]q) : ùì¢ ‚ä¢ ‚ñ°^[n](p ‚ãé q) := collect_multibox_or ‚®Ä h
lemma collect_multibox_or'! (h : ùì¢ ‚ä¢! ‚ñ°^[n]p ‚ãé ‚ñ°^[n]q) : ùì¢ ‚ä¢! ‚ñ°^[n](p ‚ãé q) := ‚ü®collect_multibox_or' h.some‚ü©

def collect_box_or' (h : ùì¢ ‚ä¢ ‚ñ°p ‚ãé ‚ñ°q) : ùì¢ ‚ä¢ ‚ñ°(p ‚ãé q) := collect_multibox_or' (n := 1) h
lemma collect_box_or'! (h : ùì¢ ‚ä¢! ‚ñ°p ‚ãé ‚ñ°q) : ùì¢ ‚ä¢! ‚ñ°(p ‚ãé q) := ‚ü®collect_box_or' h.some‚ü©


def collect_dia_or : ùì¢ ‚ä¢ ‚óáp ‚ãé ‚óáq ‚ü∂ ‚óá(p ‚ãé q) := by
  simp [StandardModalLogicalConnective.duality'];
  apply contra‚ÇÅ';
  apply deduct';
  apply demorgan‚ÇÇ';
  apply dniAnd';
  apply deductInv';
  exact impTrans (implyBoxDistribute' demorgan‚ÇÉ) distribute_box_and;
@[simp] lemma collect_dia_or! : ùì¢ ‚ä¢! ‚óáp ‚ãé ‚óáq ‚ü∂ ‚óá(p ‚ãé q) := ‚ü®collect_dia_or‚ü©

def collect_dia_or' (h : ùì¢ ‚ä¢ ‚óáp ‚ãé ‚óáq) : ùì¢ ‚ä¢ ‚óá(p ‚ãé q) := collect_dia_or ‚®Ä h
@[simp] lemma collect_dia_or'! (h : ùì¢ ‚ä¢! ‚óáp ‚ãé ‚óáq) : ùì¢ ‚ä¢! ‚óá(p ‚ãé q) := ‚ü®collect_dia_or' h.some‚ü©

-- TODO: „Åä„Åù„Çâ„ÅèÂêåÊßò„Å´Ë®ºÊòéÂèØËÉΩ„Å†„ÅåÔºåÈùûÂ∏∏„Å´ÈÅÖ„ÅÑ„ÅÆ„Åß‰∏ÄÊó¶‰øùÁïô
-- @[simp] def distributeMultidiaAnd!: ùì¢ ‚ä¢! ‚óá^[n](p ‚ãè q) ‚ü∂ ‚óá^[n]p ‚ãè ‚óá^[n]q := by sorry;

@[simp] lemma distribute_multidia_and!: ùì¢ ‚ä¢! ‚óá^[n](p ‚ãè q) ‚ü∂ ‚óá^[n]p ‚ãè ‚óá^[n]q := by
  suffices h : ùì¢ ‚ä¢! ~(‚ñ°^[n](~(p ‚ãè q))) ‚ü∂ ~(‚ñ°^[n](~p)) ‚ãè ~(‚ñ°^[n](~q)) by
    exact imp_trans! (imp_trans! (conj‚ÇÅ'! multidiaDuality!) h) $ andReplace! (conj‚ÇÇ'! multidiaDuality!) (conj‚ÇÇ'! multidiaDuality!);
  apply FiniteContext.deduct'!;
  apply demorgan‚ÇÉ'!;
  apply FiniteContext.deductInv'!;
  apply contra‚ÇÄ'!;
  apply imp_trans! collect_multibox_or! (imply_multibox_distribute'! demorgan‚ÇÅ!)

@[simp] lemma distribute_dia_and! : ùì¢ ‚ä¢! ‚óá(p ‚ãè q) ‚ü∂ ‚óáp ‚ãè ‚óáq := distribute_multidia_and! (n := 1)


-- TODO: „Åä„Åù„Çâ„ÅèÂÆöÁæ©ÂèØËÉΩ„Å†„ÅåÂêåÊßò„Å´ÈùûÂ∏∏„Å´ÈÅÖ„ÅÑ
-- def iffConj'multidiaMultidiaconj'! : ùì¢ ‚ä¢ ‚óá^[n](Œì.conj') ‚ü∂ (‚óá^[n]Œì).conj' := by sorry

@[simp] lemma iff_conj'multidia_multidiaconj'! : ùì¢ ‚ä¢! ‚óá^[n](Œì.conj') ‚ü∂ (‚óá^[n]Œì).conj' := by
  induction Œì using List.induction_with_singleton with
  | hnil => exact dhyp! verum!;
  | hsingle p => simp;
  | hcons p Œì h ih =>
    simp [
      (List.conj'_cons_nonempty h),
      (List.conj'_cons_nonempty (a := ‚óá^[n]p) (as := ‚óá^[n]Œì) (by simpa)),
    ];
    exact imp_trans! distribute_multidia_and! $ andReplaceRight! (p := ‚óá^[n]p) ih;

-- def distributeDiaAnd' (h : ùì¢ ‚ä¢ ‚óá(p ‚ãè q)) : ùì¢ ‚ä¢ ‚óáp ‚ãè ‚óáq := distributeDiaAnd ‚®Ä h
lemma distribute_dia_and'! (h : ùì¢ ‚ä¢! ‚óá(p ‚ãè q)) : ùì¢ ‚ä¢! ‚óáp ‚ãè ‚óáq := distribute_dia_and! ‚®Ä h


def axiomT [HasAxiomT ùì¢] : ùì¢ ‚ä¢ ‚ñ°p ‚ü∂ p := HasAxiomT.T _
@[simp] lemma axiomT! [HasAxiomT ùì¢] : ùì¢ ‚ä¢! ‚ñ°p ‚ü∂ p := ‚ü®axiomT‚ü©

instance [HasAxiomT ùì¢] (Œì : FiniteContext F ùì¢) : HasAxiomT Œì := ‚ü®fun _ ‚Ü¶ FiniteContext.of axiomT‚ü©
instance [HasAxiomT ùì¢] (Œì : Context F ùì¢) : HasAxiomT Œì := ‚ü®fun _ ‚Ü¶ Context.of axiomT‚ü©

def axiomT' [HasAxiomT ùì¢] (h : ùì¢ ‚ä¢ ‚ñ°p) : ùì¢ ‚ä¢ p := axiomT ‚®Ä h
@[simp] lemma axiomT'! [HasAxiomT ùì¢] (h : ùì¢ ‚ä¢! ‚ñ°p) : ùì¢ ‚ä¢! p := ‚ü®axiomT' h.some‚ü©


def axiomB [HasAxiomB ùì¢] : ùì¢ ‚ä¢ p ‚ü∂ ‚ñ°‚óáp := HasAxiomB.B _
@[simp] lemma axiomB! [HasAxiomB ùì¢] : ùì¢ ‚ä¢! p ‚ü∂ ‚ñ°‚óáp := ‚ü®axiomB‚ü©

instance [HasAxiomB ùì¢] (Œì : FiniteContext F ùì¢) : HasAxiomB Œì := ‚ü®fun _ ‚Ü¶ FiniteContext.of axiomB‚ü©
instance [HasAxiomB ùì¢] (Œì : Context F ùì¢) : HasAxiomB Œì := ‚ü®fun _ ‚Ü¶ Context.of axiomB‚ü©


def axiomD [HasAxiomD ùì¢] : ùì¢ ‚ä¢ ‚ñ°p ‚ü∂ ‚óáp := HasAxiomD.D _
@[simp] lemma axiomD! [HasAxiomD ùì¢] : ùì¢ ‚ä¢! ‚ñ°p ‚ü∂ ‚óáp := ‚ü®axiomD‚ü©

instance [HasAxiomD ùì¢] (Œì : FiniteContext F ùì¢) : HasAxiomD Œì := ‚ü®fun _ ‚Ü¶ FiniteContext.of axiomD‚ü©
instance [HasAxiomD ùì¢] (Œì : Context F ùì¢) : HasAxiomD Œì := ‚ü®fun _ ‚Ü¶ Context.of axiomD‚ü©


def axiomFour [HasAxiomFour ùì¢] : ùì¢ ‚ä¢ ‚ñ°p ‚ü∂ ‚ñ°‚ñ°p := HasAxiomFour.Four _
@[simp] lemma axiomFour! [HasAxiomFour ùì¢] : ùì¢ ‚ä¢! ‚ñ°p ‚ü∂ ‚ñ°‚ñ°p := ‚ü®axiomFour‚ü©

instance [HasAxiomFour ùì¢] (Œì : FiniteContext F ùì¢) : HasAxiomFour Œì := ‚ü®fun _ ‚Ü¶ FiniteContext.of axiomFour‚ü©
instance [HasAxiomFour ùì¢] (Œì : Context F ùì¢) : HasAxiomFour Œì := ‚ü®fun _ ‚Ü¶ Context.of axiomFour‚ü©


def axiomFive [HasAxiomFive ùì¢] : ùì¢ ‚ä¢ ‚óáp ‚ü∂ ‚ñ°‚óáp := HasAxiomFive.Five _
@[simp] lemma axiomFive! [HasAxiomFive ùì¢] : ùì¢ ‚ä¢! ‚óáp ‚ü∂ ‚ñ°‚óáp := ‚ü®axiomFive‚ü©

instance [HasAxiomFive ùì¢] (Œì : FiniteContext F ùì¢) : HasAxiomFive Œì := ‚ü®fun _ ‚Ü¶ FiniteContext.of axiomFive‚ü©
instance [HasAxiomFive ùì¢] (Œì : Context F ùì¢) : HasAxiomFive Œì := ‚ü®fun _ ‚Ü¶ Context.of axiomFive‚ü©


end LO.System
