import Logic.Logic.System
import Logic.Modal.Standard.Formula
import Logic.Modal.Standard.Deduction

universe u v

namespace LO.Modal.Standard

def RelItr (R : Œ± ‚Üí Œ± ‚Üí Prop) : ‚Ñï ‚Üí Œ± ‚Üí Œ± ‚Üí Prop
  | 0 => (¬∑ = ¬∑)
  | n + 1 => fun x y ‚Ü¶ ‚àÉ z, R x z ‚àß RelItr R n z y

namespace RelItr

@[simp]
lemma iff_zero {R : Œ± ‚Üí Œ± ‚Üí Prop} {x y : Œ±} : RelItr R 0 x y ‚Üî x = y := iff_of_eq rfl

@[simp]
lemma iff_succ {R : Œ± ‚Üí Œ± ‚Üí Prop} {x y : Œ±} : RelItr R (n + 1) x y ‚Üî ‚àÉ z, R x z ‚àß RelItr R n z y := iff_of_eq rfl

@[simp]
lemma eq : RelItr (Œ± := Œ±) (¬∑ = ¬∑) n = (¬∑ = ¬∑) := by
  induction n with
  | zero => rfl;
  | succ n ih => aesop

end RelItr

namespace Kripke


structure Frame (Œ±) where
  World : Set Œ±
  World_nonempty : World.Nonempty := by aesop
  Rel : Set (World √ó World)

structure FiniteFrame (Œ±) extends Frame Œ± where
  World_finite : World.Finite := by simp;

instance (F : Frame Œ±) : F.World.Nonempty := F.World_nonempty

/-
instance : CoeSort (Frame Œ±) (Type*) := ‚ü®Frame.World‚ü©

instance : CoeFun (Frame Œ±) (Œª F => F.World ‚Üí F.World ‚Üí Prop) := ‚ü®Frame.Rel‚ü©
-/

instance : Coe (FiniteFrame Œ±) (Frame Œ±) := ‚ü®Œª F ‚Ü¶ F.toFrame‚ü©

abbrev Frame.Rel' {F : Frame Œ±} (x y : F.World) := (x, y) ‚àà F.Rel
scoped infix:45 " ‚â∫ " => Frame.Rel'

protected abbrev Frame.RelItr'  {F : Frame Œ±} (n : ‚Ñï) (x y : F.World) : Prop := RelItr (¬∑ ‚â∫ ¬∑) n x y
scoped notation x:45 " ‚â∫^[" n "] " y:46 => Frame.RelItr' n x y


protected def Frame.finite (F : Frame Œ±) := Finite F.World

/-- dependent-version frame -/
abbrev Frame' (Œ±) (Œ≤ : Type*) := Frame Œ±


/-- Frame with single world and identiy relation -/
abbrev TerminalFrame : FiniteFrame (Fin 1) where
  World := {0}
  Rel := { (x, y) | x = y }

@[simp]
lemma TerminalFrame.iff_rel' {x y : TerminalFrame.World} : x ‚â∫ y ‚Üî x = y := by
  simp [Frame.Rel'];

@[simp]
lemma TerminalFrame.iff_relItr' {x y : TerminalFrame.World} : x ‚â∫^[n] y ‚Üî x = y := by
  induction n <;> simp_all [Frame.Rel'];


abbrev PointFrame : FiniteFrame (Fin 1) where
  World := {0}
  Rel := ‚àÖ


abbrev FrameClass := ‚àÄ (Œ± : Type*), Set (Frame Œ±)

/-- dependent-version frame class -/
abbrev FrameClass' (Œ≤ : Type*) := FrameClass


abbrev FrameClass.union (ùîΩ‚ÇÅ ùîΩ‚ÇÇ : FrameClass) : FrameClass := Œª Œ± => ùîΩ‚ÇÅ Œ± ‚à™ ùîΩ‚ÇÇ Œ±
instance : Union FrameClass := ‚ü®FrameClass.union‚ü©

abbrev FrameClass.inter (ùîΩ‚ÇÅ ùîΩ‚ÇÇ : FrameClass) : FrameClass := Œª Œ± => ùîΩ‚ÇÅ Œ± ‚à© ùîΩ‚ÇÇ Œ±
instance : Inter FrameClass := ‚ü®FrameClass.inter‚ü©

abbrev FrameClass.Nonempty (ùîΩ : FrameClass) := ‚àÉ (Œ± : Type), (ùîΩ Œ±).Nonempty

abbrev FrameClass.UNonempty (ùîΩ : FrameClass) := ‚àÉ (Œ± : Type*), (ùîΩ Œ±).Nonempty

-- def FrameClass.mem (F : Frame Œ±) (ùîΩ : FrameClass) : Prop := F ‚àà ùîΩ Œ±

abbrev FiniteFrameClass (Œ±) := Set (FiniteFrame Œ±)

/-
def FrameClass.toFinite (ùîΩ : FrameClass) : FrameClass := ‚àÄ Œ±, { F | F ‚àà ùîΩ Œ± }
postfix:max "·∂†" => FrameClass.toFinite
-/

abbrev Valuation (F : Frame Œ±) (Œ≤ : Type*) := (F.World) ‚Üí Œ≤ ‚Üí Prop

structure Model (Œ± Œ≤) where
  Frame : Frame Œ±
  Valuation : Valuation Frame Œ≤

abbrev Model.World (M : Model Œ± Œ≤) := M.Frame.World
-- instance : CoeSort (Model Œ±) (Type _) where coe := Model.World


end Kripke


variable {Œ± Œ≤ : Type*}

open Standard.Kripke

def Formula.kripke_satisfies (M : Kripke.Model Œ± Œ≤) (x : M.World) : Formula Œ≤ ‚Üí Prop
  | atom a  => M.Valuation x a
  | verum   => True
  | falsum  => False
  | and p q => (kripke_satisfies M x p) ‚àß (kripke_satisfies M x q)
  | or p q  => (kripke_satisfies M x p) ‚à® (kripke_satisfies M x q)
  | imp p q => (kripke_satisfies M x p) ‚Üí (kripke_satisfies M x q)
  | box p   => ‚àÄ {y}, x ‚â∫ y ‚Üí (kripke_satisfies M y p)

namespace Formula.kripke_satisfies

protected instance semantics : Semantics (Formula Œ≤) ((M : Model Œ± Œ≤) √ó M.World) := ‚ü®fun ‚ü®M, x‚ü© ‚Ü¶ Formula.kripke_satisfies M x‚ü©

variable {M : Model Œ± Œ≤} {x : ‚ÜëM.World} {p q : Formula Œ≤}

notation:max "(" M ", " x ")" " ‚äß " p:50 => Formula.kripke_satisfies M x p

@[simp] protected lemma iff_models : (‚ü®M, x‚ü© : (M : Model Œ± Œ≤) √ó ‚ÜëM.World) ‚äß p ‚Üî kripke_satisfies M x p := iff_of_eq rfl


protected instance tarski : Semantics.Tarski ((M : Model Œ± Œ≤) √ó M.World) where
  realize_top := by intro; trivial;
  realize_bot := by aesop;
  realize_not := by aesop;
  realize_and := by
    intro ‚ü®M, x‚ü© p q;
    constructor;
    . intro ‚ü®hp, hq‚ü©; exact ‚ü®hp, hq‚ü©;
    . intro h; exact ‚ü®h.1, h.2‚ü©;
  realize_or  := by aesop;
  realize_imp := by aesop;


lemma dia_def : (M, x) ‚äß ‚óáp ‚Üî ‚àÉ (y : M.World), x ‚â∫ y ‚àß (M, y) ‚äß p := by simp [kripke_satisfies];

lemma multibox_def : (M, x) ‚äß ‚ñ°^[n]p ‚Üî ‚àÄ {y : M.World}, x ‚â∫^[n] y ‚Üí (M, y) ‚äß p := by
  induction n generalizing x with
  | zero => aesop;
  | succ n ih =>
    constructor;
    . intro h y Rxy;
      simp [kripke_satisfies] at h;
      obtain ‚ü®u, hxu, huy‚ü© := Rxy;
      exact (ih.mp $ h u (by simp_all) hxu) huy;
    . simp;
      intro h y Rxy;
      apply ih.mpr;
      intro u Ryu;
      exact h u u.2 y y.2 Rxy Ryu;

lemma multidia_def : (M, x) ‚äß ‚óá^[n]p ‚Üî ‚àÉ y, x ‚â∫^[n] y ‚àß (M, y) ‚äß p := by
  induction n generalizing x with
  | zero => simp;
  | succ n ih =>
    constructor;
    . intro h;
      replace h : (M, x) ‚äß (‚óá‚óá^[n]p) := by simpa using h;
      obtain ‚ü®v, hwv, hv‚ü© := dia_def.mp h;
      obtain ‚ü®x, hvx, hx‚ü© := ih.mp hv;
      use x;
      constructor;
      . use v;
      . assumption;
    . intro h;
      obtain ‚ü®y, Rxy, hy‚ü© := h;
      obtain ‚ü®u, Rxu, Ruy‚ü© := Rxy;
      simp;
      apply dia_def.mpr;
      use u;
      constructor;
      . exact Rxu;
      . apply ih.mpr;
        use y;

end Formula.kripke_satisfies


def Formula.valid_on_KripkeModel (M : Model Œ± Œ≤) (f : Formula Œ≤) := ‚àÄ w, (M, w) ‚äß f

namespace Formula.valid_on_KripkeModel

protected instance : Semantics (Formula Œ≤) (Model Œ± Œ≤) := ‚ü®fun M ‚Ü¶ Formula.valid_on_KripkeModel M‚ü©

@[simp] protected lemma iff_models {M : Model Œ± Œ≤} : M ‚äß f ‚Üî valid_on_KripkeModel M f := iff_of_eq rfl

instance : Semantics.Bot (Model Œ± Œ≤) where
  realize_bot M := by
    obtain ‚ü®x, hx‚ü© := M.Frame.World_nonempty;
    simp [valid_on_KripkeModel, kripke_satisfies];
    use x, hx;


end Formula.valid_on_KripkeModel


def Formula.valid_on_KripkeFrame (F : Frame Œ±) (p : Formula Œ≤) := ‚àÄ V : Valuation F Œ≤, (‚ü®F, V‚ü© : Model Œ± Œ≤) ‚äß p

namespace Formula.valid_on_KripkeFrame

protected instance semantics : Semantics (Formula Œ≤) (Frame' Œ± Œ≤) := ‚ü®fun F ‚Ü¶ Formula.valid_on_KripkeFrame F‚ü©

variable {F : Frame' Œ± Œ≤}

@[simp] protected lemma models_iff : F ‚äß p ‚Üî valid_on_KripkeFrame F p := iff_of_eq rfl


instance : Semantics.Bot (Frame' Œ± Œ≤) where
  realize_bot _ := by simp [valid_on_KripkeFrame];


protected lemma axiomK : F ‚äß* ùóû := by
  simp [valid_on_KripkeFrame, valid_on_KripkeModel, System.Axioms.K];
  intro _ p q epq V x hx; subst epq;
  intro h‚ÇÅ h‚ÇÇ y rxy;
  exact h‚ÇÅ rxy $ h‚ÇÇ rxy;

protected lemma nec (h : F ‚äß p) : F ‚äß ‚ñ°p := by
  intro V x y _;
  exact h V y;

protected lemma mdp (hpq : F ‚äß p ‚ü∂ q) (hp : F ‚äß p) : F ‚äß q := by
  intro V x;
  exact (hpq V x) (hp V x);

end Formula.valid_on_KripkeFrame


@[simp] def Formula.valid_on_KripkeFrameClass (ùîΩ : FrameClass) (p : Formula Œ≤) := ‚àÄ {Œ±}, ‚àÄ (F : Frame' Œ± Œ≤), F ‚àà (ùîΩ Œ±) ‚Üí F ‚äß p

namespace Formula.valid_on_KripkeFrameClass

protected instance semantics : Semantics (Formula Œ≤) (FrameClass' Œ≤) := ‚ü®fun ùîΩ ‚Ü¶ Formula.valid_on_KripkeFrameClass ùîΩ‚ü©

variable {ùîΩ : FrameClass' Œ≤}

@[simp] protected lemma models_iff : ùîΩ ‚äß f ‚Üî Formula.valid_on_KripkeFrameClass ùîΩ f := iff_of_eq rfl


protected lemma axiomK : ùîΩ ‚äß* ùóû := by
  simp only [Semantics.RealizeSet.setOf_iff];
  rintro f ‚ü®p, q, _‚ü© _ F _;
  apply (Semantics.RealizeSet.setOf_iff.mp $ valid_on_KripkeFrame.axiomK) f;
  use p, q;

protected lemma nec (h : ùîΩ ‚äß p) : ùîΩ ‚äß ‚ñ°p := by
  intro _ F hF;
  apply valid_on_KripkeFrame.nec;
  exact h F hF;

protected lemma mdp (hpq : ùîΩ ‚äß p ‚ü∂ q) (hp : ùîΩ ‚äß p) : ùîΩ ‚äß q := by
  intro _ F hF;
  exact valid_on_KripkeFrame.mdp (hpq F hF) (hp F hF)

end Formula.valid_on_KripkeFrameClass


namespace AxiomSet

variable {Ax Ax‚ÇÅ Ax‚ÇÇ : AxiomSet Œ≤}

def DefinesKripkeFrameClass (Ax : AxiomSet Œ≤) (ùîΩ : FrameClass) := ‚àÄ {Œ±}, ‚àÄ {F : Frame' Œ± Œ≤}, F ‚äß* Ax ‚Üî F ‚àà (ùîΩ Œ±)

lemma DefinesKripkeFrameClass.union (defines‚ÇÅ : Ax‚ÇÅ.DefinesKripkeFrameClass ùîΩ‚ÇÅ) (defines‚ÇÇ : Ax‚ÇÇ.DefinesKripkeFrameClass ùîΩ‚ÇÇ)
  : (Ax‚ÇÅ ‚à™ Ax‚ÇÇ).DefinesKripkeFrameClass (ùîΩ‚ÇÅ ‚à© ùîΩ‚ÇÇ) := by
  intro _ F;
  simp only [Semantics.RealizeSet.union_iff];
  constructor;
  . intro ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©;
    constructor;
    . exact defines‚ÇÅ.mp h‚ÇÅ;
    . exact defines‚ÇÇ.mp h‚ÇÇ;
  . intro ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©;
    constructor;
    . apply defines‚ÇÅ.mpr h‚ÇÅ;
    . apply defines‚ÇÇ.mpr h‚ÇÇ;


def FinitelyDefinesKripkeFrameClass (Ax : AxiomSet Œ≤) (ùîΩ : FrameClass' Œ≤) := ‚àÄ {F : Frame' Œ± Œ≤}, F.finite ‚Üí (F ‚äß* Ax ‚Üî F ‚àà (ùîΩ Œ±))

/-
def FinitelyDefinesKripkeFrameClass.union (defines‚ÇÅ : Ax‚ÇÅ.FinitelyDefinesKripkeFrameClass ùîΩ‚ÇÅ) (defines‚ÇÇ : Ax‚ÇÇ.FinitelyDefinesKripkeFrameClass ùîΩ‚ÇÇ)
  : (Ax‚ÇÅ ‚à™ Ax‚ÇÇ).FinitelyDefinesKripkeFrameClass (ùîΩ‚ÇÅ ‚à© ùîΩ‚ÇÇ) := by
  intro F hF;
  simp [Semantics.RealizeSet.union_iff];
  constructor;
  . rintro ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©;
    constructor;
    . simpa [hF] using defines‚ÇÅ hF |>.mp h‚ÇÅ;
    . simpa [hF] using defines‚ÇÇ hF |>.mp h‚ÇÇ;
  . intro ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©;
    constructor;
    . simpa [hF] using defines‚ÇÅ hF |>.mpr h‚ÇÅ;
    . simpa [hF] using defines‚ÇÇ hF |>.mpr h‚ÇÇ;


lemma DefinesKripkeFrameClass.toFinitely (defines : Ax.DefinesKripkeFrameClass ùîΩ) : Ax.FinitelyDefinesKripkeFrameClass ùîΩ := by
  intro F _;
  constructor;
  . intro h;
    exact defines.mp h
  . rintro h‚ÇÅ;
    exact defines.mpr (by simpa);

instance {ùîΩ : FrameClass Œ±} (ne : ùîΩ·∂†.Nonempty) : ùîΩ.Nonempty := by
  obtain ‚ü®F, hF‚ü© := ne;
  simp [FrameClass.toFinite] at hF;
  use F;
  exact hF.1;
-/

end AxiomSet


namespace Kripke

open Formula
open AxiomSet (DefinesKripkeFrameClass)

abbrev AllFrameClass : FrameClass := Œª _ => Set.univ
abbrev AllFrameClass' (Œ≤ : Type*) : FrameClass' Œ≤ := AllFrameClass

lemma AllFrameClass.nonempty : AllFrameClass.Nonempty := by
  use Fin 1, TerminalFrame;
  trivial;

lemma axiomK_defines : ùóû.DefinesKripkeFrameClass (Œ≤ := Œ≤) (AllFrameClass) := by
  intro F;
  simp only [Set.mem_univ, iff_true];
  exact valid_on_KripkeFrame.axiomK;

lemma axiomK_union_definability {Ax : AxiomSet Œ≤} {ùîΩ : FrameClass' Œ≤} : (Ax.DefinesKripkeFrameClass ùîΩ) ‚Üî (ùóû ‚à™ Ax).DefinesKripkeFrameClass ùîΩ := by
  constructor;
  . intro defines _ F;
    simp [DefinesKripkeFrameClass] at defines;
    constructor;
    . intro h;
      simp only [Semantics.RealizeSet.union_iff] at h;
      exact defines.mp h.2;
    . intro h;
      simp only [Semantics.RealizeSet.union_iff];
      constructor;
      . apply valid_on_KripkeFrame.axiomK;
      . exact defines.mpr h;
  . intro defines _ F;
    simp only [DefinesKripkeFrameClass] at defines;
    constructor;
    . intro h;
      apply defines.mp;
      simp only [Semantics.RealizeSet.union_iff];
      constructor;
      . apply valid_on_KripkeFrame.axiomK;
      . exact h;
    . intro h;
      simp only [Semantics.RealizeSet.union_iff] at defines;
      exact defines.mpr h |>.2;


/-
def nonempty_of_exist_finiteFrame {ùîΩ : FrameClass Œ±} (h : ‚àÉ (F : FiniteFrame Œ±), F.toFrame ‚àà ùîΩ) : ùîΩ·∂†.Nonempty := by
  obtain ‚ü®F, hF‚ü© := h;
  use F.toFrame;
  constructor;
  . assumption;
  . exact F.World_finite;
-/

end Kripke


namespace DeductionParameter

open Kripke
variable {Œõ Œõ‚ÇÅ Œõ‚ÇÇ : DeductionParameter Œ±} [Œõ.IsNormal]
variable {Ax : AxiomSet Œ±}

abbrev DefinesKripkeFrameClass (Œõ : DeductionParameter Œ±) [Œõ.IsNormal] (ùîΩ : FrameClass) := AxiomSet.DefinesKripkeFrameClass (Ax(Œõ)) ùîΩ

lemma DefinesKripkeFrameClass.toAx (defines : Œõ.DefinesKripkeFrameClass ùîΩ) : Ax(Œõ).DefinesKripkeFrameClass ùîΩ := by
  simp [DefinesKripkeFrameClass] at defines;
  exact defines;

lemma DefinesKripkeFrameClass.toAx' (defines : Ax·¥∫.DefinesKripkeFrameClass ùîΩ) : Ax.DefinesKripkeFrameClass ùîΩ := by
  simp [DefinesKripkeFrameClass] at defines;
  exact axiomK_union_definability.mpr defines;

lemma DefinesKripkeFrameClass.ofAx (defines : Ax.DefinesKripkeFrameClass ùîΩ) [Ax·¥∫.IsNormal] : (Ax)·¥∫.DefinesKripkeFrameClass ùîΩ := by
  apply axiomK_union_definability.mp;
  assumption;


-- abbrev FinitelyDefinesKripkeFrameClass (Œõ : DeductionParameter Œ±) [Œõ.IsNormal] (ùîΩ : FrameClass) := AxiomSet.FinitelyDefinesKripkeFrameClass (Ax(Œõ)) ùîΩ

end DeductionParameter



end LO.Modal.Standard
