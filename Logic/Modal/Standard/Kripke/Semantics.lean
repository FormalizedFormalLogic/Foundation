import Logic.Logic.System
import Logic.Modal.Standard.Formula
import Logic.Modal.Standard.Deduction

universe u v


namespace LO.Modal.Standard

def RelItr (R : Œ± ‚Üí Œ± ‚Üí Prop) : ‚Ñï ‚Üí Œ± ‚Üí Œ± ‚Üí Prop
  | 0 => (¬∑ = ¬∑)
  | n + 1 => fun x y ‚Ü¶ ‚àÉ z, R x z ‚àß RelItr R n z y

namespace RelItr

@[simp]
lemma iff_zero {R : Œ± ‚Üí Œ± ‚Üí Prop} {x y : Œ±} : RelItr R 0 x y ‚Üî x = y := iff_of_eq rfl

@[simp]
lemma iff_succ {R : Œ± ‚Üí Œ± ‚Üí Prop} {x y : Œ±} : RelItr R (n + 1) x y ‚Üî ‚àÉ z, R x z ‚àß RelItr R n z y := iff_of_eq rfl

@[simp]
lemma eq : RelItr (Œ± := Œ±) (¬∑ = ¬∑) n = (¬∑ = ¬∑) := by
  induction n with
  | zero => rfl;
  | succ n ih => aesop

lemma forward {R} {n : ‚Ñï} : (RelItr R (n + 1) x y) ‚Üî ‚àÉ z, RelItr R n x z ‚àß R z y := by
  induction n generalizing x y with
  | zero => simp_all;
  | succ n ih =>
    constructor;
    . rintro ‚ü®z, Rxz, Rzy‚ü©;
      obtain ‚ü®w, Rzw, Rwy‚ü© := ih.mp Rzy;
      use w;
      constructor;
      . use z;
      . assumption;
    . rintro ‚ü®z, ‚ü®w, Rxw, Rwz‚ü©, Rzy‚ü©;
      use w;
      constructor;
      . assumption;
      . apply ih.mpr;
        use z;

end RelItr

namespace Kripke


structure Frame where
  World : Type*
  Rel : Rel World World
  [World_nonempty : Nonempty World]

instance {F : Frame} : Nonempty F.World := F.World_nonempty

instance : CoeSort Frame (Type u) := ‚ü®Frame.World‚ü©
instance : CoeFun Frame (Œª F => F.World ‚Üí F.World ‚Üí Prop) := ‚ü®Frame.Rel‚ü©

abbrev Frame.Rel' {F : Frame} (x y : F.World) := F.Rel x y
scoped infix:45 " ‚â∫ " => Frame.Rel'

protected abbrev Frame.RelItr' {F : Frame} (n : ‚Ñï) : _root_.Rel F.World F.World := RelItr (¬∑ ‚â∫ ¬∑) n
scoped notation x:45 " ‚â∫^[" n "] " y:46 => Frame.RelItr' n x y

noncomputable abbrev Frame.default {F : Frame} : F.World := Classical.choice F.World_nonempty
notation "Ôπ´" => Frame.default

namespace Frame.RelItr'

lemma congr {F : Frame} {x y : F.World} {n m : ‚Ñï} (h : x ‚â∫^[n] y) (he : n = m := by omega) : x ‚â∫^[m] y := by
  subst_vars; exact h;


lemma forward {F : Frame} {x y : F.World} : x ‚â∫^[n + 1] y ‚Üî ‚àÉ z, x ‚â∫^[n] z ‚àß z ‚â∫ y := RelItr.forward

lemma comp {F : Frame} {x y : F.World} {n m : ‚Ñï} : (‚àÉ z, x ‚â∫^[n] z ‚àß z ‚â∫^[m] y) ‚Üî x ‚â∫^[n + m] y := by
  constructor;
  . rintro ‚ü®z, hzx, hzy‚ü©;
    induction n generalizing x with
    | zero => simp_all;
    | succ n ih =>
      suffices x ‚â∫^[(n + m + 1)] y by apply congr this;
      obtain ‚ü®w, hxw, hwz‚ü© := hzx;
      use w;
      constructor;
      . exact hxw;
      . exact @ih w hwz;
  . rintro h;
    induction n generalizing x with
    | zero => simp_all;
    | succ n ih =>
      have rxy : x ‚â∫^[n + m + 1] y := congr h;
      obtain ‚ü®w, rxw, rwy‚ü© := rxy;
      obtain ‚ü®u, rwu, ruy‚ü© := @ih w rwy;
      use u;
      constructor;
      . use w;
      . assumption;

lemma comp' {F : Frame} {x y : F.World} {n m : ‚Ñï+} : (‚àÉ z, x ‚â∫^[n] z ‚àß z ‚â∫^[m] y) ‚Üî x ‚â∫^[n + m] y := comp

end Frame.RelItr'


set_option linter.unusedVariables false in
/-- dependent-version frame -/
abbrev Frame.Dep (Œ± : Type*) := Frame

abbrev Frame.alt (F : Frame) {Œ±} : Frame.Dep Œ± := F
scoped postfix:max "#" => Frame.alt


structure FiniteFrame extends Frame where
  [World_finite : Finite World]

instance {F : FiniteFrame} : Finite (F.World) := F.World_finite
instance : Coe (FiniteFrame) (Frame) := ‚ü®Œª F ‚Ü¶ F.toFrame‚ü©


open Relation (ReflTransGen TransGen)

protected abbrev Frame.RelReflTransGen {F : Frame} : _root_.Rel F.World F.World:= ReflTransGen (¬∑ ‚â∫ ¬∑)
scoped infix:45 " ‚â∫^* " => Frame.RelReflTransGen

namespace Frame.RelReflTransGen

variable {F : Frame}

@[simp] lemma single {x y : F.World} (hxy : x ‚â∫ y) : x ‚â∫^* y := ReflTransGen.single hxy

@[simp] lemma reflexive : Reflexive F.RelReflTransGen := Relation.reflexive_reflTransGen

@[simp] lemma refl {x : F.World} : x ‚â∫^* x := reflexive x

@[simp] lemma transitive : Transitive F.RelReflTransGen := Relation.transitive_reflTransGen

@[simp] lemma symmetric : Symmetric F.Rel ‚Üí Symmetric F.RelReflTransGen := ReflTransGen.symmetric

end Frame.RelReflTransGen


abbrev Frame.TransitiveReflexiveClosure (F : Frame) : Frame where
  World := F.World
  Rel := (¬∑ ‚â∫^* ¬∑)
postfix:max "^*" => Frame.TransitiveReflexiveClosure

namespace Frame.TransitiveReflexiveClosure

variable {F : Frame}

lemma single {x y : F.World} (hxy : x ‚â∫ y) : F^* x y := ReflTransGen.single hxy

lemma rel_reflexive : Reflexive F^* := by intro x; exact ReflTransGen.refl;

lemma rel_transitive : Transitive F^* := by simp;

lemma rel_symmetric : Symmetric F.Rel ‚Üí Symmetric F^* := ReflTransGen.symmetric

end Frame.TransitiveReflexiveClosure


def Frame.RelItr'.toReflTransGen {F : Frame} {x y : F.World} {n : ‚Ñï} (h : x ‚â∫^[n] y) : x ‚â∫^* y := by
  induction n generalizing x y with
  | zero => subst h; exact Relation.ReflTransGen.refl;
  | succ n ih =>
    obtain ‚ü®z, Rxz, Rzy‚ü© := h;
    exact Relation.ReflTransGen.head Rxz $ ih Rzy;


protected abbrev Frame.RelTransGen {F : Frame} : _root_.Rel F.World F.World := TransGen (¬∑ ‚â∫ ¬∑)
scoped infix:45 " ‚â∫^+ " => Frame.RelTransGen

namespace Frame.RelTransGen

variable {F : Frame}

@[simp] lemma single {x y : F.World} (hxy : x ‚â∫ y) : x ‚â∫^+ y := TransGen.single hxy

@[simp]
lemma transitive : Transitive F.RelTransGen := Œª _ _ _ => TransGen.trans

@[simp]
lemma symmetric (hSymm : Symmetric F.Rel) : Symmetric F.RelTransGen := by
  intro x y rxy;
  induction rxy with
  | single h => exact TransGen.single $ hSymm h;
  | tail _ hyz ih => exact TransGen.trans (TransGen.single $ hSymm hyz) ih

end Frame.RelTransGen



abbrev Frame.TransitiveClosure (F : Frame) : Frame where
  World := F.World
  Rel := (¬∑ ‚â∫^+ ¬∑)
scoped postfix:max "^+" => Frame.TransitiveClosure

namespace Frame.TransitiveClosure

variable {F : Frame}

lemma single {x y : F.World} (hxy : x ‚â∫ y) : F^+ x y := TransGen.single hxy

lemma rel_transitive : Transitive F^+ := by simp;

lemma rel_symmetric (hSymm : Symmetric F.Rel) : Symmetric F.TransitiveClosure := by simp_all

end Frame.TransitiveClosure


abbrev FrameClass := Set (Frame)

set_option linter.unusedVariables false in
/-- dependent-version frame class -/
abbrev FrameClass.Dep (Œ± : Type*) := FrameClass

abbrev FrameClass.alt (ùîΩ : FrameClass) {Œ±} : FrameClass.Dep Œ± := ùîΩ
scoped postfix:max "#" => FrameClass.alt


abbrev FiniteFrameClass := Set (FiniteFrame)

@[simp]
def FiniteFrameClass.toFrameClass (ùîΩ : FiniteFrameClass) : FrameClass := { F | ‚àÉ F', F' ‚àà ùîΩ ‚àß F'.toFrame = F }
instance : Coe (FiniteFrameClass) (FrameClass) := ‚ü®FiniteFrameClass.toFrameClass‚ü©

@[simp]
def FrameClass.toFiniteFrameClass (ùîΩ : FrameClass) : FiniteFrameClass := { F | F.toFrame ‚àà ùîΩ }
instance : Coe (FrameClass) (FiniteFrameClass) := ‚ü®FrameClass.toFiniteFrameClass‚ü©

@[simp]
abbrev FrameClass.restrictFinite (ùîΩ : FrameClass) : FrameClass := FiniteFrameClass.toFrameClass ‚ÜëùîΩ
postfix:max "Íü≥" => FrameClass.restrictFinite

lemma FrameClass.iff_mem_restrictFinite {ùîΩ : FrameClass} (h : F ‚àà ùîΩ) (F_finite : Finite F.World) : F ‚àà ùîΩÍü≥ := by
  simp;
  use { toFrame := F, World_finite := F_finite };


/-- Frame with single world and identiy relation -/
abbrev terminalFrame : FiniteFrame where
  World := Unit;
  Rel := Œª _ _ => True

@[simp]
lemma terminalFrame.iff_rel' {x y : terminalFrame.World} : x ‚â∫ y ‚Üî x = y := by
  simp [Frame.Rel'];

@[simp]
lemma terminalFrame.iff_relItr' {x y : terminalFrame.World} : x ‚â∫^[n] y ‚Üî x = y := by
  induction n with
  | zero => simp;
  | succ n ih => simp_all; use ();


abbrev PointFrame : FiniteFrame where
  World := Unit
  Rel := (Œª _ _ => False)

@[simp]
lemma PointFrame.iff_rel' {x y : PointFrame.World} : ¬¨(x ‚â∫ y) := by simp [Frame.Rel'];


abbrev Valuation (F : Frame) (Œ± : Type*) := F.World ‚Üí Œ± ‚Üí Prop

structure Model (Œ±) where
  Frame : Frame
  Valuation : Valuation Frame Œ±

abbrev Model.World (M : Model Œ±) := M.Frame.World
instance : CoeSort (Model Œ±) (Type u) := ‚ü®Model.World‚ü©

/-
structure FiniteModel (Œ±) extends Model Œ± where
  [World_finite : Finite World]

instance {M : FiniteModel Œ±} : Finite M.World := M.World_finite

def FiniteModel.FiniteFrame (M : FiniteModel Œ±) : Kripke.FiniteFrame where
  World := M.World
  Rel := M.Frame.Rel
-/

end Kripke


variable {World Œ± : Type*}

open Standard.Kripke

def Formula.Kripke.Satisfies (M : Kripke.Model Œ±) (x : M.World) : Formula Œ± ‚Üí Prop
  | atom a  => M.Valuation x a
  | natom a => ¬¨M.Valuation x a
  | ‚ä§  => True
  | ‚ä•  => False
  | p ‚ãè q => (Satisfies M x p) ‚àß (Satisfies M x q)
  | p ‚ãé q => (Satisfies M x p) ‚à® (Satisfies M x q)
  | ‚ñ°p   => ‚àÄ y, x ‚â∫ y ‚Üí (Satisfies M y p)
  | ‚óáp   => ‚àÉ y, x ‚â∫ y ‚àß (Satisfies M y p)

namespace Formula.Kripke.Satisfies

protected instance semantics {M : Kripke.Model Œ±} : Semantics (Formula Œ±) (M.World) := ‚ü®fun x ‚Ü¶ Formula.Kripke.Satisfies M x‚ü©

variable {M : Kripke.Model Œ±} {x : M.World} {p q : Formula Œ±}

@[simp] protected lemma iff_models : x ‚äß p ‚Üî Kripke.Satisfies M x p := iff_of_eq rfl

lemma or_def : x ‚äß p ‚ãé q ‚Üî x ‚äß p ‚à® x ‚äß q := by constructor <;> { simp [Satisfies]; }

lemma and_def : x ‚äß p ‚ãè q ‚Üî x ‚äß p ‚àß x ‚äß q := by constructor <;> { simp [Satisfies]; }

lemma not_def : x ‚äß ~p ‚Üî ¬¨(x ‚äß p) := by
  induction p using Formula.rec' generalizing x with
  | hbox p ih =>
    simp_all [Satisfies];
    constructor;
    . rintro ‚ü®y, Rxy, h‚ü©;
      use y;
      constructor;
      . assumption;
      . exact ih.mp h;
    . rintro ‚ü®y, Rxy, h‚ü©;
      use y;
      constructor;
      . assumption;
      . exact ih.mpr h;
  | hdia p ih =>
    simp_all [Satisfies];
    constructor;
    . intro h y Rxy; exact ih.mp $ h y Rxy;
    . intro h y Rxy; exact ih.mpr $ h y Rxy;
  | _ =>
    simp_all [Satisfies]
    try tauto;

@[simp]
lemma imp_def : x ‚äß p ‚ü∂ q ‚Üî (x ‚äß p) ‚Üí (x ‚äß q) := by
  constructor;
  . intro hpq;
    apply imp_iff_not_or (b := x ‚äß q) |>.mpr;
    rcases hpq with (hp | hq);
    . left; exact not_def.mp hp;
    . right; exact hq;
  . intro hpq;
    simp only [Formula.imp_eq];
    rcases imp_iff_not_or.mp hpq with (hp | hq);
    . left; exact not_def.mpr hp;
    . right; exact hq;

protected instance tarski : Semantics.Tarski (M.World) where
  realize_top := by intro; tauto;
  realize_bot := by tauto;
  realize_not := not_def;
  realize_and := and_def;
  realize_or  := or_def;
  realize_imp := imp_def;


lemma dia_def : x ‚äß ‚óáp ‚Üî ‚àÉ y, x ‚â∫ y ‚àß y ‚äß p := by simp [Kripke.Satisfies];

lemma multibox_def : x ‚äß ‚ñ°^[n]p ‚Üî ‚àÄ {y}, x ‚â∫^[n] y ‚Üí y ‚äß p := by
  induction n generalizing x with
  | zero => aesop;
  | succ n ih =>
    constructor;
    . intro h y Rxy;
      simp [Kripke.Satisfies] at h;
      obtain ‚ü®u, Rxu, Ruy‚ü© := Rxy;
      exact (ih.mp $ h _ Rxu) Ruy;
    . simp;
      intro h y Rxy;
      apply ih.mpr;
      intro u Ryu;
      exact h _ Rxy Ryu;

lemma multidia_def : x ‚äß ‚óá^[n]p ‚Üî ‚àÉ y, x ‚â∫^[n] y ‚àß y ‚äß p := by
  induction n generalizing x with
  | zero => simp;
  | succ n ih =>
    constructor;
    . intro h;
      replace h : x ‚äß (‚óá‚óá^[n]p) := by simpa using h;
      obtain ‚ü®v, hwv, hv‚ü© := dia_def.mp h;
      obtain ‚ü®x, hvx, hx‚ü© := ih.mp hv;
      use x;
      constructor;
      . use v;
      . assumption;
    . intro h;
      obtain ‚ü®y, Rxy, hy‚ü© := h;
      obtain ‚ü®u, Rxu, Ruy‚ü© := Rxy;
      simp;
      apply dia_def.mpr;
      use u;
      constructor;
      . exact Rxu;
      . apply ih.mpr;
        use y;

lemma trans (hpq : x ‚äß p ‚ü∂ q) (hqr : x ‚äß q ‚ü∂ r) : x ‚äß p ‚ü∂ r := by simp_all;

lemma mdp (hpq : x ‚äß p ‚ü∂ q) (hp : x ‚äß p) : x ‚äß q := by simp_all;

end Formula.Kripke.Satisfies


def Formula.Kripke.ValidOnModel (M : Kripke.Model Œ±) (p : Formula Œ±) := ‚àÄ x : M.World, x ‚äß p

namespace Formula.Kripke.ValidOnModel

protected instance : Semantics (Formula Œ±) (Kripke.Model Œ±) := ‚ü®fun M ‚Ü¶ Formula.Kripke.ValidOnModel M‚ü©

@[simp] protected lemma iff_models {M : Kripke.Model Œ±} : M ‚äß f ‚Üî Kripke.ValidOnModel M f := iff_of_eq rfl

instance : Semantics.Bot (Kripke.Model Œ±) where
  realize_bot M := by simp [Kripke.ValidOnModel, Kripke.Satisfies];

variable {M : Model Œ±} {p q r : Formula Œ±}

protected lemma mdp (hpq : M ‚äß p ‚ü∂ q) (hp : M ‚äß p) : M ‚äß q := by
  intro x;
  exact (Satisfies.imp_def.mp $ hpq x) (hp x);

protected lemma nec (h : M ‚äß p) : M ‚äß ‚ñ°p := by
  intro x y _;
  exact h y;

protected lemma verum : M ‚äß ‚ä§ := by intro; tauto;

protected lemma imply‚ÇÅ : M ‚äß (Axioms.Imply‚ÇÅ p q) := by simp [ValidOnModel]; tauto;

protected lemma imply‚ÇÇ : M ‚äß (Axioms.Imply‚ÇÇ p q r) := by simp [ValidOnModel]; tauto;

protected lemma andElim‚ÇÅ : M ‚äß (Axioms.AndElim‚ÇÅ p q) := by simp [ValidOnModel]; tauto;

protected lemma andElim‚ÇÇ : M ‚äß (Axioms.AndElim‚ÇÇ p q) := by simp [ValidOnModel];

protected lemma andInst : M ‚äß (Axioms.AndInst p q) := by simp [ValidOnModel]; tauto;

protected lemma orInst‚ÇÅ : M ‚äß (Axioms.OrInst‚ÇÅ p q) := by simp [ValidOnModel]; tauto;

protected lemma orInst‚ÇÇ : M ‚äß (Axioms.OrInst‚ÇÇ p q) := by simp [ValidOnModel]; tauto;

protected lemma orElim : M ‚äß (Axioms.OrElim p q r) := by simp [ValidOnModel]; tauto;

protected lemma dne : M ‚äß (Axioms.DNE p) := by simp [ValidOnModel];

protected lemma negEquiv : M ‚äß (Axioms.NegEquiv p) := by simp [ValidOnModel];

protected lemma diaDual : M ‚äß (Axioms.DiaDuality p) := by
  intro x;
  simp [ValidOnModel, Satisfies];
  constructor;
  . rintro ‚ü®y, Rxy, hy‚ü©; use y;
    constructor;
    . exact Rxy;
    . intro h; replace h:= Satisfies.not_def.mp h;
      contradiction;
  . rintro ‚ü®y, Rxy, hy‚ü©; use y;
    constructor;
    . exact Rxy;
    . replace hy := Satisfies.not_def.not.mp hy;
      tauto;

protected lemma axiomK : M ‚äß (Axioms.K p q)  := by
  intro V;
  apply Satisfies.imp_def.mpr;
  intro hpq;
  apply Satisfies.imp_def.mpr;
  intro hp x Rxy;
  replace hpq := Satisfies.imp_def.mp $ hpq x Rxy;
  replace hp := hp x Rxy;
  exact hpq hp;

end Formula.Kripke.ValidOnModel


def Formula.Kripke.ValidOnFrame (F : Frame) (p : Formula Œ±) := ‚àÄ V, (‚ü®F, V‚ü© : Kripke.Model Œ±) ‚äß p

namespace Formula.Kripke.ValidOnFrame

protected instance semantics : Semantics (Formula Œ±) (Frame.Dep Œ±) := ‚ü®fun F ‚Ü¶ Formula.Kripke.ValidOnFrame F‚ü©

variable {F : Frame.Dep Œ±}

@[simp] protected lemma models_iff : F ‚äß p ‚Üî Kripke.ValidOnFrame F p := iff_of_eq rfl

instance : Semantics.Bot (Frame.Dep Œ±) where
  realize_bot _ := by simp [Kripke.ValidOnFrame];

protected lemma mdp (hpq : F ‚äß p ‚ü∂ q) (hp : F ‚äß p) : F ‚äß q := by intro V; exact ValidOnModel.mdp (hpq V) (hp V);

protected lemma nec (h : F ‚äß p) : F ‚äß ‚ñ°p := by intro V; exact ValidOnModel.nec (h V);

protected lemma verum : F ‚äß ‚ä§ := by intros _; tauto;

protected lemma imply‚ÇÅ : F ‚äß (Axioms.Imply‚ÇÅ p q) := by intro V; exact ValidOnModel.imply‚ÇÅ (M := ‚ü®F, V‚ü©);

protected lemma imply‚ÇÇ : F ‚äß (Axioms.Imply‚ÇÇ p q r) := by intro V; exact ValidOnModel.imply‚ÇÇ (M := ‚ü®F, V‚ü©);

protected lemma andElim‚ÇÅ : F ‚äß (Axioms.AndElim‚ÇÅ p q) := by intro V; exact ValidOnModel.andElim‚ÇÅ (M := ‚ü®F, V‚ü©);

protected lemma andElim‚ÇÇ : F ‚äß (Axioms.AndElim‚ÇÇ p q) := by intro V; exact ValidOnModel.andElim‚ÇÇ (M := ‚ü®F, V‚ü©);

protected lemma andInst : F ‚äß (Axioms.AndInst p q) := by intro V; exact ValidOnModel.andInst (M := ‚ü®F, V‚ü©);

protected lemma orInst‚ÇÅ : F ‚äß (Axioms.OrInst‚ÇÅ p q) := by intro V; exact ValidOnModel.orInst‚ÇÅ (M := ‚ü®F, V‚ü©);

protected lemma orInst‚ÇÇ : F ‚äß (Axioms.OrInst‚ÇÇ p q) := by intro V; exact ValidOnModel.orInst‚ÇÇ (M := ‚ü®F, V‚ü©);

protected lemma orElim : F ‚äß (Axioms.OrElim p q r) := by intro V; exact ValidOnModel.orElim (M := ‚ü®F, V‚ü©);

protected lemma dne : F ‚äß (Axioms.DNE p) := by intro V; exact ValidOnModel.dne (M := ‚ü®F, V‚ü©);

protected lemma negEquiv : F ‚äß (Axioms.NegEquiv p) := by intro V; exact ValidOnModel.negEquiv (M := ‚ü®F, V‚ü©);

protected lemma diaDual : F ‚äß (Axioms.DiaDuality p) := by intro V; exact ValidOnModel.diaDual (M := ‚ü®F, V‚ü©);

protected lemma axiomK : F ‚äß (Axioms.K p q) := by intro V; exact ValidOnModel.axiomK (M := ‚ü®F, V‚ü©);

protected lemma axiomK_set : F ‚äß* ùóû := by
  simp [Semantics.realizeSet_iff];
  rintro f x y rfl;
  exact ValidOnFrame.axiomK;

end Formula.Kripke.ValidOnFrame


@[simp] def Formula.Kripke.ValidOnFrameClass (ùîΩ : FrameClass) (p : Formula Œ±) := ‚àÄ {F : Frame}, F ‚àà ùîΩ ‚Üí F# ‚äß p

namespace Formula.Kripke.ValidOnFrameClass

protected instance semantics : Semantics (Formula Œ±) (FrameClass.Dep Œ±) := ‚ü®fun ùîΩ ‚Ü¶ Kripke.ValidOnFrameClass ùîΩ‚ü©

variable {ùîΩ : FrameClass.Dep Œ±}

@[simp] protected lemma models_iff : ùîΩ ‚äß p ‚Üî Formula.Kripke.ValidOnFrameClass ùîΩ p := iff_of_eq rfl


@[simp] protected lemma mdp (hpq : ùîΩ ‚äß p ‚ü∂ q) (hp : ùîΩ ‚äß p) : ùîΩ ‚äß q := by intro _ hF; exact ValidOnFrame.mdp (hpq hF) (hp hF)

@[simp] protected lemma nec (h : ùîΩ ‚äß p) : ùîΩ ‚äß ‚ñ°p := by intro _ hF; exact ValidOnFrame.nec (h hF);

@[simp] protected lemma verum : ùîΩ ‚äß ‚ä§ := by intro _ _; tauto;

@[simp] protected lemma imply‚ÇÅ : ùîΩ ‚äß (Axioms.Imply‚ÇÅ p q) := by intro _ _; exact ValidOnFrame.imply‚ÇÅ;

@[simp] protected lemma imply‚ÇÇ : ùîΩ ‚äß (Axioms.Imply‚ÇÇ p q r)  := by intro _ _; exact ValidOnFrame.imply‚ÇÇ;

@[simp] protected lemma andElim‚ÇÅ : ùîΩ ‚äß (Axioms.AndElim‚ÇÅ p q) := by intro _ _; exact ValidOnFrame.andElim‚ÇÅ;

@[simp] protected lemma andElim‚ÇÇ : ùîΩ ‚äß (Axioms.AndElim‚ÇÇ p q) := by intro _ _; exact ValidOnFrame.andElim‚ÇÇ;

@[simp] protected lemma andInst : ùîΩ ‚äß (Axioms.AndInst p q) := by intro _ _; exact ValidOnFrame.andInst;

@[simp] protected lemma orInst‚ÇÅ : ùîΩ ‚äß (Axioms.OrInst‚ÇÅ p q) := by intro _ _; exact ValidOnFrame.orInst‚ÇÅ;

@[simp] protected lemma orInst‚ÇÇ : ùîΩ ‚äß (Axioms.OrInst‚ÇÇ p q) := by intro _ _; exact ValidOnFrame.orInst‚ÇÇ;

@[simp] protected lemma orElim : ùîΩ ‚äß (Axioms.OrElim p q r) := by intro _ _; exact ValidOnFrame.orElim;

@[simp] protected lemma dne : ùîΩ ‚äß (Axioms.DNE p) := by intro _ _; exact ValidOnFrame.dne;

@[simp] protected lemma negEquiv : ùîΩ ‚äß (Axioms.NegEquiv p) := by intro _ _; exact ValidOnFrame.negEquiv;

@[simp] protected lemma diaDual : ùîΩ ‚äß (Axioms.DiaDuality p) := by intro _ _; exact ValidOnFrame.diaDual;

@[simp] protected lemma axiomK : ùîΩ ‚äß (Axioms.K p q) := by intro _ _; exact ValidOnFrame.axiomK;

protected lemma axiomK_set : ùîΩ ‚äß* ùóû := by
  simp [Semantics.realizeSet_iff];
  rintro f x y rfl;
  exact ValidOnFrameClass.axiomK;

end ValidOnFrameClass

end Formula.Kripke

namespace Kripke

open Formula.Kripke

lemma iff_not_validOnFrameClass {ùîΩ : FrameClass} : ¬¨(ùîΩ# ‚äß p) ‚Üî ‚àÉ F ‚àà ùîΩ, ‚àÉ V x, ¬¨Satisfies ‚ü®F, V‚ü© x p := by
  simp [ValidOnFrame, ValidOnModel, Satisfies];

lemma iff_not_set_validOnFrameClass {ùîΩ : FrameClass} : ¬¨(ùîΩ# ‚äß* T) ‚Üî ‚àÉ p ‚àà T, ‚àÉ F ‚àà ùîΩ, ‚àÉ V x, ¬¨Satisfies ‚ü®F, V‚ü© x p  := by
  simp [Semantics.realizeSet_iff, ValidOnFrame, ValidOnModel, Satisfies];

lemma iff_not_validOnFrame {F : Frame} : ¬¨(F# ‚äß* T) ‚Üî ‚àÉ p ‚àà T, ‚àÉ V x, ¬¨Satisfies ‚ü®F, V‚ü© x p  := by
  simp [Semantics.realizeSet_iff, ValidOnFrame, ValidOnModel, Satisfies];

end Kripke

namespace AxiomSet

variable {Ax Ax‚ÇÅ Ax‚ÇÇ : AxiomSet Œ±}

def DefinesKripkeFrameClass (Ax : AxiomSet Œ±) (ùîΩ : FrameClass) := ‚àÄ {F : Frame}, F# ‚äß* Ax ‚Üî F ‚àà ùîΩ

lemma DefinesKripkeFrameClass.union (defines‚ÇÅ : Ax‚ÇÅ.DefinesKripkeFrameClass ùîΩ‚ÇÅ) (defines‚ÇÇ : Ax‚ÇÇ.DefinesKripkeFrameClass ùîΩ‚ÇÇ)
  : (Ax‚ÇÅ ‚à™ Ax‚ÇÇ).DefinesKripkeFrameClass (ùîΩ‚ÇÅ ‚à© ùîΩ‚ÇÇ) := by
  intro F;
  simp only [Semantics.RealizeSet.union_iff];
  constructor;
  . intro ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©;
    constructor;
    . exact defines‚ÇÅ.mp h‚ÇÅ;
    . exact defines‚ÇÇ.mp h‚ÇÇ;
  . intro ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©;
    constructor;
    . apply defines‚ÇÅ.mpr h‚ÇÅ;
    . apply defines‚ÇÇ.mpr h‚ÇÇ;


def FinitelyDefinesKripkeFrameClass (Ax : AxiomSet Œ±) (ùîΩ : FiniteFrameClass) := ‚àÄ {F : FiniteFrame}, (‚ÜëF : Frame)# ‚äß* Ax ‚Üî F ‚àà ùîΩ

lemma FinitelyDefinesKripkeFrameClass.union (defines‚ÇÅ : Ax‚ÇÅ.FinitelyDefinesKripkeFrameClass ùîΩ‚ÇÅ) (defines‚ÇÇ : Ax‚ÇÇ.FinitelyDefinesKripkeFrameClass ùîΩ‚ÇÇ)
  : (Ax‚ÇÅ ‚à™ Ax‚ÇÇ).FinitelyDefinesKripkeFrameClass (ùîΩ‚ÇÅ ‚à© ùîΩ‚ÇÇ) := by
  intro F;
  simp [Semantics.RealizeSet.union_iff];
  constructor;
  . rintro ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©;
    constructor;
    . exact defines‚ÇÅ.mp h‚ÇÅ;
    . exact defines‚ÇÇ.mp h‚ÇÇ;
  . intro ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©;
    constructor;
    . exact defines‚ÇÅ.mpr h‚ÇÅ;
    . exact defines‚ÇÇ.mpr h‚ÇÇ;

end AxiomSet


namespace Kripke

open Formula
open AxiomSet (DefinesKripkeFrameClass)

abbrev AllFrameClass : FrameClass := Set.univ

lemma AllFrameClass.nonempty : AllFrameClass.Nonempty.{0} := by
  use terminalFrame;
  trivial;

lemma axiomK_defines : DefinesKripkeFrameClass (Œ± := Œ±) ùóû AllFrameClass := by
  intro F;
  simp only [Set.mem_univ, iff_true];
  exact Kripke.ValidOnFrame.axiomK_set;

lemma axiomK_union_definability {Ax : AxiomSet Œ±} : (DefinesKripkeFrameClass Ax ùîΩ) ‚Üî DefinesKripkeFrameClass (ùóû ‚à™ Ax) ùîΩ := by
  constructor;
  . intro defines F;
    simp [DefinesKripkeFrameClass] at defines;
    constructor;
    . intro h;
      simp only [Semantics.RealizeSet.union_iff] at h;
      exact defines.mp h.2;
    . intro h;
      simp only [Semantics.RealizeSet.union_iff];
      constructor;
      . apply Kripke.ValidOnFrame.axiomK_set;
      . exact defines.mpr h;
  . intro defines F;
    simp only [DefinesKripkeFrameClass] at defines;
    constructor;
    . intro h;
      apply defines.mp;
      simp only [Semantics.RealizeSet.union_iff];
      constructor;
      . apply Kripke.ValidOnFrame.axiomK_set;
      . exact h;
    . intro h;
      simp only [Semantics.RealizeSet.union_iff] at defines;
      exact defines.mpr h |>.2;

end Kripke


namespace DeductionParameter

open Kripke
variable {Œõ Œõ‚ÇÅ Œõ‚ÇÇ : DeductionParameter Œ±} [Œõ.IsNormal]
variable {Ax : AxiomSet Œ±}

abbrev DefinesKripkeFrameClass (Œõ : DeductionParameter Œ±) [Œõ.IsNormal] (ùîΩ : FrameClass) := AxiomSet.DefinesKripkeFrameClass (Ax(Œõ)) ùîΩ

lemma DefinesKripkeFrameClass.toAx (defines : Œõ.DefinesKripkeFrameClass ùîΩ) : Ax(Œõ).DefinesKripkeFrameClass ùîΩ := by
  simp [DefinesKripkeFrameClass] at defines;
  exact defines;

lemma DefinesKripkeFrameClass.toAx' (defines : (ùùÇAx).DefinesKripkeFrameClass ùîΩ) : Ax.DefinesKripkeFrameClass ùîΩ := by
  simp [DefinesKripkeFrameClass] at defines;
  exact axiomK_union_definability.mpr defines;

lemma DefinesKripkeFrameClass.ofAx (defines : Ax.DefinesKripkeFrameClass ùîΩ) [(ùùÇAx).IsNormal] : (ùùÇAx).DefinesKripkeFrameClass ùîΩ := by
  apply axiomK_union_definability.mp;
  assumption;

end DeductionParameter

end LO.Modal.Standard
