import Logic.Modal.Standard.Kripke.Grz
import Logic.Modal.Standard.Kripke.GL.Completeness

namespace LO.Modal.Standard

namespace Formula

variable [DecidableEq Œ±]

abbrev GrzSubformulas (p : Formula Œ±) := (ùíÆ p) ‚à™ ((ùíÆ p).image (Œª q => ‚ñ°(q ‚ü∂ ‚ñ°q)))
prefix:70 "ùíÆ·¥≥ " => Formula.GrzSubformulas

end Formula

namespace Kripke

open System
open Kripke
open Formula (atom)
open Formula.Kripke

variable {Œ± : Type u} [Inhabited Œ±] [DecidableEq Œ±]
variable {F : Kripke.Frame}


abbrev GrzCanonicalFrame := CanonicalFrame (Œ± := Œ±) ùêÜùê´ùê≥
abbrev GrzCanonicalModel := CanonicalModel (Œ± := Œ±) ùêÜùê´ùê≥

-- TODO: Too slow
set_option maxHeartbeats 1000000 in
abbrev GrzFilteredFrame (p : Formula Œ±) : Kripke.FiniteFrame where
  World := FilterEqvQuotient GrzCanonicalModel ((ùíÆ p).toSet)
  World_finite := by apply FilterEqvQuotient.finite; simp;
  Rel := Quotient.lift‚ÇÇ
    (Œª X Y =>
      (‚àÄ q ‚àà ‚ñ°''‚Åª¬π(ùíÆ·¥≥ p), ‚ñ°q ‚àà X.theory ‚Üí ‚ñ°q ‚àà Y.theory) ‚àß
      ((‚àÄ q ‚àà ‚ñ°''‚Åª¬π(ùíÆ·¥≥ p), ‚ñ°q ‚àà Y.theory ‚Üí ‚ñ°q ‚àà X.theory) ‚Üí X = Y)
    )
    (by
      intro X‚ÇÅ Y‚ÇÅ X‚ÇÇ Y‚ÇÇ hX hY;
      simp only [Formula.GrzSubformulas, Finset.coe_union, Finset.coe_image, Set.preimage_union,
        Function.iterate_one, Set.mem_union, Set.mem_preimage, Finset.mem_coe, Set.mem_image,
        Box.box_injective', eq_iff_iff];
      constructor;
      . rintro ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©;
        constructor;
        . rintro q (h_sub | ‚ü®q, h_sub, rfl‚ü©) hq
          . have : ‚ñ°q ‚àà X‚ÇÅ.theory := filter_truthlemma (by simpa only) |>.mpr hq;
            have : ‚ñ°q ‚àà Y‚ÇÅ.theory := h‚ÇÅ q (by left; assumption) this;
            exact filter_truthlemma (by simpa only) |>.mp this;
          . sorry;
            -- have : ‚ñ°(q ‚ü∂ ‚ñ°q) ‚àà X‚ÇÅ.theory := filter_truthlemma (by sorry) |>.mpr hq;
          -- have : ‚ñ°q ‚àà X‚ÇÅ.theory := filter_truthlemma (by simpa only) |>.mpr hq;
          -- have : ‚ñ°q ‚àà Y‚ÇÅ.theory := h‚ÇÅ q (by assumption) this;
          -- exact filter_truthlemma (by simpa only) |>.mp this;
        . sorry;
          /-
          intro h q _;
          constructor;
          . intro hq;
            have : q ‚àà X‚ÇÅ.theory := filter_truthlemma (by simpa only) |>.mpr hq;
            have : q ‚àà Y‚ÇÅ.theory := h‚ÇÇ ?_ q (by assumption) |>.mp this;
            exact filter_truthlemma (by simpa only) |>.mp this;
            intro q _ hq;
            have : ‚ñ°q ‚àà Y‚ÇÇ.theory := filter_truthlemma (by simpa only) |>.mp hq;
            have : ‚ñ°q ‚àà X‚ÇÇ.theory := h q (by assumption) this;
            exact filter_truthlemma (by simpa only) |>.mpr this;
          . intro hq;
            have : q ‚àà Y‚ÇÅ.theory := filter_truthlemma (by simpa only) |>.mpr hq;
            have : q ‚àà X‚ÇÅ.theory := h‚ÇÇ ?_ q (by assumption) |>.mpr this;
            exact filter_truthlemma (by simpa only) |>.mp this;
            intro q _ hq;
            have : ‚ñ°q ‚àà Y‚ÇÇ.theory := filter_truthlemma (by simpa only) |>.mp hq;
            have : ‚ñ°q ‚àà X‚ÇÇ.theory := h q (by assumption) this;
            exact filter_truthlemma (by simpa only) |>.mpr this;
          -/
      . rintro ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©;
        constructor;
        . sorry;
          /-
          intro q _ hq;
          have : ‚ñ°q ‚àà X‚ÇÇ.theory := filter_truthlemma (by simpa only) |>.mp hq;
          have : ‚ñ°q ‚àà Y‚ÇÇ.theory := h‚ÇÅ q (by assumption) this;
          exact filter_truthlemma (by simpa only) |>.mpr this;
          -/
        . sorry;
          /-
          intro h q _;
          constructor;
          . intro hq;
            have : q ‚àà X‚ÇÇ.theory := filter_truthlemma (by simpa only) |>.mp hq;
            have : q ‚àà Y‚ÇÇ.theory := h‚ÇÇ ?_ q (by assumption) |>.mp this;
            exact filter_truthlemma (by simpa only) |>.mpr this;
            intro q _ hq;
            have : ‚ñ°q ‚àà Y‚ÇÅ.theory := filter_truthlemma (by simpa only) |>.mpr hq;
            have : ‚ñ°q ‚àà X‚ÇÅ.theory := h q (by assumption) this;
            exact filter_truthlemma (by simpa only) |>.mp this;
          . intro hq;
            have : q ‚àà Y‚ÇÇ.theory := filter_truthlemma (by simpa only) |>.mp hq;
            have : q ‚àà X‚ÇÇ.theory := h‚ÇÇ ?_ q (by assumption) |>.mpr this;
            exact filter_truthlemma (by simpa only) |>.mpr this;
            intro q _ hq;
            have : ‚ñ°q ‚àà Y‚ÇÅ.theory := filter_truthlemma (by simpa only) |>.mpr hq;
            have : ‚ñ°q ‚àà X‚ÇÅ.theory := h q (by assumption) this;
            exact filter_truthlemma (by simpa only) |>.mp this;
          -/
    )

lemma GrzFilteredFrame.def_rel {p : Formula Œ±} {X Y : GrzCanonicalFrame.World} :
  ((GrzFilteredFrame p).Rel ‚ü¶X‚üß ‚ü¶Y‚üß) ‚Üî
  (
    (‚àÄ q ‚àà ‚ñ°''‚Åª¬π(ùíÆ·¥≥ p), ‚ñ°q ‚àà X.theory ‚Üí ‚ñ°q ‚àà Y.theory) ‚àß
    ((‚àÄ q ‚àà ‚ñ°''‚Åª¬π(ùíÆ·¥≥ p), ‚ñ°q ‚àà Y.theory ‚Üí ‚ñ°q ‚àà X.theory) ‚Üí X = Y)
  )
  := by simp;

lemma GrzFilteredFrame.reflexive {p : Formula Œ±} : Reflexive (GrzFilteredFrame p).Rel := by
  intro QX;
  obtain ‚ü®X, hX‚ü© := Quotient.exists_rep QX; subst hX;
  simp_all;

lemma GrzFilteredFrame.transitive {p : Formula Œ±} : Transitive (GrzFilteredFrame p).Rel := by
  intro QX QY QZ RXY RYZ;
  obtain ‚ü®X, hX‚ü© := Quotient.exists_rep QX; subst hX;
  obtain ‚ü®Y, hY‚ü© := Quotient.exists_rep QY; subst hY;
  obtain ‚ü®Z, hZ‚ü© := Quotient.exists_rep QZ; subst hZ;
  replace ‚ü®hXY‚ÇÅ, hXY‚ÇÇ‚ü© := RXY;
  replace ‚ü®hYZ‚ÇÅ, hYZ‚ÇÇ‚ü© := RYZ;
  constructor;
  . intro q hs hq;
    exact hYZ‚ÇÅ q hs $ hXY‚ÇÅ q hs hq
  . intro h;
    have eXY := hXY‚ÇÇ $ by
      intro q hs hq;
      exact h q hs $ hYZ‚ÇÅ q hs hq;
    have eYZ := hYZ‚ÇÇ $ by
      intro q hs hq;
      exact hXY‚ÇÅ q hs $ h q hs hq
    subst_vars;
    tauto;

lemma GrzFilteredFrame.antisymm {p : Formula Œ±} : Antisymmetric (GrzFilteredFrame p).Rel := by
  intro QX QY RXY RYX;
  obtain ‚ü®X, hX‚ü© := Quotient.exists_rep QX; subst hX;
  obtain ‚ü®Y, hY‚ü© := Quotient.exists_rep QY; subst hY;
  have := RXY.2 RYX.1;
  tauto;

abbrev GrzFilteredModel (p : Formula Œ±) : Kripke.Model Œ± where
  Frame := GrzFilteredFrame p
  Valuation := StandardFilterationValuation GrzCanonicalModel ((ùíÆ p).toSet)

-- TODO: syntactical proof
private lemma K4_lemma1 {q : Formula Œ±} : ùêäùüí ‚ä¢! (‚ñ°q ‚ü∂ ‚ñ°(q ‚ü∂ ‚ñ°q)) := by
  by_contra hC;
  have := (not_imp_not.mpr $ K4_complete (Œ± := Œ±) |>.complete) hC;
  simp only [ValidOnFrameClass.models_iff, ValidOnFrameClass, Set.mem_setOf_eq, Transitive,
    ValidOnFrame.models_iff, ValidOnFrame, ValidOnModel.iff_models, ValidOnModel,
    Satisfies.iff_models, Satisfies, not_forall, Classical.not_imp] at this;
  obtain ‚ü®F, F_trans, V, x, h, y, Rxy, _, z, Ryz, j‚ü© := this;
  have := h (F_trans Rxy Ryz);
  contradiction;

-- TODO: syntactical proof
private lemma KT_lemma1 {q : Formula Œ±} : ùêäùêì ‚ä¢! (q ‚ãè ‚ñ°(q ‚ü∂ ‚ñ°q)) ‚ü∂ ‚ñ°q := by
  by_contra hC;
  have := (not_imp_not.mpr $ KT_complete (Œ± := Œ±) |>.complete) hC;
  simp at this;
  obtain ‚ü®F, F_refl, hF‚ü© := this;
  simp [ValidOnFrame, ValidOnModel, Satisfies] at hF;
  obtain ‚ü®V, x, h‚ÇÅ, h‚ÇÇ, ‚ü®y, Rxy, h‚ÇÉ‚ü©‚ü© := hF;
  have := h‚ÇÇ (F_refl x);
  have := (this h‚ÇÅ) Rxy;
  contradiction;

open System System.FiniteContext MaximalConsistentTheory in
private lemma Grz_truthlemma.lemma
  {q : Formula Œ±}
  {X : (CanonicalModel ùêÜùê´ùê≥).World} (h : ‚ñ°q ‚àâ X.theory) : (ùêÜùê´ùê≥)-Consistent ({‚ñ°(q ‚ü∂ ‚ñ°q), ~q} ‚à™ (‚ñ°''‚ñ°''‚Åª¬πX.theory)) := by
  by_contra hC;
  obtain ‚ü®Œì, hŒì‚ÇÅ, hŒì‚ÇÇ‚ü© := Context.provable_iff.mp hC;
  have := to‚Çõ! hŒì‚ÇÇ;
  have : ùêÜùê´ùê≥ ‚ä¢! ‚ãÄ(Œì.remove (~q)) ‚ãè ~q ‚ü∂ ‚ä• := imply_left_remove_conj! (p := ~q) this;
  have : ùêÜùê´ùê≥ ‚ä¢! ‚ãÄ(Œì.remove (~q)) ‚ü∂ ~q ‚ü∂ ‚ä• := and_imply_iff_imply_imply'!.mp this;
  have : ùêÜùê´ùê≥ ‚ä¢! ‚ãÄ(Œì.remove (~q)) ‚ü∂ q := imp_trans''! this $ imp_trans''! (and‚ÇÇ'! neg_equiv!) dne!
  have : ùêÜùê´ùê≥ ‚ä¢! ‚ãÄ((Œì.remove (~q)).remove (‚ñ°(q ‚ü∂ ‚ñ°q))) ‚ãè (‚ñ°(q ‚ü∂ ‚ñ°q)) ‚ü∂ q := imply_left_remove_conj! (p := ‚ñ°(q ‚ü∂ ‚ñ°q)) this;
  have : ùêÜùê´ùê≥ ‚ä¢! ‚ãÄ((Œì.remove (~q)).remove (‚ñ°(q ‚ü∂ ‚ñ°q))) ‚ü∂ (‚ñ°(q ‚ü∂ ‚ñ°q) ‚ü∂ q)  := and_imply_iff_imply_imply'!.mp this;
  have : ùêÜùê´ùê≥ ‚ä¢! ‚ñ°‚ãÄ((Œì.remove (~q)).remove (‚ñ°(q ‚ü∂ ‚ñ°q))) ‚ü∂ ‚ñ°(‚ñ°(q ‚ü∂ ‚ñ°q) ‚ü∂ q) := imply_box_distribute'! this;
  have : ùêÜùê´ùê≥ ‚ä¢! ‚ñ°‚ãÄ((Œì.remove (~q)).remove (‚ñ°(q ‚ü∂ ‚ñ°q))) ‚ü∂ q := imp_trans''! this axiomGrz!;
  have : ùêÜùê´ùê≥ ‚ä¢! ‚ñ°‚ñ°‚ãÄ((Œì.remove (~q)).remove (‚ñ°(q ‚ü∂ ‚ñ°q))) ‚ü∂ ‚ñ°q := imply_box_distribute'! this;
  have : ùêÜùê´ùê≥ ‚ä¢! ‚ñ°‚ãÄ((Œì.remove (~q)).remove (‚ñ°(q ‚ü∂ ‚ñ°q))) ‚ü∂ ‚ñ°q := imp_trans''! axiomFour! this;
  have : ùêÜùê´ùê≥ ‚ä¢! ‚ãÄ‚ñ°'((Œì.remove (~q)).remove (‚ñ°(q ‚ü∂ ‚ñ°q))) ‚ü∂ ‚ñ°q := imp_trans''! collect_box_conj! this;

  have : X.theory *‚ä¢[ùêÜùê´ùê≥]! (‚ñ°q) := by
    apply Context.provable_iff.mpr;
    use (‚ñ°'List.remove (‚ñ°(q ‚ü∂ ‚ñ°q)) (List.remove (~q) Œì));
    constructor;
    . intro r hr; simp at hr;
      obtain ‚ü®s, hs, rfl‚ü© := hr;
      have ‚ü®s_mem', hs‚ÇÅ‚ü© := List.mem_remove_iff.mp hs;
      have ‚ü®s_mem, hs‚ÇÇ‚ü© := List.mem_remove_iff.mp s_mem';
      clear hs s_mem';
      have := hŒì‚ÇÅ s s_mem;
      simp at this;
      rcases this with ((rfl | rfl) | ‚ü®s, hs, rfl‚ü©);
      . contradiction;
      . contradiction;
      . apply membership_iff.mpr;
        apply axiomFour'!;
        apply membership_iff.mp;
        assumption;
    . assumption;

  have : ‚ñ°q ‚àà X.theory := membership_iff.mpr this;
  contradiction;

open Formula MaximalConsistentTheory

lemma Grz_truthlemma
  {p : Formula Œ±} {X : (CanonicalModel ùêÜùê´ùê≥).World} {q : Formula Œ±} (hq : q ‚àà ùíÆ p) :
  Satisfies (GrzFilteredModel p) ‚ü¶X‚üß q ‚Üî q ‚àà X.theory := by
  induction q using Formula.rec' generalizing X with
  | hbox q ih =>
    by_cases bq_mem_X : ‚ñ°q ‚àà X.theory;
    . simp [bq_mem_X];
      intro QY RXY;
      obtain ‚ü®Y, hY‚ü© := Quotient.exists_rep QY; subst hY;
      have : ‚ñ°q ‚àà Y.theory := GrzFilteredFrame.def_rel.mp RXY |>.1 q (by simp; left; assumption) bq_mem_X;
      have : q ‚àà Y.theory := iff_mem_imp (Œ© := Y) |>.mp (membership_iff.mpr (axiomT!)) this;
      exact @ih Y (Subformulas.mem_box hq) |>.mpr this;
    . simp [bq_mem_X]
      wlog q_mem_X : q ‚àà X.theory;
      . have : ¬¨Satisfies (GrzFilteredModel p) ‚ü¶X‚üß q := @ih X (Subformulas.mem_box hq) |>.not.mpr q_mem_X;
        have : ¬¨Satisfies (GrzFilteredModel p) ‚ü¶X‚üß (‚ñ°q) := by
          simp [Satisfies];
          use ‚ü¶X‚üß;
          constructor;
          . apply GrzFilteredFrame.reflexive;
          . assumption;
        tauto;
      simp [Satisfies];
      obtain ‚ü®Y, hY‚ü© := lindenbaum (Œõ := ùêÜùê´ùê≥) (T := ({‚ñ°(q ‚ü∂ ‚ñ°q), ~q} ‚à™ (‚ñ°''‚ñ°''‚Åª¬πX.theory))) $ Grz_truthlemma.lemma bq_mem_X;
      simp [Set.insert_subset_iff] at hY;
      obtain ‚ü®‚ü®mem_q‚ÇÅ_Y, nmem_q_Y‚ü©, hY‚ÇÇ‚ü© := hY;
      use ‚ü¶Y‚üß;
      constructor;
      . apply GrzFilteredFrame.def_rel.mpr;
        constructor;
        . intro r hr;
          simp [GrzSubformulas] at hr;
          rcases hr with (_ | ‚ü®r, _, rfl‚ü©) <;> apply hY‚ÇÇ;
        . apply imp_iff_not_or (a := (‚àÄ q ‚àà ‚ñ°''‚Åª¬π‚Üë(ùíÆ·¥≥ p), ‚ñ°q ‚àà Y.theory ‚Üí ‚ñ°q ‚àà X.theory)) (b := X = Y) |>.mpr;
          left; push_neg;
          use (q ‚ü∂ ‚ñ°q);
          refine ‚ü®?_, ?_, ?_‚ü©;
          . simp; right; exact Subformulas.mem_box hq;
          . assumption;
          . by_contra hC;
            have : ùêÜùê´ùê≥ ‚ä¢! (q ‚ãè ‚ñ°(q ‚ü∂ ‚ñ°q)) ‚ü∂ ‚ñ°q := reducible_KT_Grz KT_lemma1;
            have : (q ‚ãè ‚ñ°(q ‚ü∂ ‚ñ°q) ‚ü∂ ‚ñ°q) ‚àà X.theory := membership_iff.mpr $ Context.of! this;
            have : ‚ñ°q ‚àà X.theory := iff_mem_imp.mp this ?_;
            contradiction;
            apply iff_mem_and.mpr;
            constructor;
            . assumption;
            . assumption;
      . apply @ih Y (Subformulas.mem_box hq) |>.not.mpr;
        assumption
  | _ =>
    simp_all [Satisfies, StandardFilterationValuation];
    try aesop;

private lemma Grz_completeAux {p : Formula Œ±} : ReflexiveTransitiveAntisymmetricFrameClass.{u}Íü≥# ‚äß p ‚Üí ùêÜùê´ùê≥ ‚ä¢! p := by
  contrapose;
  intro h;
  apply exists_finite_frame.mpr;
  use (GrzFilteredFrame p);
  constructor;
  . refine ‚ü®GrzFilteredFrame.reflexive, GrzFilteredFrame.transitive, GrzFilteredFrame.antisymm‚ü©;
  . simp [Formula.Kripke.ValidOnFrame, Formula.Kripke.ValidOnModel];
    obtain ‚ü®X, hX‚ü© := lindenbaum (Œõ := ùêÜùê´ùê≥) (T := {~p}) (Theory.unprovable_iff_singleton_neg_consistent.mp h);
    use (GrzFilteredModel p).Valuation, ‚ü¶X‚üß;
    apply Grz_truthlemma (by simp) |>.not.mpr;
    apply MaximalConsistentTheory.iff_mem_neg.mp;
    simpa using hX;

instance Grz_complete : Complete (ùêÜùê´ùê≥ : DeductionParameter Œ±) ReflexiveTransitiveAntisymmetricFrameClass.{u}Íü≥# := ‚ü®Grz_completeAux‚ü©

instance : FiniteFrameProperty (Œ± := Œ±) ùêÜùê´ùê≥ ReflexiveTransitiveAntisymmetricFrameClass where


end Kripke

end LO.Modal.Standard
