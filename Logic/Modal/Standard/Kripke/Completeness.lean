import Logic.Modal.Standard.Deduction
import Logic.Modal.Standard.Kripke.Semantics
import Logic.Propositional.Superintuitionistic.Kripke.Completeness

namespace LO.System

variable {F : Type*} [LogicalConnective F] [DecidableEq F]
variable {S : Type*} [System F S]
variable {ùì¢ : S} {p q r : F} {Œì Œî : List F} {T : Set F}
variable [Minimal ùì¢] [NegDefinition F]

open FiniteContext

lemma FiniteContext.of'! (h : ùì¢ ‚ä¢! p) : Œì ‚ä¢[ùì¢]! p := weakening! (by simp) $ provable_iff_provable.mp h
lemma FiniteContext.to‚Çõ! (b : Œì ‚ä¢[ùì¢]! p) : ùì¢ ‚ä¢! Œì.conj ‚ü∂ p := b

lemma implyLeft_conj_eq_conj' : ùì¢ ‚ä¢! Œì.conj ‚ü∂ p ‚Üî ùì¢ ‚ä¢! Œì.conj' ‚ü∂ p := implyLeftReplaceIff'! (by
  induction Œì using List.induction_with_singleton with
  | hnil => simp;
  | hsingle q =>
    simp;
    apply iff_intro! (by simp) (by
      apply provable_iff_provable.mpr;
      apply deduct_iff.mpr;
      exact conj‚ÇÉ'! (by_axm! (by simp)) (by simp)
    );
  | hcons q Œì hŒì ih =>
    simp [(List.conj'_cons_nonempty (a := q) hŒì)];
    apply iff_intro!
      (by
        apply provable_iff_provable.mpr;
        apply deduct_iff.mpr;
        have d : [q ‚ãè List.conj Œì] ‚ä¢[ùì¢]! q ‚ãè List.conj Œì := by_axm! (by simp);
        exact conj‚ÇÉ'! (conj‚ÇÅ'! d) ((of'! $ conj‚ÇÅ'! ih) ‚®Ä (conj‚ÇÇ'! d))
      )
      (by
        apply provable_iff_provable.mpr;
        apply deduct_iff.mpr;
        have d : [q ‚ãè List.conj' Œì] ‚ä¢[ùì¢]! q ‚ãè List.conj' Œì := by_axm! (by simp);
        exact conj‚ÇÉ'! (conj‚ÇÅ'! d) ((of'! $ conj‚ÇÇ'! ih) ‚®Ä (conj‚ÇÇ'! d))
      )
  )

@[simp]
lemma dn_iff! [NegDefinition F] [HasDNE ùì¢] : ùì¢ ‚ä¢! p ‚ü∑ ~~p := iff_intro! (by simp) (by simp)

lemma supplemental1 [NegDefinition F] [HasEFQ ùì¢] (h : ùì¢ ‚ä¢! ~p) : ùì¢ ‚ä¢! p ‚ü∂ q := by
  apply provable_iff_provable.mpr;
  apply deduct_iff.mpr;
  have dnp : [p] ‚ä¢[ùì¢]! p ‚ü∂ ‚ä• := by simpa [NegDefinition.neg] using of'! h;
  have dp : [p] ‚ä¢[ùì¢]! p := by_axm! (by simp);
  exact efq'! (dnp ‚®Ä dp);

namespace Context

lemma by_axm! {p} (h : p ‚àà T) : T *‚ä¢[ùì¢]! p := by
  apply provable_iff.mpr;
  existsi {p};
  constructor;
  . intro q hq; have := Finset.mem_singleton.mp hq; subst_vars; simpa;
  . exact FiniteContext.by_axm! (by tauto)

end Context

end LO.System


namespace LO.Modal.Standard

variable [DecidableEq Œ±]

@[simp]
def Theory.ŒõConsistent (Œõ : AxiomSet Œ±) (T : Theory Œ±) := ‚àÄ {Œì : List (Formula Œ±)}, (‚àÄ p ‚àà Œì, p ‚àà T) ‚Üí Œõ ‚ä¨! Œì.conj' ‚ü∂ ‚ä•
notation:max "(" Œõ ")-Consistent " T:90 => Theory.ŒõConsistent Œõ T

variable {Œõ : AxiomSet Œ±}

open System
open Theory

namespace Theory

variable {T : Theory Œ±} (consisT : (Œõ)-Consistent T)

lemma unprovable_either : ¬¨(T *‚ä¢[Œõ]! p ‚àß T *‚ä¢[Œõ]! ~p) := by
  by_contra hC;
  have ‚ü®hC‚ÇÅ, hC‚ÇÇ‚ü© := hC;
  have : T *‚ä¢[Œõ]! ‚ä• := hC‚ÇÇ ‚®Ä hC‚ÇÅ;
  obtain ‚ü®Œì, hŒì‚ÇÅ, hŒì‚ÇÇ‚ü© := Context.provable_iff.mp this;
  have : Œõ ‚ä¨! List.conj' Œì ‚ü∂ ‚ä• := consisT hŒì‚ÇÅ;
  have : Œõ ‚ä¢! List.conj' Œì ‚ü∂ ‚ä• := implyLeft_conj_eq_conj'.mp $ FiniteContext.to‚Çõ! hŒì‚ÇÇ;
  contradiction;


lemma provable_iff_insert_neg_not_Œõconsistent : T *‚ä¢[Œõ]! p ‚Üî ¬¨(Œõ)-Consistent (insert (~p) T) := by sorry;

lemma neg_provable_iff_insert_not_Œõconsistent : T *‚ä¢[Œõ]! ~p ‚Üî ¬¨(Œõ)-Consistent (insert (p) T) := by sorry;


lemma not_provable_falsum : Œõ ‚ä¨! ‚ä• := by
  by_contra hC;
  have : Œõ ‚ä¢! ‚ä§ ‚ü∂ ‚ä• := dhyp! hC;
  have : Œõ ‚ä¨! ‚ä§ ‚ü∂ ‚ä• := by simpa [Finset.conj] using consisT (Œì := []) (by simp);
  contradiction;

lemma not_mem_falsum_of_Œõconsistent : ‚ä• ‚àâ T := by
  by_contra hC;
  have : Œõ ‚ä¨! ‚ä• ‚ü∂ ‚ä• := consisT (Œì := [‚ä•]) (by simpa);
  have : Œõ ‚ä¢! ‚ä• ‚ü∂ ‚ä• := efq!;
  contradiction;

lemma exists_maximal_Œõconsistent_theory
  : ‚àÉ Z, (Œõ)-Consistent Z ‚àß T ‚äÜ Z ‚àß ‚àÄ U, (Œõ)-Consistent U ‚Üí Z ‚äÜ U ‚Üí U = Z
  := zorn_subset_nonempty { T : Theory Œ± | (Œõ)-Consistent T } (by
    intro c hc chain hnc;
    existsi (‚ãÉ‚ÇÄ c);
    simp only [ŒõConsistent, Set.mem_setOf_eq, Set.mem_sUnion];
    constructor;
    . intro Œì;
      by_contra hC;
      obtain ‚ü®hŒìs, hŒìd‚ü© := by simpa using hC;
      obtain ‚ü®U, hUc, hUs‚ü© :=
        Set.subset_mem_chain_of_finite c hnc chain
          (s := ‚ÜëŒì.toFinset) (by simp)
          (by intro p hp; simp_all);
      simp [List.coe_toFinset] at hUs;
      have : (Œõ)-Consistent U := hc hUc;
      have : ¬¨(Œõ)-Consistent U := by
        simp only [ŒõConsistent, not_forall, not_not, exists_prop];
        existsi Œì;
        constructor;
        . intro p hp; exact hUs hp;
        . assumption;
      contradiction;
    . intro s a;
      exact Set.subset_sUnion_of_mem a;
  ) T consisT

end Theory

structure MaximalConsistentByTheory (Œõ : AxiomSet Œ±) where
  theory : Theory Œ±
  consistent : (Œõ)-Consistent theory
  maximal : ‚àÄ {U}, theory ‚äÇ U ‚Üí ¬¨(Œõ)-Consistent U

alias MCT := MaximalConsistentByTheory

namespace MaximalConsistentByTheory

variable {Œ© Œ©‚ÇÅ Œ©‚ÇÇ : MCT Œõ}
variable {p : Formula Œ±}

lemma exists_maximal_Œõconsistented_theory (consisT : (Œõ)-Consistent T) : ‚àÉ (Œ© : MCT Œõ), (T ‚äÜ Œ©.theory) := by
  have ‚ü®Œ©, hŒ©‚ÇÅ, hŒ©‚ÇÇ, hŒ©‚ÇÉ‚ü© := exists_maximal_Œõconsistent_theory consisT;
  existsi ‚ü®
    Œ©,
    hŒ©‚ÇÅ,
    by
      rintro U ‚ü®hU‚ÇÅ, hU‚ÇÇ‚ü©;
      by_contra hC;
      have : U = Œ© := hŒ©‚ÇÉ U hC hU‚ÇÅ;
      subst_vars;
      simp at hU‚ÇÇ;
  ‚ü©;
  simp_all only [ŒõConsistent];

alias lindenbaum := exists_maximal_Œõconsistented_theory

lemma maximal' {p : Formula Œ±} (hp : p ‚àâ Œ©.theory) : ¬¨(Œõ)-Consistent (insert p Œ©.theory) := Œ©.maximal (Set.ssubset_insert hp)


lemma membership_iff : (p ‚àà Œ©.theory) ‚Üî (Œ©.theory *‚ä¢[Œõ]! p) := by
  constructor;
  . intro h;
    exact Context.by_axm! h;
  . intro hp;
    by_contra hC;

    obtain ‚ü®Œì, hŒì‚ÇÅ, hŒì‚ÇÇ‚ü© := hp;
    obtain ‚ü®Œî, hŒî‚ÇÅ, hŒî‚ÇÇ‚ü© := neg_provable_iff_insert_not_Œõconsistent.mpr $ Œ©.maximal (Set.ssubset_insert hC);

    replace hŒì‚ÇÇ : (Œì ++ Œî) ‚ä¢[Œõ]! p := FiniteContext.weakening! (by simp) ‚ü®hŒì‚ÇÇ‚ü©
    replace hŒî‚ÇÇ : (Œì ++ Œî) ‚ä¢[Œõ]! ~p := FiniteContext.weakening! (by simp) ‚ü®hŒî‚ÇÇ‚ü©

    have : Œõ ‚ä¢! List.conj' (Œì ++ Œî) ‚ü∂ ‚ä• := implyLeft_conj_eq_conj'.mp $ FiniteContext.provable_iff.mp (hŒî‚ÇÇ ‚®Ä hŒì‚ÇÇ);
    have : Œõ ‚ä¨! List.conj' (Œì ++ Œî) ‚ü∂ ‚ä• := Œ©.consistent (by simp; rintro q (hq‚ÇÅ | hq‚ÇÇ); exact hŒì‚ÇÅ _ hq‚ÇÅ; exact hŒî‚ÇÅ _ hq‚ÇÇ);
    contradiction;

@[simp]
lemma not_mem_falsum : ‚ä• ‚àâ Œ©.theory := not_mem_falsum_of_Œõconsistent Œ©.consistent

@[simp]
lemma unprovable_falsum : Œ©.theory *‚ä¨[Œõ]! ‚ä• := by apply membership_iff.not.mp; simp

lemma iff_mem_neg : (~p ‚àà Œ©.theory) ‚Üî (p ‚àâ Œ©.theory) := by
  constructor;
  . intro hnp;
    by_contra hp;
    replace hp := membership_iff.mp hp;
    replace hnp := membership_iff.mp hnp;
    have : Œ©.theory *‚ä¢[Œõ]! ‚ä• := hnp ‚®Ä hp;
    have : Œ©.theory *‚ä¨[Œõ]! ‚ä• := unprovable_falsum;
    contradiction;
  . intro hp;
    have := provable_iff_insert_neg_not_Œõconsistent.not.mp $ membership_iff.not.mp hp;
    have := (not_imp_not.mpr $ Œ©.maximal (U := insert (~p) Œ©.theory)) this;
    simp [Set.ssubset_def] at this;
    apply this;
    simp;

@[simp]
lemma iff_mem_imp : ((p ‚ü∂ q) ‚àà Œ©.theory) ‚Üî (p ‚àà Œ©.theory) ‚Üí (q ‚àà Œ©.theory) := by
  constructor;
  . intro hpq hp;
    replace dpq := membership_iff.mp hpq;
    replace dp  := membership_iff.mp hp;
    apply membership_iff.mpr;
    exact dpq ‚®Ä dp;
  . intro h;
    replace h : p ‚àâ Œ©.theory ‚à® q ‚àà Œ©.theory := or_iff_not_imp_left.mpr (by simpa using h);
    cases h with
    | inl h =>
      apply membership_iff.mpr;
      exact supplemental1 $ membership_iff.mp $ iff_mem_neg.mpr h;
    | inr h =>
      apply membership_iff.mpr;
      exact imply‚ÇÅ! ‚®Ä (membership_iff.mp h)

@[simp]
lemma iff_mem_and : ((p ‚ãè q) ‚àà Œ©.theory) ‚Üî (p ‚àà Œ©.theory) ‚àß (q ‚àà Œ©.theory) := by
  constructor;
  . intro hpq;
    replace hpq := membership_iff.mp hpq;
    constructor;
    . apply membership_iff.mpr; exact conj‚ÇÅ'! hpq;
    . apply membership_iff.mpr; exact conj‚ÇÇ'! hpq;
  . rintro ‚ü®hp, hq‚ü©;
    apply membership_iff.mpr;
    exact conj‚ÇÉ'! (membership_iff.mp hp) (membership_iff.mp hq);

@[simp]
lemma iff_mem_or : ((p ‚ãé q) ‚àà Œ©.theory) ‚Üî (p ‚àà Œ©.theory) ‚à® (q ‚àà Œ©.theory) := by
  constructor;
  . intro hpq;
    replace hpq := membership_iff.mp hpq;
    by_contra hC; simp [not_or] at hC;
    have ‚ü®hp, hq‚ü© := hC;
    replace hp := membership_iff.mp $ iff_mem_neg.mpr hp;
    replace hq := membership_iff.mp $ iff_mem_neg.mpr hq;
    have : Œ©.theory *‚ä¢[Œõ]! ‚ä• := disj‚ÇÉ'! hp hq hpq;
    have : Œ©.theory *‚ä¨[Œõ]! ‚ä• := unprovable_falsum;
    contradiction;
  . rintro (hp | hq);
    . apply membership_iff.mpr;
      exact disj‚ÇÅ'! (membership_iff.mp hp);
    . apply membership_iff.mpr;
      exact disj‚ÇÇ'! (membership_iff.mp hq);

lemma iff_mem_box : (‚ñ°p ‚àà Œ©.theory) ‚Üî (‚àÄ {Œ©' : MCT Œõ}, (‚ñ°‚Åª¬πŒ©.theory ‚äÜ Œ©'.theory) ‚Üí (p ‚àà Œ©'.theory)) := by
  constructor;
  . intro hp Œ©' hŒ©'
    apply hŒ©';
    simpa;
  . contrapose;
    intro hp;
    have : (Œõ)-Consistent (insert (~p) (‚ñ°‚Åª¬πŒ©.theory)) := by sorry;
    obtain ‚ü®Œ©', hŒ©'‚ü© := lindenbaum this;
    push_neg;
    existsi Œ©';
    constructor;
    . exact Set.Subset.trans (by simp_all) hŒ©';
    . apply iff_mem_neg.mp;
      apply hŒ©';
      simp only [Set.mem_insert_iff, true_or]

lemma iff_congr : (Œ©.theory *‚ä¢[Œõ]! (p ‚ü∑ q)) ‚Üí ((p ‚àà Œ©.theory) ‚Üî (q ‚àà Œ©.theory)) := by
  intro hpq;
  constructor;
  . intro hp; exact iff_mem_imp.mp (membership_iff.mpr $ conj‚ÇÅ'! hpq) hp;
  . intro hq; exact iff_mem_imp.mp (membership_iff.mpr $ conj‚ÇÇ'! hpq) hq;

lemma mem_dn_iff : (p ‚àà Œ©.theory) ‚Üî (~~p ‚àà Œ©.theory) := iff_congr $ (by simp)

end MaximalConsistentByTheory


open Formula
open MaximalConsistentByTheory

namespace Kripke

def CanonicalModel (Œõ : AxiomSet Œ±) : Model (MCT Œõ) Œ± where
  frame (Œ©‚ÇÅ Œ©‚ÇÇ) := ‚ñ°‚Åª¬πŒ©‚ÇÅ.theory ‚äÜ Œ©‚ÇÇ.theory
  valuation Œ© a := (atom a) ‚àà Œ©.theory

abbrev CanonicalFrame (Œõ : AxiomSet Œ±) : Frame (MCT Œõ) Œ± := CanonicalModel Œõ |>.frame

namespace CanonicalModel

@[simp]
lemma frame_def: (CanonicalModel Œõ).frame Œ©‚ÇÅ Œ©‚ÇÇ ‚Üî (‚àÄ {p : Formula Œ±}, ‚ñ°p ‚àà Œ©‚ÇÅ.theory ‚Üí p ‚àà Œ©‚ÇÇ.theory) := by rfl

@[simp]
lemma val_def {a : Œ±} : (CanonicalModel Œõ).valuation Œ© a ‚Üî (atom a) ‚àà Œ©.theory := by rfl

end CanonicalModel

lemma truthlemma {p : Formula Œ±} : ‚àÄ {Œ© : MCT Œõ}, (CanonicalModel Œõ, Œ©) ‚äß p ‚Üî (p ‚àà Œ©.theory) := by
  induction p using Formula.rec' with
  | hbox p ih =>
    intro Œ©;
    constructor;
    . intro h;
      apply iff_mem_box.mpr;
      intro Œ©' hŒ©';
      apply ih.mp;
      exact h Œ©' hŒ©';
    . intro h Œ©' hŒ©';
      apply ih.mpr;
      simp [Set.subset_def, CanonicalModel.frame_def] at hŒ©';
      exact hŒ©' h;
  | _ => simp_all

lemma deducible_of_validOnCanonicelModel : (CanonicalModel Œõ) ‚äß p ‚Üí (Œõ ‚ä¢! p) := by
  contrapose;
  intro h;
  have : (Œõ)-Consistent ({~p}) := by sorry;
  obtain ‚ü®Œ©, hŒ©‚ü© := lindenbaum this;
  simp [Kripke.ValidOnModel];
  existsi Œ©;
  exact truthlemma.not.mpr $ iff_mem_neg.mp (show ~p ‚àà Œ©.theory by simp_all);

class Canonical (Œõ : AxiomSet Œ±) where
  property : Frame (MCT Œõ) Œ± ‚Üí Prop
  definability : AxiomSetDefinability (MCT Œõ) Œõ property
  satisfy : property (CanonicalFrame Œõ)

lemma complete!_of_canonically [c : Canonical Œõ] : ùîΩ((Œõ : AxiomSet Œ±), MCT (Œõ : AxiomSet Œ±)) ‚äß p ‚Üí (Œõ ‚ä¢! p) := by
  contrapose;
  intro h‚ÇÅ h‚ÇÇ;
  simp [Kripke.ValidOnFrameClass, Kripke.ValidOnFrame] at h‚ÇÇ;
  have : Œõ ‚ä¢! p := deducible_of_validOnCanonicelModel $ h‚ÇÇ (CanonicalModel Œõ).frame
    (by apply iff_definability_memAxiomSetFrameClass c.definability |>.mp; exact c.satisfy)
    (CanonicalModel Œõ).valuation;
  contradiction;

instance [Canonical Œõ] : Complete (Œõ : AxiomSet Œ±) ùîΩ(Œõ, MCT Œõ) := ‚ü®complete!_of_canonically‚ü©

instance : Canonical (ùêä : AxiomSet Œ±) where
  definability := AxiomSet.K.definability
  satisfy := by simp;

instance : Complete (ùêä : AxiomSet Œ±) ùîΩ((ùêä : AxiomSet Œ±), MCT (ùêä : AxiomSet Œ±)) := inferInstance

end Kripke

end LO.Modal.Standard
