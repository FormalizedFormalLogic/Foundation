import Logic.Vorspiel.Collection
import Logic.Modal.Standard.System

namespace LO.Modal.Standard

inductive Formula (Œ± : Type u) : Type u where
  | atom   : Œ± ‚Üí Formula Œ±
  | natom  : Œ± ‚Üí Formula Œ±
  | verum  : Formula Œ±
  | falsum : Formula Œ±
  | and    : Formula Œ± ‚Üí Formula Œ± ‚Üí Formula Œ±
  | or     : Formula Œ± ‚Üí Formula Œ± ‚Üí Formula Œ±
  | box    : Formula Œ± ‚Üí Formula Œ±
  | dia    : Formula Œ± ‚Üí Formula Œ±
  deriving DecidableEq

namespace Formula

def neg : Formula Œ± ‚Üí Formula Œ±
  | verum   => falsum
  | falsum  => verum
  | atom a  => natom a
  | natom a => atom a
  | and p q => or (neg p) (neg q)
  | or p q  => and (neg p) (neg q)
  | box p   => dia (neg p)
  | dia p   => box (neg p)

lemma neg_neg (p : Formula Œ±) : neg (neg p) = p := by induction p <;> simp[*, neg]

variable {Œ± : Type u}

instance : BasicModalLogicalConnective (Formula Œ±) where
  tilde := neg
  arrow := Œª p q => or (neg p) q
  wedge := and
  vee := or
  top := verum
  bot := falsum
  box := box
  dia := dia

section ToString

variable [ToString Œ±]

def toStr : Formula Œ± ‚Üí String
  | ‚ä§       => "\\top"
  | ‚ä•       => "\\bot"
  | atom a  => "{" ++ toString a ++ "}"
  | natom a => "\\lnot {" ++ toString a ++ "}"
  | ‚ñ°p      => "\\Box " ++ toStr p
  | ‚óáp      => "\\Diamond " ++ toStr p
  | p ‚ãè q   => "\\left(" ++ toStr p ++ " \\land " ++ toStr q ++ "\\right)"
  | p ‚ãé q   => "\\left(" ++ toStr p ++ " \\lor "   ++ toStr q ++ "\\right)"

instance : Repr (Formula Œ±) := ‚ü®fun t _ => toStr t‚ü©

instance : ToString (Formula Œ±) := ‚ü®toStr‚ü©

instance : Coe Œ± (Formula Œ±) := ‚ü®atom‚ü©


end ToString

@[simp] lemma neg_top : ~(‚ä§ : Formula Œ±) = ‚ä• := rfl

@[simp] lemma neg_bot : ~(‚ä• : Formula Œ±) = ‚ä§ := rfl

@[simp] lemma neg_atom (a : Œ±) : ~(atom a) = natom a := rfl

@[simp] lemma neg_natom (a : Œ±) : ~(natom a) = atom a := rfl

@[simp] lemma neg_and (p q : Formula Œ±) : ~(p ‚ãè q) = ~p ‚ãé ~q := rfl

@[simp] lemma neg_or (p q : Formula Œ±) : ~(p ‚ãé q) = ~p ‚ãè ~q := rfl

@[simp] lemma neg_neg' (p : Formula Œ±) : ~~p = p := neg_neg p

@[simp] lemma neg_inj (p q : Formula Œ±) : ~p = ~q ‚Üî p = q := by
  constructor
  ¬∑ intro h; simpa using congr_arg (~¬∑) h
  ¬∑ exact congr_arg _

lemma or_eq (p q : Formula Œ±) : or p q = p ‚ãé q := rfl

lemma and_eq (p q : Formula Œ±) : and p q = p ‚ãè q := rfl

lemma neg_eq (p : Formula Œ±) : neg p = ~p := rfl

lemma box_eq (p : Formula Œ±) : box p = ‚ñ°p := rfl

lemma imp_eq (p q : Formula Œ±) : p ‚ü∂ q = ~p ‚ãé q := rfl

lemma iff_eq (p q : Formula Œ±) : p ‚ü∑ q = (p ‚ü∂ q) ‚ãè (q ‚ü∂ p) := rfl

@[simp] lemma and_inj (p‚ÇÅ q‚ÇÅ p‚ÇÇ q‚ÇÇ : Formula Œ±) : p‚ÇÅ ‚ãè p‚ÇÇ = q‚ÇÅ ‚ãè q‚ÇÇ ‚Üî p‚ÇÅ = q‚ÇÅ ‚àß p‚ÇÇ = q‚ÇÇ := by simp[Wedge.wedge]

@[simp] lemma or_inj (p‚ÇÅ q‚ÇÅ p‚ÇÇ q‚ÇÇ : Formula Œ±) : p‚ÇÅ ‚ãé p‚ÇÇ = q‚ÇÅ ‚ãé q‚ÇÇ ‚Üî p‚ÇÅ = q‚ÇÅ ‚àß p‚ÇÇ = q‚ÇÇ := by simp[Vee.vee]

-- @[simp] lemma imp_inj (p‚ÇÅ q‚ÇÅ p‚ÇÇ q‚ÇÇ : Formula Œ±) : p‚ÇÅ ‚ü∂ p‚ÇÇ = q‚ÇÅ ‚ü∂ q‚ÇÇ ‚Üî p‚ÇÅ = q‚ÇÅ ‚àß p‚ÇÇ = q‚ÇÇ := by simp[Arrow.arrow]

instance : DeMorgan (Formula Œ±) where
  verum := rfl
  falsum := rfl
  and := by simp
  or := by simp
  imply := by simp[imp_eq]
  neg := by simp

/-- Formula complexity -/
def complexity : Formula Œ± ‚Üí ‚Ñï
| atom _  => 0
| natom _ => 0
| ‚ä§       => 0
| ‚ä•       => 0
| p ‚ãè q   => max p.complexity q.complexity + 1
| p ‚ãé q   => max p.complexity q.complexity + 1
| ‚óáp   => p.complexity + 1
| ‚ñ°p   => p.complexity + 1

/-- Max numbers of `‚ñ°` -/
def degree : Formula Œ± ‚Üí Nat
  | atom _ => 0
  | natom _ => 0
  | ‚ä§ => 0
  | ‚ä• => 0
  | p ‚ãè q => max p.degree q.degree
  | p ‚ãé q => max p.degree q.degree
  | ‚ñ°p => p.degree + 1
  | ‚óáp => p.degree + 1

@[elab_as_elim]
def cases' {C : Formula Œ± ‚Üí Sort w}
    (hverum  : C ‚ä§)
    (hfalsum : C ‚ä•)
    (hatom   : ‚àÄ a : Œ±, C (atom a))
    (hnatom  : ‚àÄ a : Œ±, C (natom a))
    (hand    : ‚àÄ (p q : Formula Œ±), C (p ‚ãè q))
    (hor     : ‚àÄ (p q : Formula Œ±), C (p ‚ãé q))
    (hbox    : ‚àÄ (p : Formula Œ±), C (‚ñ°p))
    (hdia    : ‚àÄ (p : Formula Œ±), C (‚óáp))
    : (p : Formula Œ±) ‚Üí C p
  | ‚ä§       => hverum
  | ‚ä•       => hfalsum
  | atom a  => hatom a
  | natom a => hnatom a
  | ‚ñ°p      => hbox p
  | ‚óáp     => hdia p
  | p ‚ãè q   => hand p q
  | p ‚ãé q   => hor p q

@[elab_as_elim]
def rec' {C : Formula Œ± ‚Üí Sort w}
  (hverum  : C ‚ä§)
  (hfalsum : C ‚ä•)
  (hatom   : ‚àÄ a : Œ±, C (atom a))
  (hnatom  : ‚àÄ a : Œ±, C (natom a))
  (hand    : ‚àÄ (p q : Formula Œ±), C p ‚Üí C q ‚Üí C (p ‚ãè q))
  (hor     : ‚àÄ (p q : Formula Œ±), C p ‚Üí C q ‚Üí C (p ‚ãé q))
  (hbox    : ‚àÄ (p : Formula Œ±), C p ‚Üí C (‚ñ°p))
  (hdia    : ‚àÄ (p : Formula Œ±), C p ‚Üí C (‚óáp))
  : (p : Formula Œ±) ‚Üí C p
  | ‚ä§      => hverum
  | ‚ä•      => hfalsum
  | atom a => hatom a
  | natom a => hnatom a
  | p ‚ãè q  => hand p q (rec' hverum hfalsum hatom hnatom hand hor hbox hdia p) (rec' hverum hfalsum hatom hnatom hand hor hbox hdia q)
  | p ‚ãé q  => hor p q (rec' hverum hfalsum hatom hnatom hand hor hbox hdia p) (rec' hverum hfalsum hatom hnatom hand hor hbox hdia q)
  | ‚ñ°p     => hbox p (rec' hverum hfalsum hatom hnatom hand hor hbox hdia p)
  | ‚óáp     => hdia p (rec' hverum hfalsum hatom hnatom hand hor hbox hdia p)

-- @[simp] lemma complexity_neg (p : Formula Œ±) : complexity (~p) = p.complexity + 1 :=
--   by induction p using rec' <;> try { simp[neg_eq, neg, *]; rfl;}

section Decidable

variable [DecidableEq Œ±]

/-
def hasDecEq : (p q : Formula Œ±) ‚Üí Decidable (p = q)
  /-
  | ‚ä§, q => by
    cases q using cases' <;>
    { simp; try { exact isFalse not_false }; try { exact isTrue trivial } }
  -/
  | ‚ä•, q => by
    cases q <;> {
      simp;
      try { exact isFalse not_false };
      try { exact isTrue trivial };
    }
  | atom a, q => by
    cases q <;> try { simp; exact isFalse not_false }
    simp; exact decEq _ _;
  /-
  | p ‚ãè q, r => by
    cases r using cases' <;> try { simp; exact isFalse not_false }
    case hand p' q' =>
      exact match hasDecEq p p' with
      | isTrue hp =>
        match hasDecEq q q' with
        | isTrue hq  => isTrue (hp ‚ñ∏ hq ‚ñ∏ rfl)
        | isFalse hq => isFalse (by simp[hp, hq])
      | isFalse hp => isFalse (by simp[hp])
  | p ‚ãé q, r => by
    cases r using cases' <;> try { simp; exact isFalse not_false }
    case hor p' q' =>
      exact match hasDecEq p p' with
      | isTrue hp =>
        match hasDecEq q q' with
        | isTrue hq  => isTrue (hp ‚ñ∏ hq ‚ñ∏ rfl)
        | isFalse hq => isFalse (by simp[hp, hq])
      | isFalse hp => isFalse (by simp[hp])
  | ~p, q => by
    cases q using cases' <;> try { simp; exact isFalse not_false }
    case hneg p' =>
      exact match hasDecEq p p' with
      | isTrue hp  => isTrue (hp ‚ñ∏ rfl)
      | isFalse hp => isFalse (by simp[hp])
  -/
  | p ‚ü∂ q, r => by
    cases r <;> try { simp; exact isFalse not_false }
    case imp p' q' =>
      exact match hasDecEq p p' with
      | isTrue hp =>
        match hasDecEq q q' with
        | isTrue hq  => isTrue (hp ‚ñ∏ hq ‚ñ∏ rfl)
        | isFalse hq => isFalse (by simp[hp, hq])
      | isFalse hp => isFalse (by simp[hp])
  | ‚ñ°p, q => by
    cases q <;> try { simp; exact isFalse not_false }
    case box p' =>
      exact match hasDecEq p p' with
      | isTrue hp  => isTrue (hp ‚ñ∏ rfl)
      | isFalse hp => isFalse (by simp[hp, box_eq])
instance : DecidableEq (Formula Œ±) := hasDecEq
-/

end Decidable

def isBox : Formula Œ± ‚Üí Bool
  | box _ => true
  | _  => false


end Formula

abbrev Theory (Œ±) := Set (Formula Œ±)

instance : Collection (Formula Œ±) (Theory Œ±) := inferInstance

abbrev AxiomSet (Œ±) := Set (Formula Œ±)

section Subformula

variable [DecidableEq Œ±]

def Formula.Subformulas: Formula Œ± ‚Üí Finset (Formula Œ±)
  | atom a => {(atom a)}
  | natom a => {(natom a)}
  | ‚ä§      => {‚ä§}
  | ‚ä•      => {‚ä•}
  | p ‚ãè q  => insert (p ‚ãè q) (p.Subformulas ‚à™ q.Subformulas)
  | p ‚ãé q  => insert (p ‚ãé q) (p.Subformulas ‚à™ q.Subformulas)
  | ‚ñ°p     => insert (‚ñ°p) p.Subformulas
  | ‚óáp    => insert (‚óáp) p.Subformulas
  -- | ~p     => insert (~p) p.Subformulas

prefix:70 "ùíÆ " => Formula.Subformulas

namespace Formula.Subformulas

@[simp]
lemma mem_self (p : Formula Œ±) : p ‚àà ùíÆ p := by induction p <;> { simp [Subformulas]; try tauto; }

variable {p q r : Formula Œ±}

/-
lemma mem_neg (h : ~q ‚àà ùíÆ p := by assumption) : q ‚àà ùíÆ p := by
  induction p using Formula.rec' <;> {
    simp_all [Subformulas];
    try rcases h with (hq | hr); simp_all; simp_all;
  };
-/

lemma mem_and (h : (q ‚ãè r) ‚àà ùíÆ p := by assumption) : q ‚àà ùíÆ p ‚àß r ‚àà ùíÆ p := by
  induction p using Formula.rec' with
  | hand => simp_all [Subformulas]; rcases h with ‚ü®_‚ü© | ‚ü®‚ü®_‚ü© | ‚ü®_‚ü©‚ü© <;> simp_all
  | _ => simp_all [Subformulas]; try rcases h with (hq | hr); simp_all; simp_all;

lemma mem_and‚ÇÅ (h : (q ‚ãè r) ‚àà ùíÆ p := by assumption) : q ‚àà ùíÆ p := mem_and (r := r) |>.1

lemma mem_and‚ÇÇ (h : (q ‚ãè r) ‚àà ùíÆ p := by assumption) : r ‚àà ùíÆ p := mem_and (r := r) |>.2

lemma mem_or (h : (q ‚ãé r) ‚àà ùíÆ p := by assumption) : q ‚àà ùíÆ p ‚àß r ‚àà ùíÆ p := by
  induction p using Formula.rec' with
  | hor => simp_all [Subformulas]; rcases h with ‚ü®_‚ü© | ‚ü®‚ü®_‚ü© | ‚ü®_‚ü©‚ü© <;> simp_all
  | _ => simp_all [Subformulas]; try rcases h with (hq | hr); simp_all; simp_all;

lemma mem_or‚ÇÅ (h : (q ‚ãé r) ‚àà ùíÆ p := by assumption) : q ‚àà ùíÆ p := mem_or (r := r) |>.1

lemma mem_or‚ÇÇ (h : (q ‚ãé r) ‚àà ùíÆ p := by assumption) : r ‚àà ùíÆ p := mem_or (r := r) |>.2

/-
lemma mem_imp (h : (q ‚ü∂ r) ‚àà ùíÆ p := by assumption) : q ‚àà ùíÆ p ‚àß r ‚àà ùíÆ p := by
  induction p with
  | imp => simp_all [Subformulas]; rcases h with ‚ü®_‚ü© | ‚ü®‚ü®_‚ü© | ‚ü®_‚ü©‚ü© <;> simp_all
  | _ => simp_all [Subformulas]; try rcases h with (hq | hr); simp_all; simp_all;

lemma mem_imp‚ÇÅ (h : (q ‚ü∂ r) ‚àà ùíÆ p := by assumption) : q ‚àà ùíÆ p := mem_imp (r := r) |>.1

lemma mem_imp‚ÇÇ (h : (q ‚ü∂ r) ‚àà ùíÆ p := by assumption) : r ‚àà ùíÆ p := mem_imp (r := r) |>.2
-/

lemma mem_box (h : ‚ñ°q ‚àà ùíÆ p := by assumption) : q ‚àà ùíÆ p := by
  induction p using Formula.rec' <;> {
    simp_all [Subformulas];
    try rcases h with (hq | hr); simp_all; simp_all;
  };

lemma mem_dia (h : ‚óáq ‚àà ùíÆ p := by assumption) : q ‚àà ùíÆ p := by
  induction p using Formula.rec' <;> {
    simp_all [Subformulas];
    try rcases h with (hq | hr); simp_all; simp_all;
  };

attribute [aesop safe 5 forward]
  -- mem_neg
  mem_and‚ÇÅ
  mem_and‚ÇÇ
  mem_or‚ÇÅ
  mem_or‚ÇÇ
  -- mem_imp‚ÇÅ
  -- mem_imp‚ÇÇ
  mem_box
  mem_dia

/-
@[simp]
lemma complexity_lower (h : q ‚àà ùíÆ p) : q.complexity ‚â§ p.complexity  := by
  induction p using Formula.rec' with
  | hand p‚ÇÅ p‚ÇÇ ihp‚ÇÅ ihp‚ÇÇ =>
    simp_all [Subformulas];
    rcases h with _ | h‚ÇÅ | h‚ÇÇ;
    . subst_vars; simp [Formula.complexity];
    . have := ihp‚ÇÅ h‚ÇÅ; simp [Formula.complexity]; omega;
    . have := ihp‚ÇÇ h‚ÇÇ; simp [Formula.complexity]; omega;
  | hor p‚ÇÅ p‚ÇÇ ihp‚ÇÅ ihp‚ÇÇ =>
    simp_all [Subformulas];
    rcases h with _ | h‚ÇÅ | h‚ÇÇ;
    . subst_vars; simp [Formula.complexity];
    . have := ihp‚ÇÅ h‚ÇÅ; simp [Formula.complexity]; omega;
    . have := ihp‚ÇÇ h‚ÇÇ; simp [Formula.complexity]; omega;
  | himp p‚ÇÅ p‚ÇÇ ihp‚ÇÅ ihp‚ÇÇ =>
    simp_all [Subformulas];
    rcases h with _ | h‚ÇÅ | h‚ÇÇ;
    . subst_vars; simp [Formula.complexity];
    . have := ihp‚ÇÅ h‚ÇÅ; simp [Formula.complexity]; omega;
    . have := ihp‚ÇÇ h‚ÇÇ; simp [Formula.complexity]; omega;
  | hbox p ihp =>
    simp_all [Subformulas];
    rcases h with _ | h‚ÇÅ;
    . subst_vars; simp [Formula.complexity];
    . have := ihp h‚ÇÅ; simp [Formula.complexity]; omega;
  | hneg p ihp =>
    simp_all [Subformulas];
    rcases h with _ | h‚ÇÅ;
    . subst_vars; simp [Formula.complexity];
    . have := ihp h‚ÇÅ; simp [Formula.complexity]; omega;
  | _ => simp_all [Subformulas, Formula.complexity];

@[simp]
lemma degree_lower (h : q ‚àà ùíÆ p) : q.degree ‚â§ p.degree := by
  induction p using Formula.rec' with
  | hand p‚ÇÅ p‚ÇÇ ihp‚ÇÅ ihp‚ÇÇ =>
    simp_all [Subformulas];
    rcases h with _ | h‚ÇÅ | h‚ÇÇ;
    . subst_vars; simp [Formula.degree];
    . have := ihp‚ÇÅ h‚ÇÅ; simp [Formula.degree]; omega;
    . have := ihp‚ÇÇ h‚ÇÇ; simp [Formula.degree]; omega;
  | hor p‚ÇÅ p‚ÇÇ ihp‚ÇÅ ihp‚ÇÇ =>
    simp_all [Subformulas];
    rcases h with _ | h‚ÇÅ | h‚ÇÇ;
    . subst_vars; simp [Formula.degree];
    . have := ihp‚ÇÅ h‚ÇÅ; simp [Formula.degree]; omega;
    . have := ihp‚ÇÇ h‚ÇÇ; simp [Formula.degree]; omega;
  | himp p‚ÇÅ p‚ÇÇ ihp‚ÇÅ ihp‚ÇÇ =>
    simp_all [Subformulas];
    rcases h with _ | h‚ÇÅ | h‚ÇÇ;
    . subst_vars; simp [Formula.degree];
    . have := ihp‚ÇÅ h‚ÇÅ; simp [Formula.degree]; omega;
    . have := ihp‚ÇÇ h‚ÇÇ; simp [Formula.degree]; omega;
  | hbox p ihp =>
    simp_all [Subformulas];
    rcases h with _ | h‚ÇÅ;
    . subst_vars; simp [Formula.degree];
    . have := ihp h‚ÇÅ; simp [Formula.degree]; omega;
  | hneg p ihp =>
    simp_all [Subformulas];
    rcases h with _ | h‚ÇÅ;
    . subst_vars; simp [Formula.degree];
    . have := ihp h‚ÇÅ; simp [Formula.degree]; omega;
  | _ => simp_all [Subformulas, Formula.degree];
-/

lemma sub_of_top (h : p ‚àà ùíÆ ‚ä§) : p = ‚ä§ := by simp_all [Subformulas];
lemma sub_of_bot (h : p ‚àà ùíÆ ‚ä•) : p = ‚ä• := by simp_all [Subformulas];
lemma sub_of_atom {a : Œ±} (h : p ‚àà ùíÆ (atom a)) : p = atom a := by simp_all [Subformulas];
lemma sub_of_natom {a : Œ±} (h : p ‚àà ùíÆ (natom a)) : p = natom a := by simp_all [Subformulas];

-- attribute [aesop safe forward]
--   sub_of_top
--   sub_of_bot
--   sub_of_atom

end Formula.Subformulas

class Theory.SubformulaClosed (T : Theory Œ±) where
  and_closed   : ‚àÄ {p q}, p ‚ãè q ‚àà T ‚Üí p ‚àà T ‚àß q ‚àà T
  or_closed    : ‚àÄ {p q}, p ‚ãé q ‚àà T ‚Üí p ‚àà T ‚àß q ‚àà T
  box_closed   : ‚àÄ {p}, ‚ñ°p ‚àà T ‚Üí p ‚àà T
  dia_closed   : ‚àÄ {p}, ‚óáp ‚àà T ‚Üí p ‚àà T

namespace Theory.SubformulaClosed

instance {p : Formula Œ±} : Theory.SubformulaClosed (ùíÆ p).toSet where
  and_closed   := by aesop;
  or_closed    := by aesop;
  box_closed   := by aesop;
  dia_closed   := by aesop;

variable {p : Formula Œ±} {T : Theory Œ±} [T_closed : T.SubformulaClosed]

-- lemma sub_mem_neg (h : ~p ‚àà T) : p ‚àà T := T_closed.tilde_closed h
lemma sub_mem_and (h : p ‚ãè q ‚àà T) : p ‚àà T ‚àß q ‚àà T := T_closed.and_closed h
lemma sub_mem_or  (h : p ‚ãé q ‚àà T) : p ‚àà T ‚àß q ‚àà T := T_closed.or_closed h
-- lemma sub_mem_imp (h : p ‚ü∂ q ‚àà T) : p ‚àà T ‚àß q ‚àà T := T_closed.arrow_closed h
lemma sub_mem_box (h : ‚ñ°p ‚àà T) : p ‚àà T := T_closed.box_closed h
lemma sub_mem_dia (h : ‚óáp ‚àà T) : p ‚àà T := T_closed.dia_closed h

attribute [aesop safe 5 forward]
  -- sub_mem_neg
  sub_mem_and
  sub_mem_or
  -- sub_mem_imp
  sub_mem_box
  sub_mem_dia

end Theory.SubformulaClosed

end Subformula


/-
section Atoms

variable [DecidableEq Œ±]

namespace Formula

def atoms : Formula Œ± ‚Üí Finset (Œ±)
  | .atom a => {a}
  | ‚ä§      => ‚àÖ
  | ‚ä•      => ‚àÖ
  | ~p     => p.atoms
  | ‚ñ°p  => p.atoms
  | p ‚ü∂ q => p.atoms ‚à™ q.atoms
  | p ‚ãè q  => p.atoms ‚à™ q.atoms
  | p ‚ãé q  => p.atoms ‚à™ q.atoms
prefix:70 "ùíú " => Formula.atoms

@[simp]
lemma mem_atoms_iff_mem_subformulae {a : Œ±} {p : Formula Œ±} : a ‚àà ùíú p ‚Üî (atom a) ‚àà ùíÆ p := by
  induction p using Formula.rec' <;> simp_all [Subformulas, atoms];

end Formula

end Atoms


section Complement

variable [DecidableEq Œ±]

namespace Formula

def negated : Formula Œ± ‚Üí Bool
  | ~_ => true
  | _  => false

lemma negated_iff {p : Formula Œ±} : p.negated ‚Üî ‚àÉ q, p = ~q := by
  induction p using Formula.rec' <;> simp [negated]

lemma not_negated_iff {p : Formula Œ±} : ¬¨p.negated ‚Üî ‚àÄ q, p ‚â† ~q := by
  induction p using Formula.rec' <;> simp [negated]

def complement (p : Formula Œ±) : Formula Œ± := if p.negated then p else ~p
postfix:80 "‚Åª" => complement

lemma eq_complement_negated {p : Formula Œ±} (hp : p.negated) : p‚Åª = p := by
  induction p using Formula.rec' <;> simp_all [negated, complement]

lemma eq_complement_not_negated {p : Formula Œ±} (hp : ¬¨p.negated) : p‚Åª = ~p := by
  induction p using Formula.rec' <;> simp_all [negated, complement]


abbrev complement_subformula (p : Formula Œ±) : Finset (Formula Œ±) := (ùíÆ p) ‚à™ (Finset.image (¬∑‚Åª) $ ùíÆ p)
prefix:70 "ùíÆ‚Åª " => Formula.ComplementSubformula

end Formula

end Complement
-/

end LO.Modal.Standard
