import Logic.Modal.Normal.Formula
import Logic.Modal.Normal.Deduction
import Logic.Propositional.Superintuitionistic.Classical.Deduction

/-!
  # Maximality of `ùêìùê´ùê¢ùêØ` and `ùêïùêûùê´`

  `ùêìùê´ùê¢ùêØ` and `ùêïùêûùê´` are maximal in normal modal logic.
-/

namespace LO.Propositional.Superintuitionistic

def toModalFormula : Formula Œ± ‚Üí Modal.Normal.Formula Œ±
  | .atom a => Modal.Normal.Formula.atom a
  | ‚ä• => ‚ä•
  | ‚ä§ => ‚ä§
  | p ‚ü∂ q => (toModalFormula p) ‚ü∂ (toModalFormula q)
  | p ‚ãè q => (toModalFormula p) ‚ãè (toModalFormula q)
  | p ‚ãé q => (toModalFormula p) ‚ãé (toModalFormula q)
postfix:75 "·¥π" => toModalFormula

namespace toModalFormula

variable {p q : Formula Œ±}

@[simp] lemma atom_def (a : Œ±) : (.atom a)·¥π = Modal.Normal.Formula.atom a := by simp [toModalFormula]
@[simp] lemma bot_def : (‚ä• : Formula Œ±)·¥π = ‚ä• := by simp [toModalFormula]
@[simp] lemma top_def : (‚ä§ : Formula Œ±)·¥π = ‚ä§ := by simp [toModalFormula]
@[simp] lemma imp_def : (p ‚ü∂ q)·¥π = (p·¥π ‚ü∂ q·¥π) := by simp [toModalFormula]
@[simp] lemma conj_def : (p ‚ãè q)·¥π = (p·¥π ‚ãè q·¥π) := by simp [toModalFormula]
@[simp] lemma disj_def : (p ‚ãé q)·¥π = (p·¥π ‚ãé q·¥π) := by simp [toModalFormula]

end toModalFormula

end LO.Propositional.Superintuitionistic


namespace LO.Modal.Normal

open LO.Propositional

variable {Œ±} [DecidableEq Œ±]

namespace Formula

def toPropFormula (p : Formula Œ±) (_ : p.degree = 0) : Superintuitionistic.Formula Œ± :=
  match p with
  | atom a => Superintuitionistic.Formula.atom a
  | ‚ä• => ‚ä•
  | p ‚ãè q => (p.toPropFormula (by simp_all [degree])) ‚ãè (q.toPropFormula (by simp_all [degree]))
  | p ‚ãé q => (p.toPropFormula (by simp_all [degree])) ‚ãé (q.toPropFormula (by simp_all [degree]))
  | p ‚ü∂ q => (p.toPropFormula (by simp_all [degree])) ‚ü∂ (q.toPropFormula (by simp_all [degree]))

@[simp] lemma atom_degree {a : Œ±} : (atom a).degree = 0 := by simp [degree]
@[simp] lemma bot_degree : (‚ä• : Formula Œ±).degree = 0 := by simp [degree]
@[simp] lemma top_degree : (‚ä§ : Formula Œ±).degree = 0 := by simp [degree]

namespace toPropFormula

@[simp] lemma atom_def (a : Œ±) : (atom a).toPropFormula atom_degree = Superintuitionistic.Formula.atom a := by simp [toPropFormula]
@[simp] lemma bot_def : (‚ä• : Formula Œ±).toPropFormula bot_degree = ‚ä• := by simp [toPropFormula];

end toPropFormula

def TrivTranslation : Formula Œ± ‚Üí Formula Œ±
  | atom a => atom a
  | box p => p.TrivTranslation
  | ‚ä• => ‚ä•
  | p ‚ü∂ q => (p.TrivTranslation) ‚ü∂ (q.TrivTranslation)
  | p ‚ãè q => (p.TrivTranslation) ‚ãè (q.TrivTranslation)
  | p ‚ãé q => (p.TrivTranslation) ‚ãé (q.TrivTranslation)
postfix:75 "·µÄ" => TrivTranslation

namespace TrivTranslation

@[simp]
lemma degree_zero : p·µÄ.degree = 0 := by induction p <;> simp [TrivTranslation, degree, *];

@[simp] lemma atom_def (a : Œ±) : (.atom a)·µÄ = atom a := by simp [TrivTranslation];
@[simp] lemma box_def : (‚ñ°p)·µÄ = p·µÄ := by simp [TrivTranslation];
@[simp] lemma bot_def : (‚ä• : Formula Œ±)·µÄ = ‚ä• := by simp [TrivTranslation];
@[simp] lemma imp_def : (p ‚ü∂ q)·µÄ = (p·µÄ ‚ü∂ q·µÄ) := by simp [TrivTranslation];
@[simp] lemma conj_def : (p ‚ãè q)·µÄ = (p·µÄ ‚ãè q·µÄ) := by simp [TrivTranslation];
@[simp] lemma disj_def : (p ‚ãé q)·µÄ = (p·µÄ ‚ãé q·µÄ) := by simp [TrivTranslation];

def toPropFormula (p : Formula Œ±) : Superintuitionistic.Formula Œ± := p·µÄ.toPropFormula (by simp)
postfix:75 "·µÄ·¥æ" => TrivTranslation.toPropFormula

namespace toPropFormula

variable {p q : Formula Œ±}

@[simp] lemma atom_def : (.atom a)·µÄ·¥æ = Superintuitionistic.Formula.atom a := by simp [toPropFormula, Formula.toPropFormula]
@[simp] lemma bot_def : (‚ä• : Formula Œ±)·µÄ·¥æ = ‚ä• := by simp [toPropFormula, Formula.toPropFormula]
@[simp] lemma conj_def : (p ‚ãè q)·µÄ·¥æ = (p·µÄ·¥æ ‚ãè q·µÄ·¥æ) := by simp [toPropFormula, Formula.toPropFormula]
@[simp] lemma disj_def : (p ‚ãé q)·µÄ·¥æ = (p·µÄ·¥æ ‚ãé q·µÄ·¥æ) := by simp [toPropFormula, Formula.toPropFormula]
@[simp] lemma imp_def : (p ‚ü∂ q)·µÄ·¥æ = (p·µÄ·¥æ ‚ü∂ q·µÄ·¥æ) := by simp [toPropFormula, Formula.toPropFormula]
@[simp] lemma box_def : (‚ñ°p)·µÄ·¥æ = p·µÄ·¥æ := by simp [toPropFormula, Formula.toPropFormula]
@[simp] lemma neg_def : (~p)·µÄ·¥æ = ~(p·µÄ·¥æ) := by simp [toPropFormula, Formula.toPropFormula, NegDefinition.neg]

@[simp] lemma back : p·µÄ·¥æ·¥π = p·µÄ := by induction p using rec' <;> simp [*];

end toPropFormula

end TrivTranslation

@[simp]
def VerTranslation : Formula Œ± ‚Üí Formula Œ±
  | atom a => atom a
  | box _ => ‚ä§
  | ‚ä• => ‚ä•
  | p ‚ü∂ q => (p.VerTranslation) ‚ü∂ (q.VerTranslation)
  | p ‚ãè q => (p.VerTranslation) ‚ãè (q.VerTranslation)
  | p ‚ãé q => (p.VerTranslation) ‚ãé (q.VerTranslation)
postfix:75 "‚±Ω" => VerTranslation

namespace VerTranslation

@[simp] lemma degree_zero : p‚±Ω.degree = 0 := by induction p <;> simp [VerTranslation, degree, *];

@[simp] lemma atom_def (a : Œ±) : (.atom a)‚±Ω = atom a := by simp [TrivTranslation];
@[simp] lemma box_def : (‚ñ°p)‚±Ω = ‚ä§ := by simp [TrivTranslation];
@[simp] lemma bot_def : (‚ä• : Formula Œ±)‚±Ω = ‚ä• := by simp [TrivTranslation];
@[simp] lemma top_def : (‚ä§ : Formula Œ±)‚±Ω = (~‚ä•) := by simp [TrivTranslation, NegDefinition.neg];
@[simp] lemma imp_def : (p ‚ü∂ q)‚±Ω = (p‚±Ω ‚ü∂ q‚±Ω) := by simp [TrivTranslation];
@[simp] lemma conj_def : (p ‚ãè q)‚±Ω = (p‚±Ω ‚ãè q‚±Ω) := by simp [TrivTranslation];
@[simp] lemma disj_def : (p ‚ãé q)‚±Ω = (p‚±Ω ‚ãé q‚±Ω) := by simp [TrivTranslation];

@[simp] def toPropFormula (p : Formula Œ±) : Superintuitionistic.Formula Œ± := p‚±Ω.toPropFormula (by simp)
postfix:75 "‚±Ω·¥æ" => VerTranslation.toPropFormula

namespace toPropFormula

variable {p q : Formula Œ±}

@[simp] lemma atom_def : (.atom a)‚±Ω·¥æ = Superintuitionistic.Formula.atom a := by simp [toPropFormula, Formula.toPropFormula]
@[simp] lemma bot_def : (‚ä• : Formula Œ±)‚±Ω·¥æ = ‚ä• := by simp [toPropFormula, Formula.toPropFormula]
@[simp] lemma top_def : (‚ä§ : Formula Œ±)‚±Ω·¥æ = (~‚ä•) := by simp [toPropFormula, Formula.toPropFormula, NegDefinition.neg]
@[simp] lemma conj_def : (p ‚ãè q)‚±Ω·¥æ = (p‚±Ω·¥æ ‚ãè q‚±Ω·¥æ) := by simp [toPropFormula, Formula.toPropFormula]
@[simp] lemma disj_def : (p ‚ãé q)‚±Ω·¥æ = (p‚±Ω·¥æ ‚ãé q‚±Ω·¥æ) := by simp [toPropFormula, Formula.toPropFormula]
@[simp] lemma imp_def : (p ‚ü∂ q)‚±Ω·¥æ = (p‚±Ω·¥æ ‚ü∂ q‚±Ω·¥æ) := by simp [toPropFormula, Formula.toPropFormula]
@[simp] lemma box_def : (‚ñ°p)‚±Ω·¥æ = ‚ä§‚±Ω·¥æ := by simp [toPropFormula, Formula.toPropFormula]
@[simp] lemma neg_def : (~p)‚±Ω·¥æ = ~(p‚±Ω·¥æ) := by simp [toPropFormula, Formula.toPropFormula, NegDefinition.neg]

end toPropFormula
end VerTranslation

end Formula

open Hilbert

variable {Œõ : AxiomSet Œ±} {Œì} {p : Formula Œ±}

def Deduction.ofTriv : Hilbert.Triv (¬∑ ‚ä¢·¥π[(ùêìùê´ùê¢ùêØ : AxiomSet Œ±)] ¬∑) where
  K _ _ _ := Deduction.maxm $ (by simp);
  T _ _ := Deduction.maxm $ (by simp);
  Tc _ _ := Deduction.maxm $ (by simp);

def Deduction.ofVer : Hilbert.Ver (¬∑ ‚ä¢·¥π[(ùêïùêûùê´ : AxiomSet Œ±)] ¬∑) where
  K _ _ _ := Deduction.maxm $ (by simp);
  Verum _ _ := Deduction.maxm $ (by simp);

lemma deducible_iff_trivTranslation : Œì ‚ä¢·¥π[ùêìùê´ùê¢ùêØ]! p ‚ü∑ p·µÄ := by
  have := @Deduction.ofTriv;
  induction p using Formula.rec' with
  | hbox p ih => exact iff_trans'! (iff_symm'! $ boxtriv!) ih;
  | hatom _ => apply iff_id!
  | hfalsum => apply iff_id!
  | himp _ _ ih‚ÇÅ ih‚ÇÇ => exact imp_iff'! ih‚ÇÅ ih‚ÇÇ;
  | hand _ _ ih‚ÇÅ ih‚ÇÇ => exact conj_iff'! ih‚ÇÅ ih‚ÇÇ;
  | hor _ _ ih‚ÇÅ ih‚ÇÇ => exact disj_iff'! ih‚ÇÅ ih‚ÇÇ

lemma deducible_iff_verTranslation : Œì ‚ä¢·¥π[ùêïùêûùê´]! p ‚ü∑ p‚±Ω := by
  have := @Deduction.ofVer;
  induction p using Formula.rec' with
  | hbox =>
    apply iff_intro'!;
    . exact imply‚ÇÅ'! verum!
    . exact imply‚ÇÅ'! boxarbitary!;
  | hatom _ => apply iff_id!
  | hfalsum => apply iff_id!
  | himp _ _ ih‚ÇÅ ih‚ÇÇ => exact imp_iff'! ih‚ÇÅ ih‚ÇÇ;
  | hand _ _ ih‚ÇÅ ih‚ÇÇ => exact conj_iff'! ih‚ÇÅ ih‚ÇÇ;
  | hor _ _ ih‚ÇÅ ih‚ÇÇ => exact disj_iff'! ih‚ÇÅ ih‚ÇÇ

private lemma of_classical_aux (hŒì : Œì = ‚àÖ) {p : Superintuitionistic.Formula Œ±} : (Œì ‚ä¢·∂ú! p) ‚Üí (‚àÖ ‚ä¢·¥π[Œõ]! p·¥π) := by
  intro h;
  induction h.some with
  | axm h => simp_all;
  | eaxm ih =>
    simp_all;
    obtain ‚ü®p, e‚ü© := ih;
    subst e;
    apply dne!;
  | modusPonens h‚ÇÅ h‚ÇÇ ih‚ÇÅ ih‚ÇÇ =>
    subst hŒì;
    simp_all;
    replace h‚ÇÅ := ih‚ÇÅ h‚ÇÅ;
    replace h‚ÇÇ := ih‚ÇÇ h‚ÇÇ;
    simpa using modus_ponens'! h‚ÇÅ h‚ÇÇ;
  | _ =>
    simp;
    try first
    | apply verum!;
    | apply conj‚ÇÅ!;
    | apply conj‚ÇÇ!;
    | apply conj‚ÇÉ!;
    | apply disj‚ÇÅ!;
    | apply disj‚ÇÇ!;
    | apply disj‚ÇÉ!;
    | apply imply‚ÇÅ!;
    | apply imply‚ÇÇ!;

lemma of_classical {p : Superintuitionistic.Formula Œ±} : (‚àÖ ‚ä¢·∂ú! p) ‚Üí (‚àÖ ‚ä¢·¥π[Œõ]! p·¥π) := of_classical_aux rfl

private lemma iff_Triv_classical_aux (hŒì : Œì = ‚àÖ) : (Œì ‚ä¢·¥π[ùêìùê´ùê¢ùêØ]! p) ‚Üî (‚àÖ ‚ä¢·∂ú! p·µÄ·¥æ) := by
  constructor;
  . intro h;
    induction h.some with
    | axm h => simp_all;
    | maxm a =>
      rcases a with (hK | hT) | hTr;
      . obtain ‚ü®p, q, h‚ü© := hK; subst h;
        simp [axiomK, Formula.TrivTranslation.toPropFormula, Formula.toPropFormula];
        apply imp_id!;
      . obtain ‚ü®p, h‚ü© := hT; subst h;
        simp [axiomT, Formula.TrivTranslation.toPropFormula, Formula.toPropFormula];
        apply imp_id!;
      . obtain ‚ü®p, h‚ü© := hTr; subst h;
        simp [axiomK, Formula.TrivTranslation.toPropFormula, Formula.toPropFormula];
        apply imp_id!;
    | modus_ponens h‚ÇÅ h‚ÇÇ ih‚ÇÅ ih‚ÇÇ =>
      simp_all;
      have ‚ü®hŒì‚ÇÅ, hŒì‚ÇÇ‚ü© := hŒì;
      subst hŒì‚ÇÅ hŒì‚ÇÇ;
      simpa using modus_ponens'! (ih‚ÇÅ h‚ÇÅ) (ih‚ÇÇ h‚ÇÇ);
    | necessitation h ih =>
      simp_all;
      apply ih;
      assumption;
    | _ =>
      simp_all;
      try first
      | apply imp_id!;
      | apply imply‚ÇÅ!;
      | apply imply‚ÇÇ!;
      | apply conj‚ÇÅ!;
      | apply conj‚ÇÇ!;
      | apply conj‚ÇÉ!;
      | apply disj‚ÇÅ!;
      | apply disj‚ÇÇ!;
      | apply disj‚ÇÉ!;
      | apply dne!;
  . intro h;
    subst hŒì;
    have d‚ÇÅ : ‚àÖ ‚ä¢·¥π[ùêìùê´ùê¢ùêØ]! p·µÄ ‚ü∂ p := iff_mpr'! deducible_iff_trivTranslation;
    have d‚ÇÇ : ‚àÖ ‚ä¢·¥π[ùêìùê´ùê¢ùêØ]! p·µÄ := by simpa using of_classical h;
    simpa using modus_ponens'! d‚ÇÅ d‚ÇÇ;

theorem iff_Triv_classical : (‚àÖ ‚ä¢·¥π[ùêìùê´ùê¢ùêØ]! p) ‚Üî (‚àÖ ‚ä¢·∂ú! p·µÄ·¥æ) := iff_Triv_classical_aux rfl

lemma iff_Ver_classical_aux (hŒì : Œì = ‚àÖ) : (Œì ‚ä¢·¥π[ùêïùêûùê´]! p) ‚Üî (‚àÖ ‚ä¢·∂ú! p‚±Ω·¥æ) := by
  constructor;
  . intro h;
    induction h.some with
    | axm h => simp_all;
    | maxm a =>
      rcases a with (hK | hVer)
      . obtain ‚ü®p, q, h‚ü© := hK; subst h;
        simp [axiomK];
        apply imply‚ÇÅ!;
      . obtain ‚ü®p, h‚ü© := hVer; subst h;
        simp [axiomVerum];
        exact imp_id!;
    | modus_ponens h‚ÇÅ h‚ÇÇ ih‚ÇÅ ih‚ÇÇ =>
      simp_all;
      have ‚ü®hŒì‚ÇÅ, hŒì‚ÇÇ‚ü© := hŒì;
      subst hŒì‚ÇÅ hŒì‚ÇÇ;
      simpa using modus_ponens'! (ih‚ÇÅ h‚ÇÅ) (ih‚ÇÇ h‚ÇÇ);
    | necessitation =>
      simp_all [Formula.toPropFormula];
      exact imp_id!;
    | _ =>
      simp_all;
      try first
      | apply imp_id!;
      | apply imply‚ÇÅ!;
      | apply imply‚ÇÇ!;
      | apply conj‚ÇÅ!;
      | apply conj‚ÇÇ!;
      | apply conj‚ÇÉ!;
      | apply disj‚ÇÅ!;
      | apply disj‚ÇÇ!;
      | apply disj‚ÇÉ!;
      | apply dne!;
  . intro h;
    subst hŒì;
    have d‚ÇÅ : ‚àÖ ‚ä¢·¥π[ùêïùêûùê´]! p‚±Ω ‚ü∂ p := iff_mpr'! deducible_iff_verTranslation;
    have d‚ÇÇ : ‚àÖ ‚ä¢·¥π[ùêïùêûùê´]! p‚±Ω := by sorry; -- simpa using of_classical h;
    simpa using modus_ponens'! d‚ÇÅ d‚ÇÇ;

theorem iff_Ver_classical : (‚àÖ ‚ä¢·¥π[ùêïùêûùê´]! p) ‚Üî (‚àÖ ‚ä¢·∂ú! p‚±Ω·¥æ) := iff_Ver_classical_aux rfl

example : (‚àÖ ‚ä¢·¥π[ùêìùê´ùê¢ùêØ]! axiomL p) := by
  apply iff_Triv_classical.mpr;
  simp;
  sorry;

example : (‚àÖ ‚ä¢·¥π[ùêïùêûùê´]! (~(‚ñ°‚ä•) : Formula Œ±)) := by
  apply iff_Ver_classical.mpr;
  simp;
  sorry;


end LO.Modal.Normal
