import Logic.Vorspiel.BinaryRelations
import Logic.Logic.Semantics
import Logic.Propositional.Superintuitionistic.Deduction

namespace LO.Kripke

structure Frame where
  World : Type*
  Rel : Rel World World
  [World_nonempty : Nonempty World]

instance : CoeSort Frame Type* := ‚ü®Frame.World‚ü©
instance : CoeFun Frame (Œª F => F.World ‚Üí F.World ‚Üí Prop) := ‚ü®Frame.Rel‚ü©

instance {F : Frame} : Nonempty F.World := F.World_nonempty

abbrev Frame.Rel' {F : Frame} (x y : F.World) := F.Rel x y
scoped infix:45 " ‚â∫ " => Frame.Rel'

noncomputable abbrev Frame.default {F : Frame} : F.World := Classical.choice F.World_nonempty
notation "Ôπ´" => Frame.default


set_option linter.unusedVariables false in
abbrev Frame.Dep (Œ± : Type*) := Frame

abbrev Frame.alt (F : Frame) {Œ±} : Frame.Dep Œ± := F
scoped postfix:max "#" => Frame.alt


structure FiniteFrame extends Frame where
  [World_finite : Finite World]

instance {F : FiniteFrame} : Finite (F.World) := F.World_finite
instance : Coe (FiniteFrame) (Frame) := ‚ü®Œª F ‚Ü¶ F.toFrame‚ü©


open Relation (ReflTransGen TransGen)


protected abbrev Frame.RelReflTransGen {F : Frame} : _root_.Rel F.World F.World:= ReflTransGen (¬∑ ‚â∫ ¬∑)
scoped infix:45 " ‚â∫^* " => Frame.RelReflTransGen

namespace Frame.RelReflTransGen

variable {F : Frame}

@[simp] lemma single {x y : F.World} (hxy : x ‚â∫ y) : x ‚â∫^* y := ReflTransGen.single hxy

@[simp] lemma reflexive : Reflexive F.RelReflTransGen := Relation.reflexive_reflTransGen

@[simp] lemma refl {x : F.World} : x ‚â∫^* x := reflexive x

@[simp] lemma transitive : Transitive F.RelReflTransGen := Relation.transitive_reflTransGen

@[simp] lemma symmetric : Symmetric F.Rel ‚Üí Symmetric F.RelReflTransGen := ReflTransGen.symmetric

end Frame.RelReflTransGen


abbrev Frame.TransitiveReflexiveClosure (F : Frame) : Frame where
  World := F.World
  Rel := (¬∑ ‚â∫^* ¬∑)
postfix:max "^*" => Frame.TransitiveReflexiveClosure

namespace Frame.TransitiveReflexiveClosure

variable {F : Frame}

lemma single {x y : F.World} (hxy : x ‚â∫ y) : F^*.Rel x y := ReflTransGen.single hxy

lemma rel_reflexive : Reflexive F^*.Rel := by intro x; exact ReflTransGen.refl;

lemma rel_transitive : Transitive F^*.Rel := by simp;

lemma rel_symmetric : Symmetric F.Rel ‚Üí Symmetric F^* := ReflTransGen.symmetric

end Frame.TransitiveReflexiveClosure



protected abbrev Frame.RelTransGen {F : Frame} : _root_.Rel F.World F.World := TransGen (¬∑ ‚â∫ ¬∑)
scoped infix:45 " ‚â∫^+ " => Frame.RelTransGen

namespace Frame.RelTransGen

variable {F : Frame}

@[simp] lemma single {x y : F.World} (hxy : x ‚â∫ y) : x ‚â∫^+ y := TransGen.single hxy

@[simp]
lemma transitive : Transitive F.RelTransGen := Œª _ _ _ => TransGen.trans

@[simp]
lemma symmetric (hSymm : Symmetric F.Rel) : Symmetric F.RelTransGen := by
  intro x y rxy;
  induction rxy with
  | single h => exact TransGen.single $ hSymm h;
  | tail _ hyz ih => exact TransGen.trans (TransGen.single $ hSymm hyz) ih

end Frame.RelTransGen


abbrev Frame.TransitiveClosure (F : Frame) : Frame where
  World := F.World
  Rel := (¬∑ ‚â∫^+ ¬∑)
scoped postfix:max "^+" => Frame.TransitiveClosure

namespace Frame.TransitiveClosure

variable {F : Frame}

lemma single {x y : F.World} (hxy : x ‚â∫ y) : F^+ x y := TransGen.single hxy

lemma rel_transitive : Transitive F^+ := by simp;

lemma rel_symmetric (hSymm : Symmetric F.Rel) : Symmetric F.TransitiveClosure := by simp_all

end Frame.TransitiveClosure


abbrev FrameProperty := Frame ‚Üí Prop


abbrev FrameClass := Set (Frame)

set_option linter.unusedVariables false in
abbrev FrameClass.Dep (Œ± : Type*) := FrameClass

abbrev FrameClass.alt (ùîΩ : FrameClass) {Œ±} : FrameClass.Dep Œ± := ùîΩ
scoped postfix:max "#" => FrameClass.alt


abbrev FiniteFrameClass := Set (FiniteFrame)

@[simp] def FiniteFrameClass.toFrameClass (ùîΩ : FiniteFrameClass) : FrameClass := { F | ‚àÉ F', F' ‚àà ùîΩ ‚àß F'.toFrame = F }
instance : Coe (FiniteFrameClass) (FrameClass) := ‚ü®FiniteFrameClass.toFrameClass‚ü©

@[simp] def FrameClass.toFiniteFrameClass (ùîΩ : FrameClass) : FiniteFrameClass := { F | F.toFrame ‚àà ùîΩ }
instance : Coe (FrameClass) (FiniteFrameClass) := ‚ü®FrameClass.toFiniteFrameClass‚ü©

@[simp] abbrev FrameClass.restrictFinite (ùîΩ : FrameClass) : FrameClass := FiniteFrameClass.toFrameClass ‚ÜëùîΩ
postfix:max "Íü≥" => FrameClass.restrictFinite

lemma FrameClass.iff_mem_restrictFinite {ùîΩ : FrameClass} (h : F ‚àà ùîΩ) (F_finite : Finite F.World) : F ‚àà ùîΩÍü≥ := by
  simp;
  use { toFrame := F, World_finite := F_finite };


abbrev FrameClassOfSystem [System F S] [Semantics F (Frame.Dep Œ±)] (ùì¢ : S) : FrameClass.Dep Œ± := { (F : Frame.Dep Œ±) | F ‚äß* System.theory ùì¢ }
notation "ùîΩ(" ùì¢ ")" => FrameClassOfSystem ùì¢

abbrev FrameClassOfFrameProperty (P : FrameProperty) : FrameClass := { F | P F }
notation "ùîΩ(" P ")" => FrameClassOfFrameProperty P


class Characteraizable (ùîΩ : FrameClass) (P : FrameProperty) where
  characterize : ‚àÄ {F}, P F ‚Üí F ‚àà ùîΩ
  nonempty : ‚àÉ F, P F


section Soundness

variable [System F S] [Semantics F (Frame.Dep Œ±)] {ùì¢ : S}

lemma sound : ùì¢ ‚ä¢! p ‚Üí (FrameClassOfSystem (Œ± := Œ±) ùì¢) ‚äß p := by
  intro hp F hF;
  simp [System.theory] at hF;
  exact hF p hp;

instance : Sound ùì¢ (FrameClassOfSystem (Œ± := Œ±) ùì¢) := ‚ü®sound‚ü©


lemma sound_of_characterizability (characterizability : Characteraizable (FrameClassOfSystem (Œ± := Œ±) ùì¢) P) : ùì¢ ‚ä¢! p ‚Üí ùîΩ(P) ‚äß p := by
  intro h F hF;
  apply sound h;
  apply characterizability.characterize hF;

instance instSoundOfCharacterizability (characterizability : Characteraizable (FrameClassOfSystem (Œ± := Œ±) ùì¢) P)
  : Sound ùì¢ (FrameClassOfFrameProperty P) := ‚ü®sound_of_characterizability characterizability‚ü©


variable [LogicalConnective F] [Semantics.Bot (FrameClass.Dep Œ±)]

lemma unprovable_bot : ùì¢ ‚ä¨! ‚ä• := by
  apply (not_imp_not.mpr (sound (Œ± := Œ±)));
  exact Semantics.Bot.realize_bot ùîΩ(ùì¢);

lemma unprovable_bot_of_characterizability [characterizability : Characteraizable (FrameClassOfSystem (Œ± := Œ±) ùì¢) P] : ùì¢ ‚ä¨! ‚ä• := by
  apply not_imp_not.mpr $ sound_of_characterizability (characterizability := characterizability);
  exact Semantics.Bot.realize_bot ùîΩ(P);

-- instance : System.Consistent ùì¢ := System.Consistent.of_unprovable $ unprovable_bot (Œ± := Œ±)

end Soundness


abbrev Valuation (F : Frame) (Œ± : Type*) := F.World ‚Üí Œ± ‚Üí Prop

abbrev Valuation.atomic_hereditary (V : Valuation F Œ±) : Prop := ‚àÄ {w‚ÇÅ w‚ÇÇ : F.World}, (w‚ÇÅ ‚â∫ w‚ÇÇ) ‚Üí ‚àÄ {a}, (V w‚ÇÅ a) ‚Üí (V w‚ÇÇ a)


structure Model (Œ±) where
  Frame : Frame
  Valuation : Valuation Frame Œ±

abbrev Model.World (M : Model Œ±) := M.Frame.World
instance : CoeSort (Model Œ±) (Type u) := ‚ü®Model.World‚ü©

end LO.Kripke


namespace LO.Propositional.Superintuitionistic

/-
namespace Kripke

attribute [simp] Reflexive Transitive Antisymmetric in
structure Frame where
  World : Type u
  [World_nonempty : Inhabited World]
  Rel : World ‚Üí World ‚Üí Prop
  Rel_refl : Reflexive Rel := by aesop
  Rel_trans : Transitive Rel := by aesop
  Rel_antisymm : Antisymmetric Rel := by aesop

instance {F : Frame} : Inhabited F.World := F.World_nonempty

structure FiniteFrame extends Frame where
  [World_finite : Finite World]

instance {F : FiniteFrame} : Finite F.World := F.World_finite

instance : CoeSort Frame Type* where coe := Frame.World

instance (F : Frame) : Inhabited F.World := F.World_nonempty

set_option linter.unusedVariables false in
abbrev Frame' (Œ± : Type*) := Frame

set_option linter.unusedVariables false in
abbrev FiniteFrame' (Œ± : Type*) := FiniteFrame

def FiniteFrame.toFrame' {Œ± : Type*} (F : FiniteFrame) : Frame' Œ± := F.toFrame

abbrev Frame.Rel' {F : Frame} (w w' : F.World) := F.Rel w w'
scoped infix:45 " ‚â∫ " => Frame.Rel'

abbrev Frame.defaultWorld {F : Frame} : F.World := F.World_nonempty.default
-- NOTE: not `@`, `Ôπ´` (U+FE6B)
scoped notation "Ôπ´" => Frame.defaultWorld

abbrev Valuation (W Œ± : Type u) := W ‚Üí Œ± ‚Üí Prop

structure Model (Œ±) where
  Frame : Frame' Œ±
  Valuation : Valuation Frame.World Œ±
  hereditary : ‚àÄ {w‚ÇÅ w‚ÇÇ}, (w‚ÇÅ ‚â∫ w‚ÇÇ) ‚Üí ‚àÄ {a}, (Valuation w‚ÇÅ a) ‚Üí (Valuation w‚ÇÇ a)

abbrev Model.World (M : Model Œ±) := M.Frame.World
instance : CoeSort (Model Œ±) (Type u) where coe := Model.World

abbrev Model.Rel (M : Model Œ±) := M.Frame.Rel


abbrev FrameClass := Set Frame

set_option linter.unusedVariables false in
abbrev FrameClass' (Œ± : Type*) := FrameClass

class FrameClass.IsNonempty (ùîΩ : FrameClass) where
  nonempty : ‚àÉ F, F ‚àà ùîΩ



abbrev FiniteFrameClass := Set FiniteFrame

set_option linter.unusedVariables false in
abbrev FiniteFrameClass' (Œ± : Type*) := FiniteFrameClass

class FiniteFrameClass.IsNonempty (ùîΩ : FiniteFrameClass) where
  nonempty : ‚àÉ F, F ‚àà ùîΩ


abbrev FrameProperty := Frame ‚Üí Prop

abbrev FiniteFrameProperty := FiniteFrame ‚Üí Prop

section

end

end Kripke
-/

open System
open Kripke

variable [Inhabited Œ±]

def Formula.Kripke.Satisfies (M : Kripke.Model Œ±) (w : M.World) : Formula Œ± ‚Üí Prop
  | atom a => M.Valuation w a
  | ‚ä§      => True
  | ‚ä•      => False
  | p ‚ãè q  => Satisfies M w p ‚àß Satisfies M w q
  | p ‚ãé q  => Satisfies M w p ‚à® Satisfies M w q
  | ~p     => ‚àÄ {w' : M.World}, (w ‚â∫ w') ‚Üí ¬¨Satisfies M w' p
  | p ‚ü∂ q => ‚àÄ {w' : M.World}, (w ‚â∫ w') ‚Üí (Satisfies M w' p ‚Üí Satisfies M w' q)

instance instKripkeSemanticsFormulaWorld (M : Model Œ±) : Semantics (Formula Œ±) (M.World) := ‚ü®fun w ‚Ü¶ Formula.Kripke.Satisfies M w‚ü©

open Formula.Kripke

namespace Formula.Kripke.Satisfies

variable {M : Model Œ±} {w : M.World} {p q r : Formula Œ±}

@[simp] protected lemma iff_models : w ‚äß p ‚Üî Formula.Kripke.Satisfies M w p := iff_of_eq rfl

@[simp] lemma atom_def : w ‚äß atom a ‚Üî M.Valuation w a := by simp [Satisfies];
@[simp] lemma top_def  : w ‚äß ‚ä§ ‚Üî True := by simp [Satisfies];
@[simp] lemma bot_def  : w ‚äß ‚ä• ‚Üî False := by simp [Satisfies];
@[simp] lemma and_def  : w ‚äß p ‚ãè q ‚Üî w ‚äß p ‚àß w ‚äß q := by simp [Satisfies];
@[simp] lemma or_def   : w ‚äß p ‚ãé q ‚Üî w ‚äß p ‚à® w ‚äß q := by simp [Satisfies];
@[simp] lemma imp_def  : w ‚äß p ‚ü∂ q ‚Üî ‚àÄ {w' : M.World}, (w ‚â∫ w') ‚Üí (w' ‚äß p ‚Üí w' ‚äß q) := by simp [Satisfies, imp_iff_not_or];
@[simp] lemma neg_def  : w ‚äß ~p ‚Üî ‚àÄ {w' : M.World}, (w ‚â∫ w') ‚Üí ¬¨(w' ‚äß p) := by simp [Satisfies];

instance : Semantics.Top M.World where
  realize_top := by simp [Satisfies];

instance : Semantics.Bot M.World where
  realize_bot := by simp [Satisfies];

instance : Semantics.And M.World where
  realize_and := by simp [Satisfies];

instance : Semantics.Or M.World where
  realize_or := by simp [Satisfies];



lemma formula_hereditary
  (herditary : M.Valuation.atomic_hereditary)
  (F_trans : Transitive M.Frame.Rel)
  (hw : w ‚â∫ w') : w ‚äß p ‚Üí w' ‚äß p := by
  induction p using Formula.rec' with
  | hatom => apply herditary hw;
  | himp =>
    intro hpq v hv;
    exact hpq $ F_trans hw hv;
  | hneg =>
    intro hp v hv;
    exact hp $ F_trans hw hv;
  | hor => simp_all [Satisfies]; tauto;
  | _ => simp_all [Satisfies];

/-
lemma hereditary_int {M : Model (ùêàùêßùê≠ W Œ±)} {w w' : W} {p : Formula Œ±} (hw : M.frame w w') : (M, w) ‚äß p ‚Üí (M, w') ‚äß p := by
  apply hereditary (by simp [FrameClass.Intuitionistic]; tauto) hw;
-/

lemma neg_equiv : w ‚äß ~p ‚Üî w ‚äß p ‚ü∂ ‚ä• := by simp_all [Satisfies];

end Formula.Kripke.Satisfies


open Formula.Kripke.Satisfies (formula_hereditary)


def Formula.Kripke.ValidOnModel (M : Model Œ±) (p : Formula Œ±) := ‚àÄ w : M.World, w ‚äß p

namespace Formula.Kripke.ValidOnModel

variable
  {M : Model Œ±} {p q r : Formula Œ±}
  (atom_hereditary : ‚àÄ {w‚ÇÅ w‚ÇÇ : M.World}, (w‚ÇÅ ‚â∫ w‚ÇÇ) ‚Üí ‚àÄ {a}, (M.Valuation w‚ÇÅ a) ‚Üí (M.Valuation w‚ÇÇ a))
  (F_trans : Transitive M.Frame.Rel := by simpa)
  (F_refl : Reflexive M.Frame.Rel := by simpa)

instance : Semantics (Formula Œ±) (Model Œ±) := ‚ü®fun M ‚Ü¶ Formula.Kripke.ValidOnModel M‚ü©

@[simp] protected lemma iff_models : M ‚äß p ‚Üî Formula.Kripke.ValidOnModel M p := iff_of_eq rfl

@[simp] protected lemma verum : M ‚äß ‚ä§ := by simp_all [ValidOnModel];

@[simp] protected lemma and‚ÇÅ : M ‚äß p ‚ãè q ‚ü∂ p := by simp_all [ValidOnModel, Satisfies];

@[simp] protected lemma and‚ÇÇ : M ‚äß p ‚ãè q ‚ü∂ q := by simp_all [ValidOnModel, Satisfies];

@[simp] protected lemma and‚ÇÉ : M ‚äß p ‚ü∂ q ‚ü∂ p ‚ãè q := by
  intro x y _ hp z Ryz hq;
  replace hp : Satisfies M z p := formula_hereditary atom_hereditary F_trans Ryz hp;
  exact ‚ü®hp, hq‚ü©;

@[simp] protected lemma or‚ÇÅ : M ‚äß p ‚ü∂ p ‚ãé q := by simp_all [ValidOnModel, Satisfies];

@[simp] protected lemma or‚ÇÇ : M ‚äß q ‚ü∂ p ‚ãé q := by simp_all [ValidOnModel, Satisfies];

@[simp] protected lemma or‚ÇÉ : M ‚äß (p ‚ü∂ r) ‚ü∂ (q ‚ü∂ r) ‚ü∂ (p ‚ãé q ‚ü∂ r) := by
  simp_all only [ValidOnModel.iff_models, ValidOnModel, Satisfies.iff_models, Satisfies.imp_def, Satisfies.or_def];
  intro w‚ÇÅ w‚ÇÇ _ hpr w‚ÇÉ hw‚ÇÇ‚ÇÉ hqr w‚ÇÑ hw‚ÇÉ‚ÇÑ hpq;
  cases hpq with
  | inl hp => exact hpr (F_trans hw‚ÇÇ‚ÇÉ hw‚ÇÉ‚ÇÑ) hp;
  | inr hq => exact hqr hw‚ÇÉ‚ÇÑ hq;

@[simp] protected lemma imply‚ÇÅ : M ‚äß p ‚ü∂ q ‚ü∂ p := by
  intro x y _ hp z Ryz _;
  exact formula_hereditary atom_hereditary F_trans Ryz hp;

@[simp] protected lemma imply‚ÇÇ : M ‚äß (p ‚ü∂ q ‚ü∂ r) ‚ü∂ (p ‚ü∂ q) ‚ü∂ p ‚ü∂ r := by
  intro x y _ hpqr z Ryz hpq w Rzw hp;
  have Ryw := F_trans Ryz Rzw;
  have Rww := F_refl w;
  exact hpqr Ryw hp Rww (hpq Rzw hp);

@[simp] protected lemma mdp (hpq : M ‚äß p ‚ü∂ q) (hp : M ‚äß p) : M ‚äß q := by
  intro w;
  exact hpq w (F_refl w) $ hp w;

@[simp] protected lemma efq : M ‚äß Axioms.EFQ p := by simp [ValidOnModel, Satisfies];

@[simp] protected lemma neg_equiv : M ‚äß Axioms.NegEquiv p := by
  simp_all [ValidOnModel, Axioms.NegEquiv];
  intro w;
  constructor;
  . intro x _ h y rxy hyp; exact h rxy hyp;
  . intro x _ h y rxy; exact h rxy;

@[simp] protected lemma lem (hExt : Extensive M.Frame.Rel) : M ‚äß Axioms.LEM p := by
  simp_all [ValidOnModel];
  intro w;
  by_cases h : w ‚äß p
  . left; assumption;
  . right;
    intro w' hww';
    rw [‚Üê(hExt hww')];
    assumption;

end Formula.Kripke.ValidOnModel


def Formula.Kripke.ValidOnFrame (F : Frame) (p : Formula Œ±) :=
  ‚àÄ {V : Valuation F Œ±}, (_ : V.atomic_hereditary) ‚Üí (‚ü®F, V‚ü© : Kripke.Model Œ±) ‚äß p

namespace Formula.Kripke.ValidOnFrame

instance : Semantics (Formula Œ±) (Frame.Dep Œ±) := ‚ü®fun F ‚Ü¶ Formula.Kripke.ValidOnFrame F‚ü©

variable {F : Frame.Dep Œ±}

@[simp] protected lemma models_iff : F ‚äß f ‚Üî ValidOnFrame F f := iff_of_eq rfl

variable {F : Frame.Dep Œ±} {p q r : Formula Œ±}
         (F_trans : Transitive F)
         (F_refl : Reflexive F)

@[simp] protected lemma verum : F ‚äß ‚ä§ := fun _ => ValidOnModel.verum

@[simp] protected lemma and‚ÇÅ : F ‚äß p ‚ãè q ‚ü∂ p := fun _ => ValidOnModel.and‚ÇÅ

@[simp] protected lemma and‚ÇÇ : F ‚äß p ‚ãè q ‚ü∂ q := fun _ => ValidOnModel.and‚ÇÇ

@[simp] protected lemma and‚ÇÉ : F ‚äß p ‚ü∂ q ‚ü∂ p ‚ãè q := fun hV => ValidOnModel.and‚ÇÉ hV F_trans

@[simp] protected lemma or‚ÇÅ : F ‚äß p ‚ü∂ p ‚ãé q := fun _ => ValidOnModel.or‚ÇÅ

@[simp] protected lemma or‚ÇÇ : F ‚äß q ‚ü∂ p ‚ãé q := fun _ => ValidOnModel.or‚ÇÇ

@[simp] protected lemma or‚ÇÉ : F ‚äß (p ‚ü∂ r) ‚ü∂ (q ‚ü∂ r) ‚ü∂ (p ‚ãé q ‚ü∂ r) := fun _ => ValidOnModel.or‚ÇÉ F_trans

@[simp] protected lemma imply‚ÇÅ : F ‚äß p ‚ü∂ q ‚ü∂ p := fun hV => ValidOnModel.imply‚ÇÅ hV F_trans

@[simp] protected lemma imply‚ÇÇ : F ‚äß (p ‚ü∂ q ‚ü∂ r) ‚ü∂ (p ‚ü∂ q) ‚ü∂ p ‚ü∂ r := fun _ => ValidOnModel.imply‚ÇÇ F_trans F_refl

@[simp] protected lemma mdp (hpq : F ‚äß p ‚ü∂ q) (hp : F ‚äß p) : F ‚äß q := fun hV => ValidOnModel.mdp F_refl (hpq hV) (hp hV)

@[simp] protected lemma efq : F ‚äß Axioms.EFQ p := fun _ => ValidOnModel.efq

@[simp] protected lemma neg_equiv : F ‚äß Axioms.NegEquiv p := fun _ => ValidOnModel.neg_equiv

@[simp] protected lemma lem (hExt : Extensive F.Rel) : F ‚äß Axioms.LEM p := fun _ => ValidOnModel.lem hExt

instance : Semantics.Bot (Frame.Dep Œ±) where
  realize_bot _ := by
    simp [ValidOnModel, ValidOnFrame];
    existsi (Œª _ _ => True);
    simp_all [Satisfies, Valuation.atomic_hereditary];

end Formula.Kripke.ValidOnFrame


@[simp] def Formula.Kripke.ValidOnFrameClass (ùîΩ : FrameClass) (p : Formula Œ±) := ‚àÄ {F : Frame}, F ‚àà ùîΩ ‚Üí F# ‚äß p

namespace Formula.Kripke.ValidOnFrameClass

instance : Semantics (Formula Œ±) (FrameClass.Dep Œ±) := ‚ü®fun ùîΩ ‚Ü¶ Formula.Kripke.ValidOnFrameClass ùîΩ‚ü©

@[simp] protected lemma iff_models {ùîΩ : FrameClass.Dep Œ±} : ùîΩ ‚äß p ‚Üî Formula.Kripke.ValidOnFrameClass ùîΩ p := iff_of_eq rfl

protected lemma realize_bot {ùîΩ : FrameClass.Dep Œ±} (ne : ùîΩ.Nonempty) : ¬¨(ùîΩ ‚äß ‚ä•) := by
  simp [ValidOnFrameClass.iff_models, ValidOnFrameClass];
  exact ne;

end Formula.Kripke.ValidOnFrameClass

/-
@[simp] def Formula.Kripke.ValidOnFiniteFrameClass (ùîΩ : FiniteFrameClass) (f : Formula Œ±) := ‚àÄ (F : FiniteFrame' Œ±), F ‚àà ùîΩ ‚Üí F.toFrame' ‚äß f

instance : Semantics (Formula Œ±) (FiniteFrameClass' Œ±) := ‚ü®fun ùîΩ ‚Ü¶ Formula.Kripke.ValidOnFiniteFrameClass ùîΩ‚ü©

namespace Formula.Kripke.ValidOnFiniteFrameClass

@[simp] protected lemma models_iff {ùîΩ : FiniteFrameClass' Œ±} : ùîΩ ‚äß f ‚Üî Formula.Kripke.ValidOnFiniteFrameClass ùîΩ f := iff_of_eq rfl

end Formula.Kripke.ValidOnFiniteFrameClass
-/


namespace Kripke

instance Characteraizable_Int : Kripke.Characteraizable ùîΩ((ùêàùêßùê≠ : DeductionParameter Œ±)) (Œª F => Transitive F ‚àß Reflexive F) where
  characterize := by
    simp [System.theory];
    intro F hTrans hRefl p hp;
    induction hp using Deduction.rec! with
    | verum => apply ValidOnFrame.verum;
    | imply‚ÇÅ => apply ValidOnFrame.imply‚ÇÅ; simpa;
    | imply‚ÇÇ => apply ValidOnFrame.imply‚ÇÇ; simpa; simpa;
    | and‚ÇÅ => apply ValidOnFrame.and‚ÇÅ;
    | and‚ÇÇ => apply ValidOnFrame.and‚ÇÇ;
    | and‚ÇÉ => apply ValidOnFrame.and‚ÇÉ; simpa;
    | or‚ÇÅ => apply ValidOnFrame.or‚ÇÅ;
    | or‚ÇÇ => apply ValidOnFrame.or‚ÇÇ;
    | or‚ÇÉ => apply ValidOnFrame.or‚ÇÉ; simpa;
    | neg_equiv => apply ValidOnFrame.neg_equiv;
    | mdp ihpq ihp =>
      apply ValidOnFrame.mdp;
      repeat simpa;
    | eaxm h =>
      obtain ‚ü®_, rfl‚ü© := h;
      apply ValidOnFrame.efq;
  nonempty := by
    use { World := PUnit, Rel := Œª _ _ => True };
    simp [Transitive, Reflexive];

abbrev _root_.LO.Kripke.TransitiveReflexiveFrameClass : FrameClass := ùîΩ((Œª F => Transitive F ‚àß Reflexive F))


instance : Sound (ùêàùêßùê≠ : DeductionParameter Œ±) TransitiveReflexiveFrameClass# :=
  LO.Kripke.instSoundOfCharacterizability (characterizability := Kripke.Characteraizable_Int)

instance Characteraizable_Cl : Kripke.Characteraizable ùîΩ((ùêÇùê• : DeductionParameter Œ±)) (Œª F => Transitive F ‚àß Reflexive F ‚àß Extensive F) where
  characterize := by
    simp [System.theory];
    intro F hTrans hRefl hExt p hp;
    induction hp using Deduction.rec! with
    | verum => apply ValidOnFrame.verum;
    | imply‚ÇÅ => apply ValidOnFrame.imply‚ÇÅ; simpa;
    | imply‚ÇÇ => apply ValidOnFrame.imply‚ÇÇ; simpa; simpa;
    | and‚ÇÅ => apply ValidOnFrame.and‚ÇÅ;
    | and‚ÇÇ => apply ValidOnFrame.and‚ÇÇ;
    | and‚ÇÉ => apply ValidOnFrame.and‚ÇÉ; simpa;
    | or‚ÇÅ => apply ValidOnFrame.or‚ÇÅ;
    | or‚ÇÇ => apply ValidOnFrame.or‚ÇÇ;
    | or‚ÇÉ => apply ValidOnFrame.or‚ÇÉ; simpa;
    | neg_equiv => apply ValidOnFrame.neg_equiv;
    | mdp ihpq ihp =>
      apply ValidOnFrame.mdp;
      repeat simpa;
    | eaxm h =>
      rcases h with (‚ü®_, rfl‚ü© | ‚ü®_, rfl‚ü©);
      . apply ValidOnFrame.efq;
      . apply ValidOnFrame.lem; simpa;
  nonempty := by
    use { World := PUnit, Rel := Œª _ _ => True };
    simp [Transitive, Reflexive, Extensive];

abbrev _root_.LO.Kripke.TransitiveReflexiveExtensiveFrameClass : FrameClass := ùîΩ((Œª F => Transitive F ‚àß Reflexive F ‚àß Extensive F))

instance : Sound (ùêÇùê• : DeductionParameter Œ±) TransitiveReflexiveExtensiveFrameClass# :=
  LO.Kripke.instSoundOfCharacterizability (characterizability := Kripke.Characteraizable_Cl)

end Kripke

end LO.Propositional.Superintuitionistic
