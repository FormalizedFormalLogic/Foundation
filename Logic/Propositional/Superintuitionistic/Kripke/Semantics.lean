import Logic.Vorspiel.BinaryRelations
import Logic.Logic.Semantics
import Logic.Propositional.Superintuitionistic.Formula

namespace LO.Propositional.Superintuitionistic

namespace Kripke

attribute [simp] Reflexive Transitive Antisymmetric in
structure Frame where
  World : Type u
  World_nonempty : Inhabited World := by infer_instance
  [World_decEq : DecidableEq World]
  Rel : World ‚Üí World ‚Üí Prop
  Rel_refl : Reflexive Rel := by aesop
  Rel_trans : Transitive Rel := by aesop
  Rel_antisymm : Antisymmetric Rel := by aesop

instance {F : Frame} : DecidableEq F.World := F.World_decEq

structure FiniteFrame extends Frame where
  World_finite : Finite World := by infer_instance

instance : CoeSort Frame Type* where coe := Frame.World

instance (F : Frame) : Inhabited F.World := F.World_nonempty

set_option linter.unusedVariables false in
abbrev Frame' (Œ± : Type*) := Frame

set_option linter.unusedVariables false in
abbrev FiniteFrame' (Œ± : Type*) := FiniteFrame

def FiniteFrame.toFrame' {Œ± : Type*} (F : FiniteFrame) : Frame' Œ± := F.toFrame

abbrev Frame.Rel' {F : Frame} (w w' : F.World) := F.Rel w w'
scoped infix:45 " ‚â∫ " => Frame.Rel'

abbrev Frame.defaultWorld {F : Frame} : F.World := F.World_nonempty.default
-- NOTE: not `@`, `Ôπ´` (U+FE6B)
scoped notation "Ôπ´" => Frame.defaultWorld

abbrev Valuation (W Œ± : Type u) := W ‚Üí Œ± ‚Üí Prop

structure Model (Œ±) where
  Frame : Frame' Œ±
  Valuation : Valuation Frame.World Œ±
  hereditary : ‚àÄ {w‚ÇÅ w‚ÇÇ}, (w‚ÇÅ ‚â∫ w‚ÇÇ) ‚Üí ‚àÄ {a}, (Valuation w‚ÇÅ a) ‚Üí (Valuation w‚ÇÇ a)

abbrev Model.World (M : Model Œ±) := M.Frame.World
instance : CoeSort (Model Œ±) (Type u) where coe := Model.World

abbrev Model.Rel (M : Model Œ±) := M.Frame.Rel


abbrev FrameClass := Set Frame

set_option linter.unusedVariables false in
abbrev FrameClass' (Œ± : Type*) := FrameClass

class FrameClass.IsNonempty (ùîΩ : FrameClass) where
  nonempty : ‚àÉ F, F ‚àà ùîΩ



abbrev FiniteFrameClass := Set FiniteFrame

set_option linter.unusedVariables false in
abbrev FiniteFrameClass' (Œ± : Type*) := FiniteFrameClass

class FiniteFrameClass.IsNonempty (ùîΩ : FiniteFrameClass) where
  nonempty : ‚àÉ F, F ‚àà ùîΩ


abbrev FrameProperty := Frame ‚Üí Prop

abbrev FiniteFrameProperty := FiniteFrame ‚Üí Prop

section

end

end Kripke

open System
open Kripke

variable [Inhabited Œ±]

def Formula.Kripke.Satisfies (M : Kripke.Model Œ±) (w : M.World) : Formula Œ± ‚Üí Prop
  | atom a => M.Valuation w a
  | ‚ä§      => True
  | ‚ä•      => False
  | p ‚ãè q  => Satisfies M w p ‚àß Satisfies M w q
  | p ‚ãé q  => Satisfies M w p ‚à® Satisfies M w q
  | ~p     => ‚àÄ {w'}, (w ‚â∫ w') ‚Üí ¬¨Satisfies M w' p
  | p ‚ü∂ q => ‚àÄ {w'}, (w ‚â∫ w') ‚Üí (Satisfies M w' p ‚Üí Satisfies M w' q)

instance instKripkeSemanticsFormulaWorld (M : Model Œ±) : Semantics (Formula Œ±) (M.World) := ‚ü®fun w ‚Ü¶ Formula.Kripke.Satisfies M w‚ü©

open Formula.Kripke

namespace Formula.Kripke.Satisfies

variable {M : Model Œ±}

@[simp] protected lemma iff_models : w ‚äß p ‚Üî Formula.Kripke.Satisfies M w p := iff_of_eq rfl

local infix:45 " ‚ä© " => Formula.Kripke.Satisfies M

@[simp] lemma atom_def : w ‚ä© atom a ‚Üî M.Valuation w a := by simp [Satisfies];
@[simp] lemma top_def  : w ‚ä© ‚ä§ ‚Üî True := by simp [Satisfies];
@[simp] lemma bot_def  : w ‚ä© ‚ä• ‚Üî False := by simp [Satisfies];
@[simp] lemma and_def  : w ‚ä© p ‚ãè q ‚Üî w ‚ä© p ‚àß w ‚ä© q := by simp [Satisfies];
@[simp] lemma or_def   : w ‚ä© p ‚ãé q ‚Üî w ‚ä© p ‚à® w ‚ä© q := by simp [Satisfies];
@[simp] lemma imp_def  : w ‚ä© p ‚ü∂ q ‚Üî ‚àÄ {w'}, (w ‚â∫ w') ‚Üí (w' ‚ä© p ‚Üí w' ‚ä© q) := by simp [Satisfies, imp_iff_not_or];
@[simp] lemma neg_def  : w ‚ä© ~p ‚Üî ‚àÄ {w'}, (w ‚â∫ w') ‚Üí ¬¨(w' ‚ä© p) := by simp [Satisfies];

instance : Semantics.Top M.World where
  realize_top := by simp [Satisfies];

instance : Semantics.Bot M.World where
  realize_bot := by simp [Satisfies];

instance : Semantics.And M.World where
  realize_and := by simp [Satisfies];

instance : Semantics.Or M.World where
  realize_or := by simp [Satisfies];

lemma formula_hereditary (hw : w ‚â∫ w') : w ‚ä© p ‚Üí w' ‚ä© p := by
  induction p using Formula.rec' with
  | hatom => apply M.hereditary hw;
  | himp =>
    simp_all [Satisfies];
    intro hpq v hv;
    exact hpq $ M.Frame.Rel_trans hw hv;
  | hneg =>
    simp_all [Satisfies];
    intro hp v hv;
    exact hp $ M.Frame.Rel_trans hw hv;
  | hor => simp_all [Satisfies]; tauto;
  | _ => simp_all [Satisfies];

/-
lemma hereditary_int {M : Model (ùêàùêßùê≠ W Œ±)} {w w' : W} {p : Formula Œ±} (hw : M.frame w w') : (M, w) ‚äß p ‚Üí (M, w') ‚äß p := by
  apply hereditary (by simp [FrameClass.Intuitionistic]; tauto) hw;
-/

lemma neg_equiv : w ‚ä© ~p ‚Üî w ‚ä© p ‚ü∂ ‚ä• := by simp_all [Satisfies];

end Formula.Kripke.Satisfies


def Formula.Kripke.ValidOnModel (M : Model Œ±) (p : Formula Œ±) := ‚àÄ w : M.World, w ‚äß p

instance : Semantics (Formula Œ±) (Model Œ±) := ‚ü®fun M ‚Ü¶ Formula.Kripke.ValidOnModel M‚ü©

namespace Formula.Kripke.ValidOnModel

@[simp] protected lemma iff_models : M ‚äß p ‚Üî Formula.Kripke.ValidOnModel M p := iff_of_eq rfl

-- variable {ùîΩ : FrameClass W Œ±} (hTrans : ùîΩ ‚äÜ { F | Transitive F }) (hRefl : ùîΩ ‚äÜ { F | Reflexive F })
variable {M : Model Œ±} {p q r : Formula Œ±}

@[simp] protected lemma verum : M ‚äß ‚ä§ := by simp_all [ValidOnModel];

@[simp] protected lemma and‚ÇÅ : M ‚äß p ‚ãè q ‚ü∂ p := by simp_all [ValidOnModel];

@[simp] protected lemma and‚ÇÇ : M ‚äß p ‚ãè q ‚ü∂ q := by simp_all [ValidOnModel];

@[simp] protected lemma and‚ÇÉ : M ‚äß p ‚ü∂ q ‚ü∂ p ‚ãè q := by
  simp_all [ValidOnModel];
  intro w‚ÇÅ w‚ÇÇ _ hp w‚ÇÉ hw‚ÇÇ‚ÇÉ _;
  exact Satisfies.formula_hereditary hw‚ÇÇ‚ÇÉ hp;

@[simp] protected lemma or‚ÇÅ : M ‚äß p ‚ü∂ p ‚ãé q := by simp_all [ValidOnModel];

@[simp] protected lemma or‚ÇÇ : M ‚äß q ‚ü∂ p ‚ãé q := by simp_all [ValidOnModel];

@[simp] protected lemma or‚ÇÉ : M ‚äß (p ‚ü∂ r) ‚ü∂ (q ‚ü∂ r) ‚ü∂ (p ‚ãé q ‚ü∂ r) := by
  simp_all only [ValidOnModel.iff_models, ValidOnModel, Satisfies.iff_models, Satisfies.imp_def, Satisfies.or_def];
  intro w‚ÇÅ w‚ÇÇ _ hpr w‚ÇÉ hw‚ÇÇ‚ÇÉ hqr w‚ÇÑ hw‚ÇÉ‚ÇÑ hpq;
  cases hpq with
  | inl hp => exact hpr (M.Frame.Rel_trans hw‚ÇÇ‚ÇÉ hw‚ÇÉ‚ÇÑ) hp;
  | inr hq => exact hqr hw‚ÇÉ‚ÇÑ hq;

@[simp] protected lemma imply‚ÇÅ : M ‚äß p ‚ü∂ q ‚ü∂ p := by
  simp_all [ValidOnModel];
  intro w‚ÇÅ w‚ÇÇ _ hp w‚ÇÉ hw‚ÇÇ‚ÇÉ _;
  exact Satisfies.formula_hereditary hw‚ÇÇ‚ÇÉ hp;

@[simp] protected lemma imply‚ÇÇ : M ‚äß (p ‚ü∂ q ‚ü∂ r) ‚ü∂ (p ‚ü∂ q) ‚ü∂ p ‚ü∂ r := by
  simp_all only [ValidOnModel.iff_models, ValidOnModel, Satisfies.iff_models, Satisfies.imp_def];
  intro w‚ÇÅ w‚ÇÇ _ hpqr w‚ÇÉ hw‚ÇÇ‚ÇÉ hpq w‚ÇÑ hw‚ÇÉ‚ÇÑ hp;
  exact hpqr (M.Frame.Rel_trans hw‚ÇÇ‚ÇÉ hw‚ÇÉ‚ÇÑ) hp (M.Frame.Rel_refl w‚ÇÑ) (hpq hw‚ÇÉ‚ÇÑ hp);

@[simp] protected lemma mdp (hpq : M ‚äß p ‚ü∂ q) (hp : M ‚äß p) : M ‚äß q := by
  simp_all [ValidOnModel];
  intro w;
  exact hpq _ (M.Frame.Rel_refl w);

@[simp] protected lemma efq : M ‚äß Axioms.EFQ p := by simp_all [ValidOnModel];

@[simp] protected lemma neg_equiv : M ‚äß Axioms.NegEquiv p := by
  simp_all [ValidOnModel, Axioms.NegEquiv];
  intro w;
  constructor;
  . intro x _ h y rxy hyp; exact h rxy hyp;
  . intro x _ h y rxy; exact h rxy;

@[simp] protected lemma lem (hExt : Extensive M.Rel) : M ‚äß Axioms.LEM p := by
  simp_all [ValidOnModel];
  intro w;
  by_cases h : w ‚äß p
  . left; assumption;
  . right;
    intro w' hww';
    rw [‚Üê(hExt hww')];
    assumption;

end Formula.Kripke.ValidOnModel


def Formula.Kripke.ValidOnFrame (F : Frame) (p : Formula Œ±) := ‚àÄ (V : Valuation F.World Œ±), (h : _) ‚Üí (Model.mk F V h) ‚äß p

instance : Semantics (Formula Œ±) (Frame' Œ±) := ‚ü®fun F ‚Ü¶ Formula.Kripke.ValidOnFrame F‚ü©

namespace Formula.Kripke.ValidOnFrame

@[simp] protected lemma models_iff {F : Frame' Œ±} : F ‚äß f ‚Üî ValidOnFrame F f := iff_of_eq rfl


variable {F : Frame' Œ±} {p q r : Formula Œ±}

@[simp] protected lemma verum : F ‚äß ‚ä§ := by
  simp_all only [ValidOnFrame.models_iff, ValidOnFrame, ValidOnModel.iff_models];
  intros; apply ValidOnModel.verum;

@[simp] protected lemma and‚ÇÅ : F ‚äß p ‚ãè q ‚ü∂ p := by
  simp_all only [ValidOnFrame.models_iff, ValidOnFrame, ValidOnModel.iff_models];
  intros; apply ValidOnModel.and‚ÇÅ;

@[simp] protected lemma and‚ÇÇ : F ‚äß p ‚ãè q ‚ü∂ q := by
  simp_all only [ValidOnFrame.models_iff, ValidOnFrame, ValidOnModel.iff_models];
  intros; apply ValidOnModel.and‚ÇÇ;

@[simp] protected lemma and‚ÇÉ : F ‚äß p ‚ü∂ q ‚ü∂ p ‚ãè q := by
  simp_all only [ValidOnFrame.models_iff, ValidOnFrame, ValidOnModel.iff_models];
  intros; apply ValidOnModel.and‚ÇÉ;

@[simp] protected lemma or‚ÇÅ : F ‚äß p ‚ü∂ p ‚ãé q := by
  simp_all only [ValidOnFrame.models_iff, ValidOnFrame, ValidOnModel.iff_models];
  intros; apply ValidOnModel.or‚ÇÅ;

@[simp] protected lemma or‚ÇÇ : F ‚äß q ‚ü∂ p ‚ãé q := by
  simp_all only [ValidOnFrame.models_iff, ValidOnFrame, ValidOnModel.iff_models];
  intros; apply ValidOnModel.or‚ÇÇ;

@[simp] protected lemma or‚ÇÉ : F ‚äß (p ‚ü∂ r) ‚ü∂ (q ‚ü∂ r) ‚ü∂ (p ‚ãé q ‚ü∂ r) := by
  simp_all only [ValidOnFrame.models_iff, ValidOnFrame, ValidOnModel.iff_models];
  intros; apply ValidOnModel.or‚ÇÉ;

@[simp] protected lemma imply‚ÇÅ : F ‚äß p ‚ü∂ q ‚ü∂ p := by
  simp_all only [ValidOnFrame.models_iff, ValidOnFrame, ValidOnModel.iff_models];
  intros; apply ValidOnModel.imply‚ÇÅ;

@[simp] protected lemma imply‚ÇÇ : F ‚äß (p ‚ü∂ q ‚ü∂ r) ‚ü∂ (p ‚ü∂ q) ‚ü∂ p ‚ü∂ r := by
  simp_all only [ValidOnFrame.models_iff, ValidOnFrame, ValidOnModel.iff_models];
  intros; apply ValidOnModel.imply‚ÇÇ;

@[simp] protected lemma mdp (hpq : F ‚äß p ‚ü∂ q) (hp : F ‚äß p) : F ‚äß q := by
  simp_all only [ValidOnFrame.models_iff, ValidOnFrame, ValidOnModel.iff_models];
  intros V hV;
  exact ValidOnModel.mdp (hpq V hV) (hp V hV);

@[simp] protected lemma efq : F ‚äß Axioms.EFQ p := by
  simp_all only [ValidOnFrame.models_iff, ValidOnFrame, ValidOnModel.iff_models];
  intros; apply ValidOnModel.efq;

@[simp] protected lemma neg_equiv : F ‚äß Axioms.NegEquiv p := by
  simp_all only [ValidOnFrame.models_iff, ValidOnFrame, ValidOnModel.iff_models];
  intros; apply ValidOnModel.neg_equiv;

@[simp] protected lemma lem (hExt : Extensive F.Rel) : F ‚äß Axioms.LEM p := by
  simp_all only [ValidOnFrame.models_iff, ValidOnFrame, ValidOnModel.iff_models];
  intros; exact ValidOnModel.lem hExt;

instance : Semantics.Bot (Frame' Œ±) where
  realize_bot _ := by
    simp [ValidOnModel, ValidOnFrame];
    existsi (Œª _ _ => True);
    simp_all;

end Formula.Kripke.ValidOnFrame


@[simp] def Formula.Kripke.ValidOnFrameClass (ùîΩ : FrameClass) (p : Formula Œ±) := ‚àÄ {F : Frame' Œ±}, F ‚àà ùîΩ ‚Üí F ‚äß p

instance : Semantics (Formula Œ±) (FrameClass' Œ±) := ‚ü®fun ùîΩ ‚Ü¶ Formula.Kripke.ValidOnFrameClass ùîΩ‚ü©

namespace Formula.Kripke.ValidOnFrameClass

@[simp] protected lemma iff_models {ùîΩ : FrameClass' Œ±} : ùîΩ ‚äß p ‚Üî Formula.Kripke.ValidOnFrameClass ùîΩ p := iff_of_eq rfl

end Formula.Kripke.ValidOnFrameClass

@[simp] def Formula.Kripke.ValidOnFiniteFrameClass (ùîΩ : FiniteFrameClass) (f : Formula Œ±) := ‚àÄ (F : FiniteFrame' Œ±), F ‚àà ùîΩ ‚Üí F.toFrame' ‚äß f

instance : Semantics (Formula Œ±) (FiniteFrameClass' Œ±) := ‚ü®fun ùîΩ ‚Ü¶ Formula.Kripke.ValidOnFiniteFrameClass ùîΩ‚ü©

namespace Formula.Kripke.ValidOnFiniteFrameClass

@[simp] protected lemma models_iff {ùîΩ : FiniteFrameClass' Œ±} : ùîΩ ‚äß f ‚Üî Formula.Kripke.ValidOnFiniteFrameClass ùîΩ f := iff_of_eq rfl

end Formula.Kripke.ValidOnFiniteFrameClass


namespace Kripke

def AxiomSetFrameClass (Ax : AxiomSet Œ±) : FrameClass' Œ± := { (F : Frame' Œ±) | F ‚äß* Ax }
notation "ùîΩ(" Ax ")" => Kripke.AxiomSetFrameClass Ax

def AxiomSetFiniteFrameClass (Ax : AxiomSet Œ±) : FiniteFrameClass' Œ± := { (F : FiniteFrame' Œ±) | F.toFrame' ‚äß* Ax }
notation "ùîΩÍü≥(" Ax ")" => Kripke.AxiomSetFiniteFrameClass Ax

variable {Ax : AxiomSet Œ±}

lemma validOnAxiomSetFrameClass_axiom (h : p ‚àà Ax) : ùîΩ(Ax) ‚äß p := by intro F hF; exact hF.realize h;

class Definability (Ax : AxiomSet Œ±) (P : FrameProperty) where
  defines : ‚àÄ (F : Frame' Œ±), F ‚äß* Ax ‚Üî P F

instance Definability.instUnion (definability‚ÇÅ : Definability Ax‚ÇÅ P‚ÇÅ) (definability‚ÇÇ : Definability Ax‚ÇÇ P‚ÇÇ) : Definability (Ax‚ÇÅ ‚à™ Ax‚ÇÇ) (Œª F => P‚ÇÅ F ‚àß P‚ÇÇ F) where
  defines F := by
    constructor;
    . intro h;
      simp only [Semantics.RealizeSet.union_iff] at h;
      constructor;
      . exact Definability.defines F |>.mp h.1;
      . exact Definability.defines F |>.mp h.2;
    . intro h;
      simp only [Semantics.RealizeSet.union_iff];
      constructor;
      . apply Definability.defines F |>.mpr h.1;
      . apply Definability.defines F |>.mpr h.2;

lemma iff_definability_memAxiomSetFrameClass (definability : Definability Ax P) : ‚àÄ {F : Frame' Œ±}, F ‚àà ùîΩ(Ax) ‚Üî P F := by
  apply Definability.defines;

class FiniteDefinability (Ax : AxiomSet Œ±) (P : FiniteFrameProperty) where
  defines : ‚àÄ (F : FiniteFrame' Œ±), F.toFrame' ‚äß* Ax ‚Üî P F

lemma iff_definability_memAxiomSetFiniteFrameClass (definability : FiniteDefinability Ax P) : ‚àÄ {F : FiniteFrame' Œ±}, F ‚àà ùîΩÍü≥(Ax) ‚Üî P F := by
  apply definability.defines;

end Kripke

instance AxiomSet.EFQ.definability : Definability (Œ± := Œ±) ùóòùóôùó§ (Œª _ => True) where
  defines F := by simp; intros; apply ValidOnFrame.efq

instance AxiomSet.EFQ.nonempty : FrameClass.IsNonempty (ùîΩ(ùóòùóôùó§) : FrameClass' Œ±) where
  nonempty := by
    existsi { World := PUnit, Rel := Œª x y => x ‚â§ y };
    apply iff_definability_memAxiomSetFrameClass AxiomSet.EFQ.definability |>.mpr;
    trivial;

instance AxiomSet.EFQ.instDefinabilityUnion (definability : Definability Ax P) : Definability (ùóòùóôùó§ ‚à™ Ax) P := by simpa using Definability.instUnion AxiomSet.EFQ.definability definability;

instance AxiomSet.EFQ.instUnionNonempty [FrameClass.IsNonempty ùîΩ(Ax)] (definability : Definability Ax P) : FrameClass.IsNonempty (ùîΩ(ùóòùóôùó§ ‚à™ Ax) : FrameClass' Œ±) where
  nonempty := by
    obtain ‚ü®F, hF‚ü© := FrameClass.IsNonempty.nonempty (ùîΩ := ùîΩ(Ax));
    existsi F;
    apply iff_definability_memAxiomSetFrameClass (AxiomSet.EFQ.instDefinabilityUnion definability) |>.mpr;
    apply iff_definability_memAxiomSetFrameClass definability |>.mp hF;

end LO.Propositional.Superintuitionistic
