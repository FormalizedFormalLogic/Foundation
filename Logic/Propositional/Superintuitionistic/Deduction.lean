/-
import Logic.Logic.System
import Logic.Propositional.Superintuitionistic.Formula
import Logic.Propositional.Superintuitionistic.Axioms

namespace LO.Propositional.Superintuitionistic

variable {Œ± : Type u} [DecidableEq Œ±]

inductive Deduction (Œõ : AxiomSet Œ±) : Theory Œ± ‚Üí Formula Œ± ‚Üí Type _
  | axm {Œì p}        : p ‚àà Œì ‚Üí Deduction Œõ Œì p
  | eaxm {Œì p}       : p ‚àà Œõ ‚Üí Deduction Œõ Œì p
  | mdp {Œì p q} : Deduction Œõ Œì (p ‚ü∂ q) ‚Üí Deduction Œõ Œì p ‚Üí Deduction Œõ Œì q
  | verum Œì          : Deduction Œõ Œì ‚ä§
  | imply‚ÇÅ Œì p q     : Deduction Œõ Œì (p ‚ü∂ q ‚ü∂ p)
  | imply‚ÇÇ Œì p q r   : Deduction Œõ Œì ((p ‚ü∂ q ‚ü∂ r) ‚ü∂ (p ‚ü∂ q) ‚ü∂ p ‚ü∂ r)
  | conj‚ÇÅ Œì p q      : Deduction Œõ Œì (p ‚ãè q ‚ü∂ p)
  | conj‚ÇÇ Œì p q      : Deduction Œõ Œì (p ‚ãè q ‚ü∂ q)
  | conj‚ÇÉ Œì p q      : Deduction Œõ Œì (p ‚ü∂ q ‚ü∂ p ‚ãè q)
  | disj‚ÇÅ Œì p q      : Deduction Œõ Œì (p ‚ü∂ p ‚ãé q)
  | disj‚ÇÇ Œì p q      : Deduction Œõ Œì (q ‚ü∂ p ‚ãé q)
  | disj‚ÇÉ Œì p q r    : Deduction Œõ Œì ((p ‚ü∂ r) ‚ü∂ (q ‚ü∂ r) ‚ü∂ (p ‚ãé q ‚ü∂ r))
  -- | efq Œì p          : Deduction Œõ Œì (‚ä• ‚ü∂ p)

notation:45 Œì " ‚ä¢·¥æ[" Œõ "] " p => Deduction Œõ Œì p

variable (Œõ : AxiomSet Œ±) (Œì : Theory Œ±) (p : Formula Œ±)

abbrev Deducible := Nonempty (Œì ‚ä¢·¥æ[Œõ] p)
notation:45 Œì " ‚ä¢·¥æ[" Œõ "]! " p => Deducible Œõ Œì p

abbrev Undeducible := ¬¨(Œì ‚ä¢·¥æ[Œõ]! p)
notation:45 Œì " ‚ä¨·¥æ[" Œõ "]! " p => Undeducible Œõ Œì p

abbrev Theory.Consistent := Œì ‚ä¨·¥æ[Œõ]! ‚ä•

abbrev Theory.Inconsistent := Œì ‚ä¢·¥æ[Œõ]! ‚ä•

/-
infix:45 " ‚ä¢‚Å±! " => Deducible

abbrev Undeducible := Hilbert.Undeducible (@Deduction Œ±)
infix:45 " ‚ä¨‚Å±! " => Undeducible

abbrev Theory.Consistent := Hilbert.Consistent (@Deduction Œ±) Œì
abbrev Theory.Inconsistent := Hilbert.Inconsistent (@Deduction Œ±) Œì
-/

namespace Deduction

open Hilbert

variable {Œõ : AxiomSet Œ±} {Œì : Theory Œ±} {p q : Formula Œ±}

def weakening' {Œì Œî} {p : Formula Œ±} (hs : Œì ‚äÜ Œî) : Deduction Œõ Œì p ‚Üí Deduction Œõ Œî p
  | axm h => axm (hs h)
  | eaxm h => eaxm h
  | mdp h‚ÇÅ h‚ÇÇ => by
      -- simp [Finset.union_subset_iff] at hs;
      simpa using (h‚ÇÅ.weakening' hs).mdp (h‚ÇÇ.weakening' hs);
  | verum _ => by apply verum
  | imply‚ÇÅ _ _ _ => by apply imply‚ÇÅ
  | imply‚ÇÇ _ _ _ _ => by apply imply‚ÇÇ
  | conj‚ÇÅ _ _ _ => by apply conj‚ÇÅ
  | conj‚ÇÇ _ _ _ => by apply conj‚ÇÇ
  | conj‚ÇÉ _ _ _ => by apply conj‚ÇÉ
  | disj‚ÇÅ _ _ _ => by apply disj‚ÇÅ
  | disj‚ÇÇ _ _ _ => by apply disj‚ÇÇ
  | disj‚ÇÉ _ _ _ _ => by apply disj‚ÇÉ

instance : Hilbert.Minimal (¬∑ ‚ä¢·¥æ[Œõ] ¬∑ : Theory Œ± ‚Üí Formula Œ± ‚Üí Type _) where
  axm          := axm;
  weakening'   := weakening';
  modus_ponens h‚ÇÅ h‚ÇÇ := by
    rename_i Œì‚ÇÅ Œì‚ÇÇ p q
    replace h‚ÇÅ : (Œì‚ÇÅ ‚à™ Œì‚ÇÇ) ‚ä¢·¥æ[Œõ] p ‚ü∂ q := h‚ÇÅ.weakening' (by simp);
    replace h‚ÇÇ : (Œì‚ÇÅ ‚à™ Œì‚ÇÇ) ‚ä¢·¥æ[Œõ] p := h‚ÇÇ.weakening' (by simp);
    exact modusPonens h‚ÇÅ h‚ÇÇ;
  verum        := verum;
  imply‚ÇÅ       := imply‚ÇÅ;
  imply‚ÇÇ       := imply‚ÇÇ;
  conj‚ÇÅ        := conj‚ÇÅ;
  conj‚ÇÇ        := conj‚ÇÇ;
  conj‚ÇÉ        := conj‚ÇÉ;
  disj‚ÇÅ        := disj‚ÇÅ;
  disj‚ÇÇ        := disj‚ÇÇ;
  disj‚ÇÉ        := disj‚ÇÉ;

private def dtrAux (Œì : Theory Œ±) (p q : Formula Œ±) : (Œì ‚ä¢·¥æ[Œõ] q) ‚Üí (Œì \ {p} ‚ä¢·¥æ[Œõ] p ‚ü∂ q)
  | verum _         => (imply‚ÇÅ _ _ _) ‚®Ä (verum _)
  | imply‚ÇÅ _ _ _    => (imply‚ÇÅ _ _ _) ‚®Ä (imply‚ÇÅ _ _ _)
  | imply‚ÇÇ _ _ _ _  => (imply‚ÇÅ _ _ _) ‚®Ä (imply‚ÇÇ _ _ _ _)
  | conj‚ÇÅ _ _ _     => (imply‚ÇÅ _ _ _) ‚®Ä (conj‚ÇÅ _ _ _)
  | conj‚ÇÇ _ _ _     => (imply‚ÇÅ _ _ _) ‚®Ä (conj‚ÇÇ _ _ _)
  | conj‚ÇÉ _ _ _     => (imply‚ÇÅ _ _ _) ‚®Ä (conj‚ÇÉ _ _ _)
  | disj‚ÇÅ _ _ _     => (imply‚ÇÅ _ _ _) ‚®Ä (disj‚ÇÅ _ _ _)
  | disj‚ÇÇ _ _ _     => (imply‚ÇÅ _ _ _) ‚®Ä (disj‚ÇÇ _ _ _)
  | disj‚ÇÉ _ _ _ _   => (imply‚ÇÅ _ _ _) ‚®Ä (disj‚ÇÉ _ _ _ _)
  | @eaxm _ _ Œì q ih => (imply‚ÇÅ _ _ _) ‚®Ä (eaxm (by assumption))
  | @axm _ _ Œì q ih => by
    by_cases h : p = q
    case pos => deduct
    case neg =>
      have d‚ÇÅ : (Œì \ {p}) ‚ä¢·¥æ[Œõ] (q ‚ü∂ p ‚ü∂ q) := imply‚ÇÅ _ q p
      have d‚ÇÇ : (Œì \ {p}) ‚ä¢·¥æ[Œõ] q := axm (Set.mem_diff_singleton.mpr ‚ü®ih, Ne.symm h‚ü©)
      exact d‚ÇÅ ‚®Ä d‚ÇÇ;
  | @modusPonens _ _ Œì a b h‚ÇÅ h‚ÇÇ =>
      have ih‚ÇÅ : Œì \ {p} ‚ä¢·¥æ[Œõ] p ‚ü∂ a ‚ü∂ b := dtrAux Œì p (a ‚ü∂ b) h‚ÇÅ
      have ih‚ÇÇ : Œì \ {p} ‚ä¢·¥æ[Œõ] p ‚ü∂ a := dtrAux Œì p a h‚ÇÇ
      have d‚ÇÅ : Œì \ {p} ‚ä¢·¥æ[Œõ] (p ‚ü∂ a) ‚ü∂ p ‚ü∂ b := Hilbert.imply‚ÇÇ ‚®Ä ih‚ÇÅ;
      have d‚ÇÇ : (Œì) \ {p} ‚ä¢·¥æ[Œõ] (p ‚ü∂ a) := ih‚ÇÇ.weakening' (by simp)
      d‚ÇÅ ‚®Ä d‚ÇÇ

def dtr {Œì : Theory Œ±} {p q} (d : (insert p Œì) ‚ä¢·¥æ[Œõ] q) : (Œì ‚ä¢·¥æ[Œõ](p ‚ü∂ q)) := by
  exact dtrAux (insert p Œì) p q d |> LO.Deduction.weakening' (by simp)

instance : Hilbert.HasDT (¬∑ ‚ä¢·¥æ[Œõ] ¬∑ : Theory Œ± ‚Üí Formula Œ± ‚Üí Type _) := ‚ü®dtr‚ü©

def compact {Œì : Theory Œ±} {p : Formula Œ±} : (Œì ‚ä¢·¥æ[Œõ] p) ‚Üí (Œî : { Œî : Context Œ± | ‚ÜëŒî ‚äÜ Œì}) √ó Œî ‚ä¢·¥æ[Œõ] p
  | @axm _ _ Œì p h  => ‚ü®‚ü®{p}, by simpa‚ü©, axm (by simp)‚ü©
  | @eaxm _ _ Œì q ih => ‚ü®‚ü®‚àÖ, by simp‚ü©, eaxm (by assumption)‚ü©
  | @mdp _ _ Œì p q h‚ÇÅ h‚ÇÇ => by
      have ‚ü®‚ü®Œî‚ÇÅ, hs‚ÇÅ‚ü©, d‚ÇÅ‚ü© := compact h‚ÇÅ
      have ‚ü®‚ü®Œî‚ÇÇ, hs‚ÇÇ‚ü©, d‚ÇÇ‚ü© := compact h‚ÇÇ
      simp at hs‚ÇÅ d‚ÇÅ hs‚ÇÇ d‚ÇÇ;
      exact ‚ü®
        ‚ü®Œî‚ÇÅ ‚à™ Œî‚ÇÇ, by simp [hs‚ÇÅ, hs‚ÇÇ, Set.subset_union_of_subset_left, Set.subset_union_of_subset_right];‚ü©,
        by simpa using modus_ponens‚ÇÇ' (LO.Deduction.weakening' (by simp) d‚ÇÅ) (LO.Deduction.weakening' (by simp) d‚ÇÇ)
      ‚ü©
  | verum _         => ‚ü®‚ü®‚àÖ, by simp‚ü©, verum _‚ü©
  | imply‚ÇÅ _ _ _    => ‚ü®‚ü®‚àÖ, by simp‚ü©, imply‚ÇÅ _ _ _‚ü©
  | imply‚ÇÇ _ _ _ _  => ‚ü®‚ü®‚àÖ, by simp‚ü©, imply‚ÇÇ _ _ _ _‚ü©
  | conj‚ÇÅ _ _ _     => ‚ü®‚ü®‚àÖ, by simp‚ü©, conj‚ÇÅ _ _ _‚ü©
  | conj‚ÇÇ _ _ _     => ‚ü®‚ü®‚àÖ, by simp‚ü©, conj‚ÇÇ _ _ _‚ü©
  | conj‚ÇÉ _ _ _     => ‚ü®‚ü®‚àÖ, by simp‚ü©, conj‚ÇÉ _ _ _‚ü©
  | disj‚ÇÅ _ _ _     => ‚ü®‚ü®‚àÖ, by simp‚ü©, disj‚ÇÅ _ _ _‚ü©
  | disj‚ÇÇ _ _ _     => ‚ü®‚ü®‚àÖ, by simp‚ü©, disj‚ÇÇ _ _ _‚ü©
  | disj‚ÇÉ _ _ _ _   => ‚ü®‚ü®‚àÖ, by simp‚ü©, disj‚ÇÉ _ _ _ _‚ü©

end Deduction

def AxiomSet.Disjunctive (Œõ : AxiomSet Œ±) := ‚àÄ {p q}, (‚àÖ ‚ä¢·¥æ[Œõ]! p ‚ãé q) ‚Üí (‚àÖ ‚ä¢·¥æ[Œõ]! p) ‚à® (‚àÖ ‚ä¢·¥æ[Œõ]! q)

end LO.Propositional.Superintuitionistic
-/

/-
import Logic.Propositional.Superintuitionistic.Deduction
import Logic.Propositional.Superintuitionistic.Classical.Deduction

namespace LO.Propositional.Superintuitionistic

open Hilbert Deduction

variable {Œ±} [DecidableEq Œ±]

infix:45 " ‚ä¢‚Å± " => Deduction ùêÑùêÖùêê
infix:45 " ‚ä¢‚Å±! " => Deducible ùêÑùêÖùêê
infix:45 " ‚ä¨‚Å±! " => Undeducible ùêÑùêÖùêê

instance : Hilbert.Intuitionistic (¬∑ ‚ä¢‚Å± ¬∑ : Theory Œ± ‚Üí Formula Œ± ‚Üí Type _) where
  axm          := axm;
  weakening'   := Deduction.weakening';
  modus_ponens h‚ÇÅ h‚ÇÇ := by
    rename_i Œì‚ÇÅ Œì‚ÇÇ p q
    replace h‚ÇÅ : (Œì‚ÇÅ ‚à™ Œì‚ÇÇ) ‚ä¢‚Å± p ‚ü∂ q := h‚ÇÅ.weakening' (by simp);
    replace h‚ÇÇ : (Œì‚ÇÅ ‚à™ Œì‚ÇÇ) ‚ä¢‚Å± p := h‚ÇÇ.weakening' (by simp);
    exact modusPonens h‚ÇÅ h‚ÇÇ;
  verum        := verum;
  imply‚ÇÅ       := imply‚ÇÅ;
  imply‚ÇÇ       := imply‚ÇÇ;
  conj‚ÇÅ        := conj‚ÇÅ;
  conj‚ÇÇ        := conj‚ÇÇ;
  conj‚ÇÉ        := conj‚ÇÉ;
  disj‚ÇÅ        := disj‚ÇÅ;
  disj‚ÇÇ        := disj‚ÇÇ;
  disj‚ÇÉ        := disj‚ÇÉ;
  efq Œì p      := eaxm (by simp);

namespace Deduction

variable {Œì : Theory Œ±} {p : Formula Œ±}

theorem deducible_Classical_of_Int (d : Œì ‚ä¢‚Å±! p) : (Œì ‚ä¢·∂ú! p) := by
  induction d.some with
  | axm => apply axm! (by assumption)
  | eaxm ih =>
    obtain ‚ü®q, hq‚ü© := ih;
    subst hq;
    apply efq!;
  | modusPonens h‚ÇÅ h‚ÇÇ ih‚ÇÅ ih‚ÇÇ => exact (ih‚ÇÅ ‚ü®h‚ÇÅ‚ü©) ‚®Ä (ih‚ÇÇ ‚ü®h‚ÇÇ‚ü©)
  | _ =>
    try first
    | apply verum!
    | apply imply‚ÇÅ!
    | apply imply‚ÇÇ!
    | apply conj‚ÇÅ!
    | apply conj‚ÇÇ!
    | apply conj‚ÇÉ!
    | apply disj‚ÇÅ!
    | apply disj‚ÇÇ!
    | apply disj‚ÇÉ!

/-- a.k.a. Glivenko's Theorem -/
theorem deducible_dn_iff_Int_Classical : (Œì ‚ä¢‚Å±! ~~p) ‚Üî (Œì ‚ä¢·∂ú! p) := by
  constructor;
  . intro d;
    exact dne'! $ deducible_Classical_of_Int d;
  . intro d;
    induction d.some with
    | axm h => exact dni'! $ axm! h;
    | @modusPonens p q h‚ÇÅ h‚ÇÇ ih‚ÇÅ ih‚ÇÇ =>
      have : Œì ‚ä¢‚Å±! ~~p ‚ü∂ ~~q := dn_distribute_imp_left'! $ ih‚ÇÅ ‚ü®h‚ÇÅ‚ü©;
      exact (by assumption) ‚®Ä ih‚ÇÇ ‚ü®h‚ÇÇ‚ü©;
    | eaxm ih =>
      obtain ‚ü®q, hq‚ü© := ih;
      subst hq;
      exact dn_disctribute_imp_right'! $ contra‚ÇÄ'! $ dni!;
    | _ =>
      apply dni'!;
      try first
      | apply verum!
      | apply imply‚ÇÅ!
      | apply imply‚ÇÇ!
      | apply conj‚ÇÅ!
      | apply conj‚ÇÇ!
      | apply conj‚ÇÉ!
      | apply disj‚ÇÅ!
      | apply disj‚ÇÇ!
      | apply disj‚ÇÉ!

alias glivenko := deducible_dn_iff_Int_Classical

theorem deducible_neg_iff_Int_Classical : (Œì ‚ä¢‚Å±! ~p) ‚Üî (Œì ‚ä¢·∂ú! ~p) := by
  constructor;
  . intro d; exact glivenko.mp $ dni'! d;
  . intro d; exact tne'! $ glivenko.mpr d;

end Deduction

end LO.Propositional.Superintuitionistic
-/

import Logic.Logic.HilbertStyle.Basic
import Logic.Logic.HilbertStyle.Supplemental
import Logic.Propositional.Superintuitionistic.Formula
import Logic.Propositional.Superintuitionistic.Axioms

namespace LO.Propositional.Superintuitionistic

variable {Œ± : Type u} [DecidableEq Œ±]

inductive Deduction (Œõ : AxiomSet Œ±) : Formula Œ± ‚Üí Type _
  | eaxm {p}       : p ‚àà Œõ ‚Üí Deduction Œõ p
  | mdp {p q} : Deduction Œõ (p ‚ü∂ q) ‚Üí Deduction Œõ p ‚Üí Deduction Œõ q
  | verum          : Deduction Œõ $ ‚ä§
  | imply‚ÇÅ p q     : Deduction Œõ $ p ‚ü∂ q ‚ü∂ p
  | imply‚ÇÇ p q r   : Deduction Œõ $ (p ‚ü∂ q ‚ü∂ r) ‚ü∂ (p ‚ü∂ q) ‚ü∂ p ‚ü∂ r
  | conj‚ÇÅ p q      : Deduction Œõ $ p ‚ãè q ‚ü∂ p
  | conj‚ÇÇ p q      : Deduction Œõ $ p ‚ãè q ‚ü∂ q
  | conj‚ÇÉ p q      : Deduction Œõ $ p ‚ü∂ q ‚ü∂ p ‚ãè q
  | disj‚ÇÅ p q      : Deduction Œõ $ p ‚ü∂ p ‚ãé q
  | disj‚ÇÇ p q      : Deduction Œõ $ q ‚ü∂ p ‚ãé q
  | disj‚ÇÉ p q r    : Deduction Œõ $ (p ‚ü∂ r) ‚ü∂ (q ‚ü∂ r) ‚ü∂ (p ‚ãé q ‚ü∂ r)

instance : System (Formula Œ±) (AxiomSet Œ±) := ‚ü®Deduction‚ü©

open Deduction

instance : System.Minimal (Œõ : AxiomSet Œ±) where
  mdp := mdp
  verum := verum
  imply‚ÇÅ := imply‚ÇÅ
  imply‚ÇÇ := imply‚ÇÇ
  conj‚ÇÅ := conj‚ÇÅ
  conj‚ÇÇ := conj‚ÇÇ
  conj‚ÇÉ := conj‚ÇÉ
  disj‚ÇÅ := disj‚ÇÅ
  disj‚ÇÇ := disj‚ÇÇ
  disj‚ÇÉ := disj‚ÇÉ

instance intuitionistic_of_subset_efq (hEFQ : ùêÑùêÖùêê ‚äÜ Œõ := by assumption) : System.Intuitionistic (Œõ : AxiomSet Œ±) where
  efq _ := eaxm $ Set.mem_of_subset_of_mem hEFQ (by simp);

instance : System.Intuitionistic (ùêÑùêÖùêê : AxiomSet Œ±) := intuitionistic_of_subset_efq (by rfl)


instance classical_of_subset_dne (hDNE : ùêÉùêçùêÑ ‚äÜ Œõ := by assumption) : System.Classical (Œõ : AxiomSet Œ±) where
  dne _ := eaxm $ Set.mem_of_subset_of_mem hDNE (by simp);

instance : System.Classical (ùêÉùêçùêÑ : AxiomSet Œ±) := classical_of_subset_dne (by rfl)


open System

lemma reducible_efq_dne : (ùêÑùêÖùêê : AxiomSet Œ±) ‚â§‚Çõ ùêÉùêçùêÑ := by
  rintro p hp;
  simp [System.theory];
  induction hp.some with
  | eaxm h =>
    obtain ‚ü®q, hq‚ü© := by simpa [axiomEFQ] using h;
    subst hq;
    apply efq!;
  | mdp h‚ÇÅ h‚ÇÇ ih‚ÇÅ ih‚ÇÇ => exact (ih‚ÇÅ ‚ü®h‚ÇÅ‚ü©) ‚®Ä (ih‚ÇÇ ‚ü®h‚ÇÇ‚ü©);
  | _ => simp;

variable {p : Formula Œ±}

theorem iff_provable_dn_efq_dne_provable: (ùêÑùêÖùêê ‚ä¢! ~~p) ‚Üî (ùêÉùêçùêÑ ‚ä¢! p) := by
  constructor;
  . intro d; exact dne'! $ reducible_efq_dne d;
  . intro d;
    induction d.some with
    | eaxm h =>
      obtain ‚ü®q, hq‚ü© := by simpa [axiomDNE] using h;
      subst hq;
      sorry;
    | @mdp p q h‚ÇÅ h‚ÇÇ ih‚ÇÅ ih‚ÇÇ =>
      have : ùêÑùêÖùêê ‚ä¢! ~~p ‚ü∂ ~~q := by sorry;
      exact (by assumption) ‚®Ä ih‚ÇÇ ‚ü®h‚ÇÇ‚ü©;
    | _ => apply dni'!; simp;

alias glivenko := iff_provable_dn_efq_dne_provable

theorem iff_provable_neg_efq_provable_neg_efq : (ùêÑùêÖùêê ‚ä¢! ~p) ‚Üî (ùêÉùêçùêÑ ‚ä¢! ~p) := by
  constructor;
  . intro d; exact glivenko.mp $ dni'! d;
  . intro d; exact tne'! $ glivenko.mpr d;

end LO.Propositional.Superintuitionistic
