import Arithmetization.ISigmaOne.HFS.Fixpoint

/-!

# Vec

-/

noncomputable section

namespace LO.Arith

open FirstOrder FirstOrder.Arith

variable {V : Type*} [ORingStruc V] [V ‚äß‚Çò* ùêàùö∫‚ÇÅ]

section cons

instance : Cons V V := ‚ü®(‚ü™¬∑, ¬∑‚ü´ + 1)‚ü©

scoped infixr:67 " ‚à∑ " => cons

syntax "?[" term,* "]" : term

macro_rules
  | `(?[$term:term, $terms:term,*]) => `(cons $term ?[$terms,*])
  | `(?[$term:term]) => `(cons $term 0)
  | `(?[]) => `(0)

@[app_unexpander Cons.cons]
def consUnexpander : Lean.PrettyPrinter.Unexpander
  | `($_ $term ?[$terms,*]) => `(?[$term, $terms,*])
  | `($_ $term 0) => `(?[$term])
  | _ => throw ()

lemma cons_def (x v : V) : x ‚à∑ v = ‚ü™x, v‚ü´ + 1 := rfl

@[simp] lemma fstIdx_cons (x v : V) : fstIdx (x ‚à∑ v) = x := by simp [cons_def, fstIdx]

@[simp] lemma sndIdx_cons (x v : V) : sndIdx (x ‚à∑ v) = v := by simp [cons_def, sndIdx]

lemma succ_eq_cons (x : V) : x + 1 = œÄ‚ÇÅ x ‚à∑ œÄ‚ÇÇ x := by simp [cons_def]

@[simp] lemma lt_cons (x v : V) : x < x ‚à∑ v := by simp [cons_def, lt_succ_iff_le]

@[simp] lemma lt_cons' (x v : V) : v < x ‚à∑ v := by simp [cons_def, lt_succ_iff_le]

@[simp] lemma zero_lt_cons (x v : V) : 0 < x ‚à∑ v := by simp [cons_def]

@[simp] lemma cons_ne_zero (x v : V) : x ‚à∑ v ‚â† 0 := by simp [cons_def]

@[simp] lemma zero_ne_cons (x v : V) : 0 ‚â† x ‚à∑ v := by symm; simp [cons_def]

lemma nil_or_cons (z : V) : z = 0 ‚à® ‚àÉ x v, z = x ‚à∑ v := by
  rcases zero_or_succ z with (rfl | ‚ü®z, rfl‚ü©)
  ¬∑ left; rfl
  ¬∑ right; exact ‚ü®œÄ‚ÇÅ z, œÄ‚ÇÇ z, by simp [succ_eq_cons]‚ü©

@[simp] lemma cons_inj (x‚ÇÅ x‚ÇÇ v‚ÇÅ v‚ÇÇ : V) :
    x‚ÇÅ ‚à∑ v‚ÇÅ = x‚ÇÇ ‚à∑ v‚ÇÇ ‚Üî x‚ÇÅ = x‚ÇÇ ‚àß v‚ÇÅ = v‚ÇÇ := by simp [cons_def]

lemma cons_le_cons {x‚ÇÅ x‚ÇÇ v‚ÇÅ v‚ÇÇ : V} (hx : x‚ÇÅ ‚â§ x‚ÇÇ) (hv : v‚ÇÅ ‚â§ v‚ÇÇ) :
    x‚ÇÅ ‚à∑ v‚ÇÅ ‚â§ x‚ÇÇ ‚à∑ v‚ÇÇ := by simpa [cons_def] using pair_le_pair hx hv

section

def _root_.LO.FirstOrder.Arith.consDef : ùö∫‚ÇÄ.Semisentence 3 :=
  .mkSigma ‚Äúw x v. ‚àÉ xv < w, !pairDef xv x v ‚àß w = xv + 1‚Äù (by simp)

lemma cons_defined : ùö∫‚ÇÄ-Function‚ÇÇ (cons : V ‚Üí V ‚Üí V) via consDef := by
  intro v; simp [consDef]
  constructor
  ¬∑ intro h; rw [h]; exact ‚ü®_, by simp [cons_def], rfl, rfl‚ü©
  ¬∑ intro ‚ü®_, _, rfl, h‚ü©; exact h

@[simp] lemma eval_cons (v) :
    Semiformula.Evalbm V v consDef.val ‚Üî v 0 = v 1 ‚à∑ v 2 := cons_defined.df.iff v

instance cons_definable : ùö∫‚ÇÄ-Function‚ÇÇ (cons : V ‚Üí V ‚Üí V) := cons_defined.to_definable

instance cons_definable' (‚Ñå) : ‚Ñå-Function‚ÇÇ (cons : V ‚Üí V ‚Üí V) := cons_definable.of_zero

def _root_.LO.FirstOrder.Arith.mkVec‚ÇÅDef : ùö∫‚ÇÄ.Semisentence 2 := .mkSigma
  ‚Äús x. !consDef s x 0‚Äù (by simp)

lemma mkVec‚ÇÅ_defined : ùö∫‚ÇÄ-Function‚ÇÅ (fun x : V ‚Ü¶ ?[x]) via mkVec‚ÇÅDef := by
  intro v; simp [mkVec‚ÇÅDef]

@[simp] lemma eval_mkVec‚ÇÅDef (v) :
    Semiformula.Evalbm V v mkVec‚ÇÅDef.val ‚Üî v 0 = ?[v 1] := mkVec‚ÇÅ_defined.df.iff v

instance mkVec‚ÇÅ_definable : ùö∫‚ÇÄ-Function‚ÇÅ (fun x : V ‚Ü¶ ?[x]) := mkVec‚ÇÅ_defined.to_definable

instance mkVec‚ÇÅ_definable' (‚Ñå) : ‚Ñå-Function‚ÇÅ (fun x : V ‚Ü¶ ?[x]) := mkVec‚ÇÅ_definable.of_zero

def _root_.LO.FirstOrder.Arith.mkVec‚ÇÇDef : ùö∫‚ÇÅ.Semisentence 3 := .mkSigma
  ‚Äús x y. ‚àÉ sy, !mkVec‚ÇÅDef sy y ‚àß !consDef s x sy‚Äù (by simp)

lemma mkVec‚ÇÇ_defined : ùö∫‚ÇÅ-Function‚ÇÇ (fun x y : V ‚Ü¶ ?[x, y]) via mkVec‚ÇÇDef := by
  intro v; simp [mkVec‚ÇÇDef]

@[simp] lemma eval_mkVec‚ÇÇDef (v) :
    Semiformula.Evalbm V v mkVec‚ÇÇDef.val ‚Üî v 0 = ?[v 1, v 2] := mkVec‚ÇÇ_defined.df.iff v

instance mkVec‚ÇÇ_definable : ùö∫‚ÇÅ-Function‚ÇÇ (fun x y : V ‚Ü¶ ?[x, y]) := mkVec‚ÇÇ_defined.to_definable

instance mkVec‚ÇÇ_definable' (Œì m) : Œì-[m + 1]-Function‚ÇÇ (fun x y : V ‚Ü¶ ?[x, y]) := mkVec‚ÇÇ_definable.of_sigmaOne

end

end cons

/-!

### N-th element of List

-/

namespace Nth

def Phi (C : Set V) (pr : V) : Prop :=
  (‚àÉ v, pr = ‚ü™v, 0, fstIdx v‚ü´) ‚à® (‚àÉ v i x, pr = ‚ü™v, i + 1, x‚ü´ ‚àß ‚ü™sndIdx v, i, x‚ü´ ‚àà C)

private lemma phi_iff (C pr : V) :
    Phi {x | x ‚àà C} pr ‚Üî
    (‚àÉ v ‚â§ pr, ‚àÉ fst ‚â§ v, fst = fstIdx v ‚àß pr = ‚ü™v, 0, fst‚ü´) ‚à®
    (‚àÉ v ‚â§ pr, ‚àÉ i ‚â§ pr, ‚àÉ x ‚â§ pr, pr = ‚ü™v, i + 1, x‚ü´ ‚àß ‚àÉ snd ‚â§ v, snd = sndIdx v ‚àß ‚àÉ six < C, six = ‚ü™snd, i, x‚ü´ ‚àß six ‚àà C) := by
  constructor
  ¬∑ rintro (‚ü®v, rfl‚ü© | ‚ü®v, i, x, rfl, hC‚ü©)
    ¬∑ left; exact ‚ü®v, by simp, _, by simp, rfl, rfl‚ü©
    ¬∑ right; exact ‚ü®v, by simp,
        i, le_trans (le_trans (by simp) (le_pair_left _ _)) (le_pair_right _ _),
        x, le_trans (by simp) (le_pair_right _ _), rfl, _, by simp, rfl, _, lt_of_mem hC, rfl, hC‚ü©
  ¬∑ rintro (‚ü®v, _, _, _, rfl, rfl‚ü© | ‚ü®v, _, i, _, x, _, rfl, _, _, rfl, _, _, rfl, hC‚ü©)
    ¬∑ left; exact ‚ü®v, rfl‚ü©
    ¬∑ right; exact ‚ü®v, i, x, rfl, hC‚ü©

def blueprint : Fixpoint.Blueprint 0 where
  core := .ofZero
    (.mkSigma ‚Äúpr C.
    (‚àÉ v <‚Å∫ pr, ‚àÉ fst <‚Å∫ v, !fstIdxDef fst v ‚àß !pair‚ÇÉDef pr v 0 fst) ‚à®
    (‚àÉ v <‚Å∫ pr, ‚àÉ i <‚Å∫ pr, ‚àÉ x <‚Å∫ pr, !pair‚ÇÉDef pr v (i + 1) x ‚àß
      ‚àÉ snd <‚Å∫ v, !sndIdxDef snd v ‚àß ‚àÉ six < C, !pair‚ÇÉDef six snd i x ‚àß six ‚àà C)‚Äù
    (by simp))
    _

def construction : Fixpoint.Construction V blueprint where
  Œ¶ := fun _ ‚Ü¶ Phi
  defined := .of_zero <| by intro v; simp [phi_iff]
  monotone := by
    rintro C C' hC _ x (h | ‚ü®v, i, x, rfl, h‚ü©)
    ¬∑ left; exact h
    ¬∑ right; exact ‚ü®v, i, x, rfl, hC h‚ü©

instance : construction.Finite V where
  finite := by
    rintro C v x (h | ‚ü®v, i, x, rfl, h‚ü©)
    ¬∑ exact ‚ü®0, Or.inl h‚ü©
    ¬∑ exact ‚ü®‚ü™sndIdx v, i, x‚ü´ + 1, Or.inr ‚ü®v, i, x, rfl, h, by simp‚ü©‚ü©

def Graph : V ‚Üí Prop := construction.Fixpoint ![]

section

def graphDef : ùö∫‚ÇÅ.Semisentence 1 := blueprint.fixpointDef

lemma graph_defined : ùö∫‚ÇÅ-Predicate (Graph : V ‚Üí Prop) via graphDef :=
  construction.fixpoint_defined

instance graph_definable : ùö∫‚ÇÅ-Predicate (Graph : V ‚Üí Prop) := graph_defined.to_definable

instance graph_definable' : ùö∫-[0 + 1]-Predicate (Graph : V ‚Üí Prop) := graph_definable

end

/-- TODO: move-/
@[simp] lemma zero_ne_add_one (x : V) : 0 ‚â† x + 1 := ne_of_lt (by simp)

lemma graph_case {pr : V} :
    Graph pr ‚Üî
    (‚àÉ v, pr = ‚ü™v, 0, fstIdx v‚ü´) ‚à® (‚àÉ v i x, pr = ‚ü™v, i + 1, x‚ü´ ‚àß Graph ‚ü™sndIdx v, i, x‚ü´) :=
  construction.case

lemma graph_zero {v x : V} :
    Graph ‚ü™v, 0, x‚ü´ ‚Üî x = fstIdx v := by
  constructor
  ¬∑ intro h
    rcases graph_case.mp h with (‚ü®v, h‚ü© | ‚ü®v, i, x, h, _‚ü©)
    ¬∑ simp at h; rcases h with ‚ü®rfl, rfl, rfl‚ü©; rfl
    ¬∑ simp at h
  ¬∑ rintro rfl; exact graph_case.mpr <| Or.inl ‚ü®v, rfl‚ü©

lemma graph_succ {v i x : V} :
    Graph ‚ü™v, i + 1, x‚ü´ ‚Üî Graph ‚ü™sndIdx v, i, x‚ü´ := by
  constructor
  ¬∑ intro h
    rcases graph_case.mp h with (‚ü®v, h‚ü© | ‚ü®v, i, x, h, hv‚ü©)
    ¬∑ simp at h
    ¬∑ simp at h; rcases h with ‚ü®rfl, rfl, rfl‚ü©; exact hv
  ¬∑ intro h; exact graph_case.mpr <| Or.inr ‚ü®v, i, x, rfl, h‚ü©

lemma graph_exists (v i : V) : ‚àÉ x, Graph ‚ü™v, i, x‚ü´ := by
  suffices ‚àÄ i' ‚â§ i, ‚àÄ v' ‚â§ v, ‚àÉ x, Graph ‚ü™v', i', x‚ü´ from this i (by simp) v (by simp)
  intro i' hi'
  induction i' using induction_sigma1
  ¬∑ definability
  case zero =>
    intro v' _
    exact ‚ü®fstIdx v', graph_case.mpr <| Or.inl ‚ü®v', rfl‚ü©‚ü©
  case succ i' ih =>
    intro v' hv'
    rcases ih (le_trans le_self_add hi') (sndIdx v') (le_trans (by simp) hv') with ‚ü®x, hx‚ü©
    exact ‚ü®x, graph_case.mpr <| Or.inr ‚ü®v', i', x, rfl, hx‚ü©‚ü©

lemma graph_unique {v i x‚ÇÅ x‚ÇÇ : V} : Graph ‚ü™v, i, x‚ÇÅ‚ü´ ‚Üí Graph ‚ü™v, i, x‚ÇÇ‚ü´ ‚Üí x‚ÇÅ = x‚ÇÇ := by
  induction i using induction_pi1 generalizing v x‚ÇÅ x‚ÇÇ
  ¬∑ definability
  case zero =>
    simp [graph_zero]
    rintro rfl rfl; rfl
  case succ i ih =>
    simp [graph_succ]
    exact ih

lemma graph_existsUnique (v i : V) : ‚àÉ! x, Graph ‚ü™v, i, x‚ü´ := by
  rcases graph_exists v i with ‚ü®x, hx‚ü©
  exact ExistsUnique.intro x hx (fun y hy ‚Ü¶ graph_unique hy hx)

end Nth

section nth

open Nth

def nth (v i : V) : V := Classical.choose! (graph_existsUnique v i)

scoped notation:max v:max ".[" i "]" => nth v i

lemma nth_graph (v i : V) : Graph ‚ü™v, i, v.[i]‚ü´ :=
  Classical.choose!_spec (graph_existsUnique v i)

lemma nth_eq_of_graph {v i x : V} (h : Graph ‚ü™v, i, x‚ü´) : nth v i = x := graph_unique (nth_graph v i) h

lemma nth_zero (v : V) : v.[0] = fstIdx v := nth_eq_of_graph (graph_zero.mpr rfl)

lemma nth_succ (v i : V) : v.[i + 1] = (sndIdx v).[i] := nth_eq_of_graph (graph_succ.mpr <| nth_graph _ _)

@[simp] lemma nth_cons_zero (x v : V) : (x ‚à∑ v).[0] = x := by
  simp [nth_zero]

@[simp] lemma nth_cons_succ (x v i : V) : (x ‚à∑ v).[i + 1] = v.[i] := by
  simp [nth_succ]

@[simp] lemma nth_cons_one (x v : V) : (x ‚à∑ v).[1] = v.[0] := by
  simpa using nth_cons_succ x v 0

@[simp] lemma nth_cons_two (x v : V) : (x ‚à∑ v).[2] = v.[1] := by
  simpa [-nth_cons_succ, one_add_one_eq_two] using nth_cons_succ x v 1

lemma cons_cases (x : V) : x = 0 ‚à® ‚àÉ y v, x = y ‚à∑ v := by
  rcases zero_or_succ x with (rfl | ‚ü®z, rfl‚ü©)
  ¬∑ simp
  ¬∑ right; exact ‚ü®œÄ‚ÇÅ z, œÄ‚ÇÇ z, by simp [cons]‚ü©

lemma cons_induction (Œì) {P : V ‚Üí Prop} (hP : Œì-[1]-Predicate P)
    (nil : P 0) (cons : ‚àÄ x v, P v ‚Üí P (x ‚à∑ v)) : ‚àÄ v, P v :=
  order_induction_hh Œì 1 hP (by
    intro v ih
    rcases nil_or_cons v with (rfl | ‚ü®x, v, rfl‚ü©)
    ¬∑ exact nil
    ¬∑ exact cons _ _ (ih v (by simp)))

@[elab_as_elim]
lemma cons_induction_sigma1 {P : V ‚Üí Prop} (hP : ùö∫‚ÇÅ-Predicate P)
    (nil : P 0) (cons : ‚àÄ x v, P v ‚Üí P (x ‚à∑ v)) : ‚àÄ v, P v :=
  cons_induction ùö∫ hP nil cons

@[elab_as_elim]
lemma cons_induction_pi1 {P : V ‚Üí Prop} (hP : ùö∑‚ÇÅ-Predicate P)
    (nil : P 0) (cons : ‚àÄ x v, P v ‚Üí P (x ‚à∑ v)) : ‚àÄ v, P v :=
  cons_induction ùö∑ hP nil cons

section

def _root_.LO.FirstOrder.Arith.nthDef : ùö∫‚ÇÅ.Semisentence 3 :=
  .mkSigma ‚Äúy v i. ‚àÉ pr, !pair‚ÇÉDef pr v i y ‚àß !graphDef pr‚Äù (by simp)

lemma nth_defined : ùö∫‚ÇÅ-Function‚ÇÇ (nth : V ‚Üí V ‚Üí V) via nthDef := by
  intro v; simp [nthDef, graph_defined.df.iff]
  constructor
  ¬∑ intro h; rw [h]; exact nth_graph _ _
  ¬∑ intro h; simp [nth_eq_of_graph h]

@[simp] lemma eval_nthDef (v) :
    Semiformula.Evalbm V v nthDef.val ‚Üî v 0 = nth (v 1) (v 2) := nth_defined.df.iff v

instance nth_definable : ùö∫‚ÇÅ-Function‚ÇÇ (nth : V ‚Üí V ‚Üí V) := nth_defined.to_definable

instance nth_definable' (Œì m) : Œì-[m + 1]-Function‚ÇÇ (nth : V ‚Üí V ‚Üí V) := nth_definable.of_sigmaOne

end

lemma cons_absolute (a v : ‚Ñï) : ((a ‚à∑ v : ‚Ñï) : V) = (a : V) ‚à∑ (v : V) := by
  simpa using DefinedFunction.shigmaZero_absolute_func V cons_defined cons_defined ![a, v]

/-- TODO: move-/
lemma pi‚ÇÅ_zero : œÄ‚ÇÅ (0 : V) = 0 := nonpos_iff_eq_zero.mp (pi‚ÇÅ_le_self 0)

lemma pi‚ÇÇ_zero : œÄ‚ÇÇ (0 : V) = 0 := nonpos_iff_eq_zero.mp (pi‚ÇÇ_le_self 0)

@[simp] lemma nth_zero_idx (i : V) : (0).[i] = 0 := by
  induction i using induction_sigma1
  ¬∑ definability
  case zero => simp [nth_zero, fstIdx, pi‚ÇÅ_zero]
  case succ i ih => simp [nth_succ, sndIdx, pi‚ÇÇ_zero, ih]

lemma nth_lt_of_pos {v} (hv : 0 < v) (i : V) : v.[i] < v := by
  induction i using induction_pi1 generalizing v
  ¬∑ definability
  case zero =>
    rcases zero_or_succ v with (rfl | ‚ü®v, rfl‚ü©)
    ¬∑ simp at hv
    ¬∑ simp [succ_eq_cons]
  case succ i ih =>
    rcases zero_or_succ v with (rfl | ‚ü®v, rfl‚ü©)
    ¬∑ simp at hv
    ¬∑ simp [succ_eq_cons v]
      rcases eq_zero_or_pos (œÄ‚ÇÇ v) with (h | h)
      ¬∑ simp [h]
      ¬∑ exact lt_trans (ih h) (by simp)

@[simp] lemma nth_le (v i : V) : v.[i] ‚â§ v := by
  rcases eq_zero_or_pos v with (h | h)
  ¬∑ simp [h]
  ¬∑ exact le_of_lt <| nth_lt_of_pos h i

end nth


/-!

### Inductivly Construction of Function on List

-/

namespace VecRec

structure Blueprint (arity : ‚Ñï) where
  nil : ùö∫‚ÇÅ.Semisentence (arity + 1)
  cons : ùö∫‚ÇÅ.Semisentence (arity + 4)

namespace Blueprint

variable {arity : ‚Ñï} (Œ≤ : Blueprint arity)

def blueprint : Fixpoint.Blueprint arity where
  core := .mkDelta
    (.mkSigma ‚Äúpr C.
        (‚àÉ nil, !Œ≤.nil nil ‚ãØ ‚àß !pairDef pr 0 nil) ‚à®
        (‚àÉ x < pr, ‚àÉ xs < pr, ‚àÉ ih < C,
          ‚àÉ xxs, !consDef xxs x xs ‚àß
          ‚àÉ cons, !Œ≤.cons cons x xs ih ‚ãØ ‚àß
          !pairDef pr xxs cons ‚àß :‚ü™xs, ih‚ü´:‚àà C)‚Äù
      (by simp))
    (.mkPi ‚Äúpr C.
        (‚àÄ nil, !Œ≤.nil nil ‚ãØ ‚Üí !pairDef pr 0 nil) ‚à®
        (‚àÉ x < pr, ‚àÉ xs < pr, ‚àÉ ih < C,
          ‚àÄ xxs, !consDef xxs x xs ‚Üí
          ‚àÄ cons, !Œ≤.cons cons x xs ih ‚ãØ ‚Üí
          !pairDef pr xxs cons ‚àß :‚ü™xs, ih‚ü´:‚àà C)‚Äù
      (by simp))

def graphDef : ùö∫‚ÇÅ.Semisentence (arity + 1) := Œ≤.blueprint.fixpointDef

def resultDef : ùö∫‚ÇÅ.Semisentence (arity + 2) :=
  .mkSigma ‚Äúy xs. ‚àÉ pr, !pairDef pr xs y ‚àß !Œ≤.graphDef pr ‚ãØ‚Äù (by simp)

end Blueprint

variable (V)

structure Construction {arity : ‚Ñï} (Œ≤ : Blueprint arity) where
  nil (param : Fin arity ‚Üí V) : V
  cons (param : Fin arity ‚Üí V) (x xs ih) : V
  nil_defined : ùö∫‚ÇÅ.DefinedFunction nil Œ≤.nil
  cons_defined : ùö∫‚ÇÅ.DefinedFunction (fun v ‚Ü¶ cons (v ¬∑.succ.succ.succ) (v 0) (v 1) (v 2)) Œ≤.cons

variable {V}

namespace Construction

variable {arity : ‚Ñï} {Œ≤ : Blueprint arity} (c : Construction V Œ≤)

def Phi (param : Fin arity ‚Üí V) (C : Set V) (pr : V) : Prop :=
  pr = ‚ü™0, c.nil param‚ü´ ‚à® (‚àÉ x xs ih, pr = ‚ü™x ‚à∑ xs, c.cons param x xs ih‚ü´ ‚àß ‚ü™xs, ih‚ü´ ‚àà C)

private lemma phi_iff (param : Fin arity ‚Üí V) (C pr : V) :
    c.Phi param {x | x ‚àà C} pr ‚Üî
    pr = ‚ü™0, c.nil param‚ü´ ‚à® (‚àÉ x < pr, ‚àÉ xs < pr, ‚àÉ ih < C, pr = ‚ü™x ‚à∑ xs, c.cons param x xs ih‚ü´ ‚àß ‚ü™xs, ih‚ü´ ‚àà C) := by
  constructor
  ¬∑ rintro (h | ‚ü®x, xs, ih, rfl, hC‚ü©)
    ¬∑ left; exact h
    ¬∑ right
      exact ‚ü®x, lt_of_lt_of_le (by simp) (le_pair_left _ _),
        xs, lt_of_lt_of_le (by simp) (le_pair_left _ _), ih, lt_of_mem_rng hC, rfl , hC‚ü©
  ¬∑ rintro (h | ‚ü®x, _, xs, _, ih, _, rfl, hC‚ü©)
    ¬∑ left; exact h
    ¬∑ right; exact ‚ü®x, xs, ih, rfl, hC‚ü©

def construction : Fixpoint.Construction V Œ≤.blueprint where
  Œ¶ := c.Phi
  defined := ‚ü®by
    intro v; simp [Blueprint.blueprint, c.nil_defined.df.iff, c.cons_defined.df.iff], by
    intro v; simpa [Blueprint.blueprint, c.nil_defined.df.iff, c.cons_defined.df.iff] using c.phi_iff _ _ _‚ü©
  monotone := by
    rintro C C' hC _ x (h | ‚ü®v, i, hv, rfl, h‚ü©)
    ¬∑ left; exact h
    ¬∑ right; exact ‚ü®v, i, hv, rfl, hC h‚ü©

instance : c.construction.Finite V where
  finite := by
    rintro C v x (h | ‚ü®x, xs, ih, rfl, h‚ü©)
    ¬∑ exact ‚ü®0, Or.inl h‚ü©
    ¬∑ exact ‚ü®‚ü™xs, ih‚ü´ + 1, Or.inr ‚ü®x, xs, ih, rfl, h, by simp‚ü©‚ü©

variable (param : Fin arity ‚Üí V)

def Graph : V ‚Üí Prop := c.construction.Fixpoint param

section

lemma graph_defined : ùö∫‚ÇÅ.Defined (fun v ‚Ü¶ c.Graph (v ¬∑.succ) (v 0)) Œ≤.graphDef :=
  c.construction.fixpoint_defined

instance graph_definable : ùö∫‚ÇÅ.Boldface (fun v ‚Ü¶ c.Graph (v ¬∑.succ) (v 0)) := c.graph_defined.to_definable

instance graph_definable' (param) : ùö∫‚ÇÅ-Predicate (c.Graph param) := by
  simpa using HierarchySymbol.Boldface.retractiont (n := 1) c.graph_definable (#0 :> fun i ‚Ü¶ &(param i))

instance graph_definable'' (param) : ùö∫-[0 + 1]-Predicate (c.Graph param) := c.graph_definable' param

end

variable {param}

lemma graph_case {pr : V} :
    c.Graph param pr ‚Üî pr = ‚ü™0, c.nil param‚ü´ ‚à® (‚àÉ x xs ih, pr = ‚ü™x ‚à∑ xs, c.cons param x xs ih‚ü´ ‚àß c.Graph param ‚ü™xs, ih‚ü´) :=
  c.construction.case

lemma graph_nil {l : V} :
    c.Graph param ‚ü™0, l‚ü´ ‚Üî l = c.nil param := by
  constructor
  ¬∑ intro h
    rcases c.graph_case.mp h with (h | ‚ü®x, xs, ih, h, _‚ü©)
    ¬∑ simp at h; rcases h with ‚ü®rfl, rfl‚ü©; rfl
    ¬∑ simp at h
  ¬∑ rintro rfl; exact c.graph_case.mpr <| Or.inl rfl

lemma graph_cons {x xs y : V} :
    c.Graph param ‚ü™x ‚à∑ xs, y‚ü´ ‚Üî ‚àÉ y', y = c.cons param x xs y' ‚àß c.Graph param ‚ü™xs, y'‚ü´ := by
  constructor
  ¬∑ intro h
    rcases c.graph_case.mp h with (h | ‚ü®x, xs, y, h, hg‚ü©)
    ¬∑ simp at h
    ¬∑ simp at h; rcases h with ‚ü®‚ü®rfl, rfl‚ü©, rfl‚ü©
      exact ‚ü®y, rfl, hg‚ü©
  ¬∑ rintro ‚ü®y, rfl, h‚ü©; exact c.graph_case.mpr <| Or.inr ‚ü®x, xs, y, rfl, h‚ü©

variable (param)

lemma graph_exists (xs : V) : ‚àÉ y, c.Graph param ‚ü™xs, y‚ü´ := by
  induction xs using cons_induction_sigma1
  ¬∑ definability
  case nil =>
    exact ‚ü®c.nil param, c.graph_nil.mpr rfl‚ü©
  case cons x xs ih =>
    ¬∑ rcases ih with ‚ü®y, hy‚ü©
      exact ‚ü®c.cons param x xs y, c.graph_cons.mpr ‚ü®y, rfl, hy‚ü©‚ü©

variable {param}

lemma graph_unique {xs y‚ÇÅ y‚ÇÇ : V} : c.Graph param ‚ü™xs, y‚ÇÅ‚ü´ ‚Üí c.Graph param ‚ü™xs, y‚ÇÇ‚ü´ ‚Üí y‚ÇÅ = y‚ÇÇ := by
  induction xs using cons_induction_pi1 generalizing y‚ÇÅ y‚ÇÇ
  ¬∑ definability
  case nil =>
    simp [graph_nil]; rintro rfl rfl; rfl
  case cons x v ih =>
    simp [graph_cons]
    rintro l‚ÇÅ rfl h‚ÇÅ l‚ÇÇ rfl h‚ÇÇ
    rcases ih h‚ÇÅ h‚ÇÇ; rfl

variable (param)

lemma graph_existsUnique (xs : V) : ‚àÉ! y, c.Graph param ‚ü™xs, y‚ü´ := by
  rcases c.graph_exists param xs with ‚ü®y, hy‚ü©
  exact ExistsUnique.intro y hy (fun y' hy' ‚Ü¶ c.graph_unique hy' hy)

def result (xs : V) : V := Classical.choose! (c.graph_existsUnique param xs)

lemma result_graph (xs : V) : c.Graph param ‚ü™xs, c.result param xs‚ü´ :=
  Classical.choose!_spec (c.graph_existsUnique param xs)

lemma result_eq_of_graph {xs y : V} (h : c.Graph param ‚ü™xs, y‚ü´) : c.result param xs = y :=
  c.graph_unique (c.result_graph param xs) h

@[simp] lemma result_nil : c.result param (0 : V) = c.nil param := c.result_eq_of_graph param (c.graph_nil.mpr rfl)

@[simp] lemma result_cons (x xs : V) :
    c.result param (x ‚à∑ xs) = c.cons param x xs (c.result param xs) :=
  c.result_eq_of_graph param (c.graph_cons.mpr ‚ü®_, rfl, c.result_graph param xs‚ü©)

section

lemma result_defined : ùö∫‚ÇÅ.DefinedFunction (fun v ‚Ü¶ c.result (v ¬∑.succ) (v 0)) Œ≤.resultDef := by
  intro v; simp [Blueprint.resultDef, c.graph_defined.df.iff]
  constructor
  ¬∑ intro h; rw [h]; exact c.result_graph _ _
  ¬∑ intro h; symm; simpa using c.result_eq_of_graph _ h

@[simp] lemma eval_resultDef (v) :
    Semiformula.Evalbm V v Œ≤.resultDef.val ‚Üî v 0 = c.result (v ¬∑.succ.succ) (v 1) := c.result_defined.df.iff v

instance result_definable : ùö∫‚ÇÅ.BoldfaceFunction (fun v ‚Ü¶ c.result (v ¬∑.succ) (v 0)) :=
  c.result_defined.to_definable

instance result_definable' (Œì m) :
    Œì-[m + 1].BoldfaceFunction (fun v ‚Ü¶ c.result (v ¬∑.succ) (v 0)) := c.result_definable.of_sigmaOne

end

end Construction

end VecRec

/-!

### Length of List

-/

namespace Len

def blueprint : VecRec.Blueprint 0 where
  nil := .mkSigma ‚Äúy. y = 0‚Äù (by simp)
  cons := .mkSigma ‚Äúy x xs ih. y = ih + 1‚Äù (by simp)

def construction : VecRec.Construction V blueprint where
  nil _ := 0
  cons _ _ _ ih := ih + 1
  nil_defined := by intro v; simp [blueprint]
  cons_defined := by intro v; simp [blueprint]

end Len

section len

open Len

def len (v : V) : V := construction.result ![] v

@[simp] lemma len_nil : len (0 : V) = 0 := by simp [len, construction]

@[simp] lemma len_cons (x v : V) : len (x ‚à∑ v) = len v + 1 := by simp [len, construction]

section

def _root_.LO.FirstOrder.Arith.lenDef : ùö∫‚ÇÅ.Semisentence 2 := blueprint.resultDef

lemma len_defined : ùö∫‚ÇÅ-Function‚ÇÅ (len : V ‚Üí V) via lenDef := construction.result_defined

@[simp] lemma eval_lenDef (v) :
    Semiformula.Evalbm V v lenDef.val ‚Üî v 0 = len (v 1) := len_defined.df.iff v

instance len_definable : ùö∫‚ÇÅ-Function‚ÇÅ (len : V ‚Üí V) := len_defined.to_definable

instance len_definable' (Œì m) : Œì-[m + 1]-Function‚ÇÅ (len : V ‚Üí V) := len_definable.of_sigmaOne

end

@[simp] lemma len_zero_iff_eq_nil {v : V} : len v = 0 ‚Üî v = 0 := by
  rcases nil_or_cons v with (rfl | ‚ü®x, v, rfl‚ü©) <;> simp

lemma nth_lt_len {v i : V} (hl : len v ‚â§ i) : v.[i] = 0 := by
  induction v using cons_induction_pi1 generalizing i
  ¬∑ definability
  case nil => simp
  case cons x v ih =>
    rcases zero_or_succ i with (rfl | ‚ü®i, rfl‚ü©)
    ¬∑ simp at hl
    simpa using ih (by simpa using hl)

@[simp] lemma len_le (v : V) : len v ‚â§ v := by
  induction v using cons_induction_pi1
  ¬∑ definability
  case nil => simp
  case cons x v ih =>
    simp only [len_cons]
    simp only [cons, add_le_add_iff_right]
    exact le_trans ih (le_pair_right x v)

end len

lemma nth_ext {v‚ÇÅ v‚ÇÇ : V} (hl : len v‚ÇÅ = len v‚ÇÇ) (H : ‚àÄ i < len v‚ÇÅ, v‚ÇÅ.[i] = v‚ÇÇ.[i]) : v‚ÇÅ = v‚ÇÇ := by
  induction v‚ÇÅ using cons_induction_pi1 generalizing v‚ÇÇ
  ¬∑ definability
  case nil =>
    exact Eq.symm <| len_zero_iff_eq_nil.mp (by simp [‚Üêhl])
  case cons x‚ÇÅ v‚ÇÅ ih =>
    rcases nil_or_cons v‚ÇÇ with (rfl | ‚ü®x‚ÇÇ, v‚ÇÇ, rfl‚ü©)
    ¬∑ simp at hl
    have hx : x‚ÇÅ = x‚ÇÇ := by simpa using H 0 (by simp)
    have hv : v‚ÇÅ = v‚ÇÇ := ih (by simpa using hl) (by intro i hi; simpa using H (i + 1) (by simpa using hi))
    simp [hx, hv]

lemma nth_ext' (l : V) {v‚ÇÅ v‚ÇÇ : V} (hl‚ÇÅ : len v‚ÇÅ = l) (hl‚ÇÇ : len v‚ÇÇ = l) (H : ‚àÄ i < l, v‚ÇÅ.[i] = v‚ÇÇ.[i]) : v‚ÇÅ = v‚ÇÇ := by
  rcases hl‚ÇÇ; exact nth_ext hl‚ÇÅ (by simpa [hl‚ÇÅ] using H)

lemma le_of_nth_le_nth {v‚ÇÅ v‚ÇÇ : V} (hl : len v‚ÇÅ = len v‚ÇÇ) (H : ‚àÄ i < len v‚ÇÅ, v‚ÇÅ.[i] ‚â§ v‚ÇÇ.[i]) : v‚ÇÅ ‚â§ v‚ÇÇ := by
  induction v‚ÇÅ using cons_induction_pi1 generalizing v‚ÇÇ
  ¬∑ definability
  case nil => simp
  case cons x‚ÇÅ v‚ÇÅ ih =>
    rcases nil_or_cons v‚ÇÇ with (rfl | ‚ü®x‚ÇÇ, v‚ÇÇ, rfl‚ü©)
    ¬∑ simp at hl
    have hx : x‚ÇÅ ‚â§ x‚ÇÇ := by simpa using H 0 (by simp)
    have hv : v‚ÇÅ ‚â§ v‚ÇÇ := ih (by simpa using hl) (by intro i hi; simpa using H (i + 1) (by simpa using hi))
    exact cons_le_cons hx hv

lemma nth_lt_self {v i : V} (hi : i < len v) : v.[i] < v := by
  induction v using cons_induction_pi1 generalizing i
  ¬∑ definability
  case nil => simp at hi
  case cons x v ih =>
    rcases zero_or_succ i with (rfl | ‚ü®i, rfl‚ü©)
    ¬∑ simp
    ¬∑ simpa using lt_trans (ih (by simpa using hi)) (by simp)

theorem sigmaOne_skolem_vec {R : V ‚Üí V ‚Üí Prop} (hP : ùö∫‚ÇÅ-Relation R) {l}
    (H : ‚àÄ x < l, ‚àÉ y, R x y) : ‚àÉ v, len v = l ‚àß ‚àÄ i < l, R i v.[i] := by
  have : ‚àÄ k ‚â§ l, ‚àÉ v, len v = k ‚àß ‚àÄ i < k, R (l - k + i) v.[i] := by
    intro k hk
    induction k using induction_sigma1
    ¬∑ definability
    case zero => exact ‚ü®0, by simp‚ü©
    case succ k ih =>
      rcases ih (le_trans (by simp) hk) with ‚ü®v, hvk, hv‚ü©
      have : ‚àÉ y, R (l - (k + 1)) y := H (l - (k + 1)) (by simp [tsub_lt_iff_left hk])
      rcases this with ‚ü®y, hy‚ü©
      exact ‚ü®y ‚à∑ v, by simp [hvk], fun i hi ‚Ü¶ by
        rcases zero_or_succ i with (rfl | ‚ü®i, rfl‚ü©)
        ¬∑ simpa using hy
        ¬∑ simpa [sub_succ_add_succ (succ_le_iff_lt.mp hk) i] using hv i (by simpa using hi)‚ü©
  simpa using this l (by rfl)

lemma eq_singleton_iff_len_eq_one {v : V} : len v = 1 ‚Üî ‚àÉ x, v = ?[x] := by
  constructor
  ¬∑ intro h; exact ‚ü®v.[0], nth_ext (by simp [h]) (by simp [h])‚ü©
  ¬∑ rintro ‚ü®x, rfl‚ü©; simp

lemma eq_doubleton_of_len_eq_two {v : V} : len v = 2 ‚Üî ‚àÉ x y, v = ?[x, y] := by
  constructor
  ¬∑ intro h; exact ‚ü®v.[0], v.[1],
      nth_ext (by simp [h, one_add_one_eq_two]) (by simp [lt_two_iff_le_one, le_one_iff_eq_zero_or_one, h])‚ü©
  ¬∑ rintro ‚ü®x, y, rfl‚ü©; simp [one_add_one_eq_two]


/-!

### Maximum of List

-/

namespace ListMax

def blueprint : VecRec.Blueprint 0 where
  nil := .mkSigma ‚Äúy. y = 0‚Äù (by simp)
  cons := .mkSigma ‚Äúy x xs ih. !FirstOrder.Arith.max y x ih‚Äù (by simp)

def construction : VecRec.Construction V blueprint where
  nil _ := 0
  cons _ x _ ih := max x ih
  nil_defined := by intro v; simp [blueprint]
  cons_defined := by intro v; simp [blueprint]

end ListMax

section listMax

open ListMax

def listMax (v : V) : V := construction.result ![] v

@[simp] lemma listMax_nil : listMax (0 : V) = 0 := by simp [listMax, construction]

@[simp] lemma listMax_cons (x v : V) : listMax (x ‚à∑ v) = max x (listMax v) := by simp [listMax, construction]

section

def _root_.LO.FirstOrder.Arith.listMaxDef : ùö∫‚ÇÅ.Semisentence 2 := blueprint.resultDef

lemma listMax_defined : ùö∫‚ÇÅ-Function‚ÇÅ (listMax : V ‚Üí V) via listMaxDef := construction.result_defined

@[simp] lemma eval_listMaxDef (v) :
    Semiformula.Evalbm V v listMaxDef.val ‚Üî v 0 = listMax (v 1) := listMax_defined.df.iff v

instance listMax_definable : ùö∫‚ÇÅ-Function‚ÇÅ (listMax : V ‚Üí V) := listMax_defined.to_definable

instance listMax_definable' (Œì m) : Œì-[m + 1]-Function‚ÇÅ (listMax : V ‚Üí V) := listMax_definable.of_sigmaOne

end

lemma nth_le_listMax {i v : V} (h : i < len v) : v.[i] ‚â§ listMax v := by
  induction v using cons_induction_pi1 generalizing i
  ¬∑ definability
  case nil => simp
  case cons x v ih =>
    rcases zero_or_succ i with (rfl | ‚ü®i, rfl‚ü©)
    ¬∑ simp
    ¬∑ simp [ih (by simpa using h)]

lemma listMaxss_le {v z : V} (h : ‚àÄ i < len v, v.[i] ‚â§ z) : listMax v ‚â§ z := by
  induction v using cons_induction_pi1
  ¬∑ definability
  case nil => simp
  case cons x v ih =>
    simp only [listMax_cons, max_le_iff]
    constructor
    ¬∑ simpa using h 0 (by simp)
    ¬∑ exact ih (fun i hi ‚Ü¶ by simpa using h (i + 1) (by simp [hi]))

lemma listMaxss_le_iff {v z : V} : listMax v ‚â§ z ‚Üî ‚àÄ i < len v, v.[i] ‚â§ z := by
  constructor
  ¬∑ intro h i hi; exact le_trans (nth_le_listMax hi) h
  ¬∑ exact listMaxss_le

/-
lemma nth_le_listMaxs (v : V) (hv : v ‚â† 0) : ‚àÉ i < len v, v.[i] = listMax v := by
  induction v using cons_induction_sigma1
  ¬∑ definability
  case nil => simp at hv
  case cons x v ih =>
    simp
-/

end listMax

/-!

### Take Last k-Element

-/

namespace TakeLast

def blueprint : VecRec.Blueprint 1 where
  nil := .mkSigma ‚Äúy k. y = 0‚Äù (by simp)
  cons := .mkSigma ‚Äúy x xs ih k.
    ‚àÉ l, !lenDef l xs ‚àß
    (l < k ‚Üí !consDef y x xs) ‚àß (k ‚â§ l ‚Üí y = ih)‚Äù (by simp)

def construction : VecRec.Construction V blueprint where
  nil _ := 0
  cons (param x xs ih) := if len xs < param 0 then x ‚à∑ xs else ih
  nil_defined := by intro v; simp [blueprint]
  cons_defined := by
    intro v
    simp [blueprint, Fin.isValue]
    show (v 0 = if len (v 2) < v 4 then v 1 ‚à∑ v 2 else v 3) ‚Üî
      (len (v 2) < v 4 ‚Üí v 0 = v 1 ‚à∑ v 2) ‚àß (v 4 ‚â§ len (v 2) ‚Üí v 0 = v 3)
    rcases lt_or_ge (len (v 2)) (v 4) with (hv | hv)
    ¬∑ simp [hv]
    ¬∑ simp [hv, not_lt_of_le hv]

end TakeLast

section takeLast

open TakeLast

def takeLast (v k : V) : V := construction.result ![k] v

@[simp] lemma takeLast_nil : takeLast (0 : V) k = 0 := by simp [takeLast, construction]

lemma takeLast_cons (x v : V) :
    takeLast (x ‚à∑ v) k = if len v < k then x ‚à∑ v else takeLast v k := by simp [takeLast, construction]

section

def _root_.LO.FirstOrder.Arith.takeLastDef : ùö∫‚ÇÅ.Semisentence 3 := blueprint.resultDef

lemma takeLast_defined : ùö∫‚ÇÅ-Function‚ÇÇ (takeLast : V ‚Üí V ‚Üí V) via takeLastDef := construction.result_defined

@[simp] lemma eval_takeLastDef (v) :
    Semiformula.Evalbm V v takeLastDef.val ‚Üî v 0 = takeLast (v 1) (v 2) := takeLast_defined.df.iff v

instance takeLast_definable : ùö∫‚ÇÅ-Function‚ÇÇ (takeLast : V ‚Üí V ‚Üí V) := takeLast_defined.to_definable

instance takeLast_definable' (Œì m) : Œì-[m + 1]-Function‚ÇÇ (takeLast : V ‚Üí V ‚Üí V) := takeLast_definable.of_sigmaOne

end

lemma len_takeLast {v k : V} (h : k ‚â§ len v) : len (takeLast v k) = k := by
  induction v using cons_induction_sigma1
  ¬∑ definability
  case nil => simp_all
  case cons x v ih =>
    simp [takeLast_cons]
    have : k = len v + 1 ‚à® k ‚â§ len v := by
      rcases eq_or_lt_of_le h with (h | h)
      ¬∑ left; simpa using h
      ¬∑ right; simpa [lt_succ_iff_le] using h
    rcases this with (rfl | hkv)
    ¬∑ simp
    ¬∑ simp [not_lt_of_le hkv, ih hkv]

@[simp] lemma takeLast_len_self (v : V) : takeLast v (len v) = v := by
  rcases nil_or_cons v with (rfl | ‚ü®x, v, rfl‚ü©) <;> simp [takeLast_cons]

/-- TODO: move -/
@[simp] lemma add_sub_add (a b c : V) : (a + c) - (b + c) = a - b := add_tsub_add_eq_tsub_right a c b

@[simp] lemma takeLast_zero (v : V) : takeLast v 0 = 0 := by
  induction v using cons_induction_sigma1
  ¬∑ definability
  case nil => simp
  case cons x v ih => simp [takeLast_cons, ih]

lemma takeLast_succ_of_lt {i v : V} (h : i < len v) : takeLast v (i + 1) = v.[len v - (i + 1)] ‚à∑ takeLast v i := by
  induction v using cons_induction_sigma1 generalizing i
  ¬∑ definability
  case nil => simp at h
  case cons x v ih =>
    simp [takeLast_cons, lt_succ_iff_le]
    rcases show i = len v ‚à® i < len v from eq_or_lt_of_le (by simpa [lt_succ_iff_le] using h) with (rfl | hi)
    ¬∑ simp
    ¬∑ have : len v - i = len v - (i + 1) + 1 := by
        rw [‚Üêsub_sub, sub_add_self_of_le (pos_iff_one_le.mp (tsub_pos_of_lt hi))]
      simpa [not_le_of_lt hi, ‚ÜìreduceIte, this, nth_cons_succ, not_lt_of_gt hi] using ih hi

end takeLast


/-!

### Concatation

-/

namespace Concat

def blueprint : VecRec.Blueprint 1 where
  nil := .mkSigma ‚Äúy z. !consDef y z 0‚Äù (by simp)
  cons := .mkSigma ‚Äúy x xs ih z. !consDef y x ih‚Äù (by simp)

def construction : VecRec.Construction V blueprint where
  nil param := ?[param 0]
  cons (_ x _ ih) := x ‚à∑ ih
  nil_defined := by intro v; simp [blueprint]
  cons_defined := by
    intro v; simp [blueprint, Fin.isValue]

end Concat

section concat

open Concat

def concat (v z : V) : V := construction.result ![z] v

@[simp] lemma concat_nil (z : V) : concat 0 z = ?[z] := by simp [concat, construction]

@[simp] lemma concat_cons (x v z : V) : concat (x ‚à∑ v) z = x ‚à∑ concat v z := by simp [concat, construction]

section

def _root_.LO.FirstOrder.Arith.concatDef : ùö∫‚ÇÅ.Semisentence 3 := blueprint.resultDef

lemma concat_defined : ùö∫‚ÇÅ-Function‚ÇÇ (concat : V ‚Üí V ‚Üí V) via concatDef := construction.result_defined

@[simp] lemma eval_concatDef (v) :
    Semiformula.Evalbm V v concatDef.val ‚Üî v 0 = concat (v 1) (v 2) := concat_defined.df.iff v

instance concat_definable : ùö∫‚ÇÅ-Function‚ÇÇ (concat : V ‚Üí V ‚Üí V) := concat_defined.to_definable

instance concat_definable' (Œì m) : Œì-[m + 1]-Function‚ÇÇ (concat : V ‚Üí V ‚Üí V) := concat_definable.of_sigmaOne

end

@[simp] lemma len_concat (v z : V) : len (concat v z) = len v + 1 := by
  induction v using cons_induction_sigma1
  ¬∑ definability
  case nil => simp
  case cons x v ih => simp [ih]

lemma concat_nth_lt (v z : V) {i} (hi : i < len v) : (concat v z).[i] = v.[i] := by
  induction v using cons_induction_sigma1 generalizing i
  ¬∑ definability
  case nil => simp at hi
  case cons x v ih =>
    rcases zero_or_succ i with (rfl | ‚ü®i, rfl‚ü©)
    ¬∑ simp
    ¬∑ simp [ih (by simpa using hi)]

@[simp] lemma concat_nth_len (v z : V) : (concat v z).[len v] = z := by
  induction v using cons_induction_sigma1
  ¬∑ definability
  case nil => simp
  case cons x v ih => simp [ih]

lemma concat_nth_len' (v z : V) {i} (hi : len v = i) : (concat v z).[i] = z := by
  rcases hi; simp

end concat

/-!

### Membership

-/

section vec_membership

def MemVec (x v : V) : Prop := ‚àÉ i < len v, x = v.[i]

scoped infix:40 " ‚àà·µ• " => MemVec

@[simp] lemma not_memVec_empty (x : V) : ¬¨x ‚àà·µ• 0 := by rintro ‚ü®i, h, _‚ü©; simp at h

lemma nth_mem_memVec {i v : V} (h : i < len v) : v.[i] ‚àà·µ• v := ‚ü®i, by simp [h]‚ü©

@[simp] lemma memVec_insert_fst {x v : V} : x ‚àà·µ• x ‚à∑ v := ‚ü®0, by simp‚ü©

@[simp] lemma memVec_cons_iff {x y v : V} : x ‚àà·µ• y ‚à∑ v ‚Üî x = y ‚à® x ‚àà·µ• v := by
  constructor
  ¬∑ rintro ‚ü®i, h, rfl‚ü©
    rcases zero_or_succ i with (rfl | ‚ü®i, rfl‚ü©) <;> simp
    right; exact nth_mem_memVec (by simpa using h)
  ¬∑ rintro (rfl | hx)
    ¬∑ simp
    ¬∑ rcases hx with ‚ü®i, hi, rfl‚ü©
      exact ‚ü®i + 1, by simp [hi]‚ü©

lemma le_of_memVec {x v : V} (h : x ‚àà·µ• v) : x ‚â§ v := by
  rcases h with ‚ü®i, _, rfl‚ü©; simp

section

def _root_.LO.FirstOrder.Arith.memVecDef : ùö´‚ÇÅ.Semisentence 2 := .mkDelta
  (.mkSigma ‚Äúx v. ‚àÉ l, !lenDef l v ‚àß ‚àÉ i < l, !nthDef x v i‚Äù (by simp))
  (.mkPi ‚Äúx v. ‚àÄ l, !lenDef l v ‚Üí ‚àÉ i < l, ‚àÄ vi, !nthDef vi v i ‚Üí x = vi‚Äù (by simp))

lemma memVec_defined : ùö´‚ÇÅ-Relation (MemVec : V ‚Üí V ‚Üí Prop) via memVecDef :=
  ‚ü®by intro v; simp [memVecDef], by intro v; simp [memVecDef, MemVec]‚ü©

@[simp] lemma eval_memVecDef (v) :
    Semiformula.Evalbm V v memVecDef.val ‚Üî v 0 ‚àà·µ• v 1 := memVec_defined.df.iff v

instance memVec_definable : ùö´‚ÇÅ-Relation (MemVec : V ‚Üí V ‚Üí Prop) := memVec_defined.to_definable

instance memVec_definable' (Œì m) : Œì-[m + 1]-Relation (MemVec : V ‚Üí V ‚Üí Prop) := memVec_definable.of_deltaOne

end

end vec_membership

/-!

### Subset

-/

section vec_subset

def SubsetVec (v w : V) : Prop := ‚àÄ x, x ‚àà·µ• v ‚Üí x ‚àà·µ• w

scoped infix:30 " ‚äÜ·µ• " => SubsetVec

@[simp, refl] lemma SubsetVec.refl (v : V) : v ‚äÜ·µ• v := fun _ hx ‚Ü¶ hx

@[simp] lemma subsetVec_insert_tail (x v : V) : v ‚äÜ·µ• x ‚à∑ v := by intro y hy; simp [hy]

section

def _root_.LO.FirstOrder.Arith.subsetVecDef : ùö´‚ÇÅ.Semisentence 2 := .mkDelta
  (.mkSigma ‚Äúv w. ‚àÄ x <‚Å∫ v, !memVecDef.pi x v ‚Üí !memVecDef.sigma x w‚Äù (by simp))
  (.mkPi ‚Äúv w. ‚àÄ x <‚Å∫ v, !memVecDef.sigma x v ‚Üí !memVecDef.pi x w‚Äù (by simp))

lemma subsetVec_defined : ùö´‚ÇÅ-Relation (SubsetVec : V ‚Üí V ‚Üí Prop) via subsetVecDef :=
  ‚ü®by intro v; simp [subsetVecDef, HierarchySymbol.Semiformula.val_sigma, memVec_defined.proper.iff'],
   by intro v
      simp [subsetVecDef, HierarchySymbol.Semiformula.val_sigma, memVec_defined.proper.iff']
      constructor
      ¬∑ intro h x _; exact h x
      ¬∑ intro h x hx; exact h x (le_of_memVec hx) hx‚ü©

@[simp] lemma eval_subsetVecDef (v) :
    Semiformula.Evalbm V v subsetVecDef.val ‚Üî v 0 ‚äÜ·µ• v 1 := subsetVec_defined.df.iff v

instance subsetVec_definable : ùö´‚ÇÅ-Relation (SubsetVec : V ‚Üí V ‚Üí Prop) := subsetVec_defined.to_definable

instance subsetVec_definable' (Œì m) : Œì-[m + 1]-Relation (SubsetVec : V ‚Üí V ‚Üí Prop) := subsetVec_definable.of_deltaOne

end

end vec_subset

/-!

### Repeat

-/

section repaetVec

def repeatVec.blueprint : PR.Blueprint 1 where
  zero := .mkSigma ‚Äúy x. y = 0‚Äù (by simp)
  succ := .mkSigma ‚Äúy ih n x. !consDef y x ih‚Äù (by simp)

def repeatVec.construction : PR.Construction V repeatVec.blueprint where
  zero := fun _ ‚Ü¶ 0
  succ := fun x _ ih ‚Ü¶ x 0 ‚à∑ ih
  zero_defined := by intro v; simp [blueprint]
  succ_defined := by intro v; simp [blueprint]

/-- `repeatVec x k = x ‚à∑ x ‚à∑ x ‚à∑ ... k times ... ‚à∑ 0`-/
def repeatVec (x k : V) : V := repeatVec.construction.result ![x] k

@[simp] lemma repeatVec_zero (x : V) : repeatVec x 0 = 0 := by simp [repeatVec, repeatVec.construction]

@[simp] lemma repeatVec_succ (x k : V) : repeatVec x (k + 1) = x ‚à∑ repeatVec x k := by simp [repeatVec, repeatVec.construction]

section

def _root_.LO.FirstOrder.Arith.repeatVecDef : ùö∫‚ÇÅ.Semisentence 3 := repeatVec.blueprint.resultDef |>.rew (Rew.substs ![#0, #2, #1])

lemma repeatVec_defined : ùö∫‚ÇÅ-Function‚ÇÇ (repeatVec : V ‚Üí V ‚Üí V) via repeatVecDef :=
  fun v ‚Ü¶ by simp [repeatVec.construction.result_defined_iff, repeatVecDef]; rfl

@[simp] lemma eval_repeatVec (v) :
    Semiformula.Evalbm V v repeatVecDef.val ‚Üî v 0 = repeatVec (v 1) (v 2) := repeatVec_defined.df.iff v

instance repeatVec_definable : ùö∫‚ÇÅ-Function‚ÇÇ (repeatVec : V ‚Üí V ‚Üí V) := repeatVec_defined.to_definable

instance repeatVec_definable' (Œì) : Œì-[m + 1]-Function‚ÇÇ (repeatVec : V ‚Üí V ‚Üí V) := repeatVec_definable.of_sigmaOne

end

@[simp] lemma len_repeatVec (x k : V) : len (repeatVec x k) = k := by
  induction k using induction_sigma1
  ¬∑ definability
  case zero => simp
  case succ k ih => simp [ih]

@[simp] lemma le_repaetVec (x k : V) : k ‚â§ repeatVec x k := by
  simpa using len_le (repeatVec x k)

lemma nth_repeatVec (x k : V) {i} (h : i < k) : (repeatVec x k).[i] = x := by
  induction k using induction_sigma1 generalizing i
  ¬∑ definability
  case zero => simp at h
  case succ k ih =>
    rcases zero_or_succ i with (rfl | ‚ü®i, rfl‚ü©)
    ¬∑ simp
    ¬∑ simpa using ih (by simpa using h)

lemma len_repeatVec_of_nth_le {v m : V} (H : ‚àÄ i < len v, v.[i] ‚â§ m) : v ‚â§ repeatVec m (len v) :=
  le_of_nth_le_nth (by simp) (fun i hi ‚Ü¶ by simp [nth_repeatVec m (len v) hi, H i hi])

end repaetVec

/-!

### Convert to Set

-/

namespace VecToSet

def blueprint : VecRec.Blueprint 0 where
  nil := .mkSigma ‚Äúy. y = 0‚Äù (by simp)
  cons := .mkSigma ‚Äúy x xs ih. !insertDef y x ih‚Äù (by simp)

def construction : VecRec.Construction V blueprint where
  nil _ := ‚àÖ
  cons (_ x _ ih) := insert x ih
  nil_defined := by intro v; simp [blueprint, emptyset_def]
  cons_defined := by intro v; simp [blueprint]

end VecToSet

section vecToSet

open VecToSet

def vecToSet (v : V) : V := construction.result ![] v

@[simp] lemma vecToSet_nil : vecToSet (0 : V) = ‚àÖ := by simp [vecToSet, construction]

@[simp] lemma vecToSet_cons (x v : V) :
    vecToSet (x ‚à∑ v) = insert x (vecToSet v) := by simp [vecToSet, construction]

section

def _root_.LO.FirstOrder.Arith.vecToSetDef : ùö∫‚ÇÅ.Semisentence 2 := blueprint.resultDef

lemma vecToSet_defined : ùö∫‚ÇÅ-Function‚ÇÅ (vecToSet : V ‚Üí V) via vecToSetDef := construction.result_defined

@[simp] lemma eval_vecToSetDef (v) :
    Semiformula.Evalbm V v vecToSetDef.val ‚Üî v 0 = vecToSet (v 1) := vecToSet_defined.df.iff v

instance vecToSet_definable : ùö∫‚ÇÅ-Function‚ÇÅ (vecToSet : V ‚Üí V) := vecToSet_defined.to_definable

instance vecToSet_definable' (Œì) : Œì-[m + 1]-Function‚ÇÅ (vecToSet : V ‚Üí V) := vecToSet_definable.of_sigmaOne

end

lemma mem_vecToSet_iff {v x : V} : x ‚àà vecToSet v ‚Üî ‚àÉ i < len v, x = v.[i] := by
  induction v using cons_induction_sigma1
  ¬∑ definability
  case nil => simp
  case cons y v ih =>
    simp only [vecToSet_cons, mem_bitInsert_iff, ih, len_cons]
    constructor
    ¬∑ rintro (rfl | ‚ü®i, hi, rfl‚ü©)
      ¬∑ exact ‚ü®0, by simp‚ü©
      ¬∑ exact ‚ü®i + 1, by simp [hi]‚ü©
    ¬∑ rintro ‚ü®i, hi, rfl‚ü©
      rcases zero_or_succ i with (rfl | ‚ü®i, rfl‚ü©)
      ¬∑ simp
      ¬∑ right; exact ‚ü®i, by simpa using hi, by simp‚ü©

@[simp] lemma nth_mem_vecToSet {v i : V} (h : i < len v) : v.[i] ‚àà vecToSet v :=
  mem_vecToSet_iff.mpr ‚ü®i, h, rfl‚ü©

end vecToSet

end LO.Arith
