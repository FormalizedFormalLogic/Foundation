import Arithmetization.Basic.Ind
import Mathlib.Logic.Nonempty

namespace LO.Arith

open FirstOrder FirstOrder.Arith

noncomputable section

variable {V : Type*} [ORingStruc V]

section IOpen

variable [V ‚äß‚Çò* ùêàopen]

@[elab_as_elim]
lemma open_induction {P : V ‚Üí Prop}
    (hP : ‚àÉ p : Semiformula ‚Ñí‚Çí·µ£ V 1, p.Open ‚àß ‚àÄ x, P x ‚Üî Semiformula.Evalm V ![x] id p)
    (zero : P 0) (succ : ‚àÄ x, P x ‚Üí P (x + 1)) : ‚àÄ x, P x :=
  induction (C := Semiformula.Open)
    (by rcases hP with ‚ü®p, hp, hhp‚ü©
        haveI : Inhabited V := Classical.inhabited_of_nonempty'
        exact ‚ü®p.fvarEnumInv, Rew.rewriteMap p.fvarEnum ‚ñπ p, by simp[hp],
          by  intro x; simp [Semiformula.eval_rewriteMap, hhp]
              exact Semiformula.eval_iff_of_funEqOn p (by
                intro z hz
                simp [Semiformula.fvarEnumInv_fvarEnum (Semiformula.mem_fvarList_iff_fvar?.mpr hz)])‚ü©) zero succ

lemma open_leastNumber {P : V ‚Üí Prop}
    (hP : ‚àÉ p : Semiformula ‚Ñí‚Çí·µ£ V 1, p.Open ‚àß ‚àÄ x, P x ‚Üî Semiformula.Evalm V ![x] id p)
    (zero : P 0) {a} (counterex : ¬¨P a) : ‚àÉ x, P x ‚àß ¬¨P (x + 1) := by
  by_contra A
  have : ‚àÄ x, P x := by
    intro x; induction x using open_induction
    ¬∑ exact hP
    case zero => exact zero
    case succ n ih =>
      simp at A
      exact A n ih
  have : P a := this a
  contradiction

lemma div_exists_unique_pos (a : V) {b} (pos : 0 < b) : ‚àÉ! u, b * u ‚â§ a ‚àß a < b * (u + 1) := by
  have : ‚àÉ u, b * u ‚â§ a ‚àß a < b * (u + 1) := by
    have : a < b * (a + 1) ‚Üí ‚àÉ u, b * u ‚â§ a ‚àß a < b * (u + 1) := by
      simpa using open_leastNumber (P := fun u ‚Ü¶ b * u ‚â§ a) ‚ü®‚Äúx. &b * x ‚â§ &a‚Äù, by simp, by intro x; simp‚ü©
    simp at this
    have hx : a < b * (a + 1) := by
      have : a + 0 < b * a + b :=
        add_lt_add_of_le_of_lt (le_mul_self_of_pos_left pos) pos
      simpa [mul_add] using this
    exact this hx
  rcases this with ‚ü®u, hu‚ü©
  exact ExistsUnique.intro u hu (by
    intro u' hu'
    by_contra ne
    wlog lt : u < u'
    ¬∑ exact this a pos u' hu' u hu (Ne.symm ne) (Ne.lt_of_le ne $ by simpa using lt)
    have : a < a := by calc
      a < b * (u + 1) := hu.2
      _ ‚â§ b * u'      := (_root_.mul_le_mul_left pos).mpr (lt_iff_succ_le.mp lt)
      _ ‚â§ a           := hu'.1
    exact LT.lt.false this)

section div

lemma div_exists_unique (a b : V) : ‚àÉ! u, (0 < b ‚Üí b * u ‚â§ a ‚àß a < b * (u + 1)) ‚àß (b = 0 ‚Üí u = 0) := by
  have : 0 ‚â§ b := by exact zero_le b
  rcases this with (rfl | pos) <;> simp [*]
  ¬∑ simpa [pos_iff_ne_zero.mp pos] using div_exists_unique_pos a pos

scoped instance : Div V := ‚ü®fun a b ‚Ü¶ Classical.choose! (div_exists_unique a b)‚ü©

lemma mul_div_le_pos (a : V) (h : 0 < b) : b * (a / b) ‚â§ a := ((Classical.choose!_spec (div_exists_unique a b)).1 h).1

lemma lt_mul_div_succ (a : V) (h : 0 < b) : a < b * (a / b + 1) := ((Classical.choose!_spec (div_exists_unique a b)).1 h).2

lemma eq_mul_div_add_of_pos (a : V) {b} (hb : 0 < b) : ‚àÉ r < b, a = b * (a / b) + r := by
  let r := a - b * (a / b)
  have e : a = b * (a / b) + r := by simp [r, add_tsub_self_of_le (mul_div_le_pos a hb)]
  exact ‚ü®r, by
    by_contra A
    have hyv : b ‚â§ r := by simpa using A
    have : a < a := by calc
          a < b * (a / b + 1) := lt_mul_div_succ a hb
          _ ‚â§ b * (a / b) + r := by simpa [mul_add] using hyv
          _ = a               := e.symm
    simp at this, e‚ü©

@[simp] lemma div_spec_zero (a : V) : a / 0 = 0 := (Classical.choose!_spec (div_exists_unique a 0)).2 (by simp)

lemma div_graph {a b c : V} : c = a / b ‚Üî ((0 < b ‚Üí b * c ‚â§ a ‚àß a < b * (c + 1)) ‚àß (b = 0 ‚Üí c = 0)) :=
  Classical.choose!_eq_iff _

def _root_.LO.FirstOrder.Arith.divDef : ùö∫‚ÇÄ.Semisentence 3 :=
  .mkSigma ‚Äúc a b. (0 < b ‚Üí b * c ‚â§ a ‚àß a < b * (c + 1)) ‚àß (b = 0 ‚Üí c = 0)‚Äù (by simp[Hierarchy.pi_zero_iff_sigma_zero])

lemma div_defined : ùö∫‚ÇÄ-Function‚ÇÇ ((¬∑ / ¬∑) : V ‚Üí V ‚Üí V) via divDef := by
  intro v; simp[div_graph, divDef, Matrix.vecHead, Matrix.vecTail]

@[simp] lemma div_defined_iff (v) :
    Semiformula.Evalbm V v divDef.val ‚Üî v 0 = v 1 / v 2 := div_defined.df.iff v

lemma div_spec_of_pos' (a : V) (h : 0 < b) : ‚àÉ v < b, a = (a / b) * b + v := by
  simpa [mul_comm] using eq_mul_div_add_of_pos a h

lemma div_eq_of {b : V} (hb : b * c ‚â§ a) (ha : a < b * (c + 1)) : a / b = c := by
  have pos : 0 < b := pos_of_mul_pos_left (pos_of_gt ha) (by simp)
  exact (div_exists_unique_pos a pos).unique ‚ü®mul_div_le_pos a pos, lt_mul_div_succ a pos‚ü© ‚ü®hb, ha‚ü©

lemma div_mul_add (a b : V) {r} (hr : r < b) : (a * b + r) / b = a :=
  div_eq_of (by simp [mul_comm]) (by simp [mul_comm b a, mul_add, hr])

lemma div_mul_add' (a b : V) {r} (hr : r < b) : (b * a + r) / b = a := by simpa [mul_comm] using div_mul_add a b hr

@[simp] lemma zero_div (a : V) : 0 / a = 0 := by
  rcases zero_le a with (rfl | pos)
  ¬∑ simp
  ¬∑ exact div_eq_of (by simp) (by simpa)

lemma div_mul (a b c : V) : a / (b * c) = a / b / c := by
  rcases zero_le b with (rfl | hb)
  ¬∑ simp
  rcases zero_le c with (rfl | hc)
  ¬∑ simp
  exact div_eq_of
    (by calc
          b * c * (a / b / c) ‚â§ b * (a / b) := by simp [mul_assoc]; exact mul_le_mul_left (mul_div_le_pos (a / b) hc)
          _                   ‚â§ a := mul_div_le_pos a hb)
    (by calc
          a < b * (a / b + 1)         := lt_mul_div_succ a hb
          _ ‚â§ b * c * (a / b / c + 1) := by simp [mul_assoc]; exact mul_le_mul_left (lt_iff_succ_le.mp <| lt_mul_div_succ (a / b) hc))

@[simp] lemma mul_div_le (a b : V) : b * (a / b) ‚â§ a := by
  have : 0 ‚â§ b := by exact zero_le b
  rcases this with (rfl | pos) <;> simp [*]
  rcases eq_mul_div_add_of_pos a pos with ‚ü®v, _, e‚ü©
  simpa [‚Üê e] using show b * (a / b) ‚â§ b * (a / b) + v from le_self_add

@[simp] lemma div_le (a b : V) : a / b ‚â§ a := by
  have : 0 ‚â§ b := zero_le b
  rcases this with (rfl | pos) <;> simp [*]
  have : 1 * (a / b) ‚â§ b * (a / b) := mul_le_mul_of_nonneg_right (le_iff_lt_succ.mpr (by simp[pos])) (by simp)
  simpa using le_trans this (mul_div_le a b)

instance div_polybounded : Bounded‚ÇÇ ((¬∑ / ¬∑) : V ‚Üí V ‚Üí V) := ‚ü®#0, Œª _ ‚Ü¶ by simp‚ü©

instance div_definable : ùö∫‚ÇÄ-Function‚ÇÇ ((¬∑ / ¬∑) : V ‚Üí V ‚Üí V) := div_defined.to_definable _

@[simp] lemma div_mul_le (a b : V) : a / b * b ‚â§ a := by rw [mul_comm]; exact mul_div_le _ _

lemma lt_mul_div (a : V) {b} (pos : 0 < b) : a < b * (a / b + 1) := by
  rcases eq_mul_div_add_of_pos a pos with ‚ü®v, hv, e‚ü©
  calc a = b * (a / b) + v := e
       _ < b * (a / b + 1) := by simp [mul_add, hv]

@[simp] lemma div_one (a : V) : a / 1 = a :=
  le_antisymm (by simp) (le_iff_lt_succ.mpr $ by simpa using lt_mul_div a one_pos)

lemma div_add_mul_self (a c : V) {b} (pos : 0 < b) : (a + c * b) / b = a / b + c := by
  rcases div_spec_of_pos' a pos with ‚ü®r, hr, ex‚ü©
  simpa [add_mul, add_right_comm, ‚Üê ex] using div_mul_add (a / b + c) _ hr

lemma div_add_mul_self' (a c : V) {b} (pos : 0 < b) : (a + b * c) / b = a / b + c := by
  simpa [mul_comm] using div_add_mul_self a c pos

lemma div_mul_add_self (a c : V) {b} (pos : 0 < b) : (a * b + c) / b = a + c / b := by
  simp [div_add_mul_self, pos, add_comm]

lemma div_mul_add_self' (a c : V) {b} (pos : 0 < b) : (b * a + c) / b = a + c / b := by
  simp [mul_comm b a, div_mul_add_self, pos]

@[simp] lemma div_mul_left (a : V) {b} (pos : 0 < b) : (a * b) / b = a := by
  simpa using div_mul_add a _ pos

@[simp] lemma div_mul_right (a : V) {b} (pos : 0 < b) : (b * a) / b = a := by
  simpa [mul_comm] using div_mul_add a _ pos

@[simp] lemma div_eq_zero_of_lt (b : V) {a} (h : a < b) : a / b = 0 := by
  simpa using div_mul_add 0 b h

@[simp] lemma div_sq (a : V) : a^2 / a = a := by
  rcases zero_le a with (rfl | pos)
  ¬∑ simp
  ¬∑ simp [sq, pos]

@[simp] lemma div_self {a : V} (hx : 0 < a) : a / a = 1 := by
  simpa using div_mul_left 1 hx

@[simp] lemma div_mul' (a : V) {b} (pos : 0 < b) : (b * a) / b = a := by simp [mul_comm, pos]

@[simp] lemma div_add_self_left {a} (pos : 0 < a) (b : V) : (a + b) / a = 1 + b / a := by
  simpa using div_mul_add_self 1 b pos

@[simp] lemma div_add_self_right (a : V) {b} (pos : 0 < b) : (a + b) / b = a / b + 1 := by
  simpa using div_add_mul_self a 1 pos

lemma mul_div_self_of_dvd {a b : V} : a * (b / a) = b ‚Üî a ‚à£ b := by
  rcases zero_le a with (rfl | pos)
  ¬∑ simp[eq_comm]
  ¬∑ constructor
    ¬∑ intro e; rw [‚Üêe]; simp
    ¬∑ rintro ‚ü®r, rfl‚ü©; simp [pos]

lemma div_lt_of_pos_of_one_lt {a b : V} (ha : 0 < a) (hb : 1 < b) : a / b < a := by
  rcases zero_le (a / b) with (e | lt)
  ¬∑ simp [‚Üêe, ha]
  ¬∑ exact lt_of_lt_of_le (lt_mul_of_one_lt_left lt hb) (mul_div_le a b)

lemma le_two_mul_div_two_add_one (a : V) : a ‚â§ 2 * (a / 2) + 1 := by
  have : a < 2 * (a / 2 + 1) := lt_mul_div_succ a (show 0 < 2 from by simp)
  exact le_iff_lt_succ.mpr (by simpa [add_assoc, one_add_one_eq_two, mul_add] using this)

lemma div_monotone {a b : V} (h : a ‚â§ b) (c : V) : a / c ‚â§ b / c := by
  rcases zero_le c with (rfl | pos)
  ¬∑ simp
  by_contra A
  have : b / c + 1 ‚â§ a / c := succ_le_iff_lt.mpr (by simpa using A)
  have : a < a := calc
    a ‚â§ b               := h
    _ < c * (b / c + 1) := lt_mul_div b pos
    _ ‚â§ c * (a / c)     := mul_le_mul_left this
    _ ‚â§ a               := mul_div_le a c
  simp_all

lemma div_lt_of_lt_mul {a b c : V} (h : a < b * c) : a / c < b := by
  by_contra hb
  simp at hb
  have : a < a := calc
    a < b * c     := h
    _ ‚â§ a / c * c := mul_le_mul_right hb
    _ ‚â§ a         := by simp
  simp_all

lemma div_cancel_left {c} (pos : 0 < c) (a b : V) : (c * a) / (c * b) = a / b := by simp [div_mul, pos]

lemma div_cancel_right {c} (pos : 0 < c) (a b : V) : (a * c) / (b * c) = a / b := by simp [mul_comm _ c, div_cancel_left pos]

@[simp] lemma two_mul_add_one_div_two (a : V) : (2 * a + 1) / 2 = a := by simp [div_mul_add_self', one_lt_two]

end div

section mod

def rem (a b : V) : V := a - b * (a / b)

scoped instance : Mod V := ‚ü®rem‚ü©

lemma mod_def (a b : V) : a % b = a - b * (a / b) := rfl

def _root_.LO.FirstOrder.Arith.remDef : ùö∫‚ÇÄ.Semisentence 3 :=
  .mkSigma ‚Äúc a b. ‚àÉ d <‚Å∫ a, !divDef.val d a b ‚àß !subDef.val c a (b * d)‚Äù (by simp)

lemma rem_graph (a b c : V) : a = b % c ‚Üî ‚àÉ x ‚â§ b, (x = b / c ‚àß a = b - c * x) := by
  simp [mod_def]; constructor
  ¬∑ rintro rfl; exact ‚ü®b / c, by simp, rfl, by rfl‚ü©
  ¬∑ rintro ‚ü®_, _, rfl, rfl‚ü©; simp

lemma rem_defined : ùö∫‚ÇÄ-Function‚ÇÇ ((¬∑ % ¬∑) : V ‚Üí V ‚Üí V) via remDef := by
  intro v; simp [Matrix.vecHead, Matrix.vecTail, remDef, rem_graph, Semiformula.eval_substs, le_iff_lt_succ]

@[simp] lemma rem_defined_iff (v) :
    Semiformula.Evalbm V v remDef.val ‚Üî v 0 = v 1 % v 2 := rem_defined.df.iff v

instance rem_definable : ùö∫‚ÇÄ-Function‚ÇÇ ((¬∑ % ¬∑) : V ‚Üí V ‚Üí V) := rem_defined.to_definable _

lemma div_add_mod (a b : V) : b * (a / b) + (a % b) = a :=
  add_tsub_self_of_le (mul_div_le a b)

@[simp] lemma mod_zero (a : V) : a % 0 = a := by simp [mod_def]

@[simp] lemma zero_mod (a : V) : 0 % a = 0 := by simp [mod_def]

@[simp] lemma mod_self (a : V) : a % a = 0 := by
  rcases zero_le a with (rfl | h)
  ¬∑ simp
  ¬∑ simp [mod_def, h]

lemma mod_mul_add_of_lt (a b : V) {r} (hr : r < b) : (a * b + r) % b = r := by
  simp [mod_def, div_mul_add a b hr, mul_comm]

@[simp] lemma mod_mul_add (a c : V) (pos : 0 < b) : (a * b + c) % b = c % b := by
  simp [mod_def, div_mul_add_self, pos, mul_add, ‚Üêsub_sub, show b * a = a * b from mul_comm _ _]

@[simp] lemma mod_add_mul (a b : V) (pos : 0 < c) : (a + b * c) % c = a % c := by
  simp [add_comm a (b * c), pos]

@[simp] lemma mod_add_mul' (a b : V) (pos : 0 < c) : (a + c * b) % c = a % c := by
  simp [mul_comm c b, pos]

@[simp] lemma mod_mul_add' (a c : V) (pos : 0 < b) : (b * a + c) % b = c % b := by
  simp [mul_comm b a, pos]

@[simp] lemma mod_mul_self_left (a b : V) : (a * b) % b = 0 := by
  rcases zero_le b with (rfl | h)
  ¬∑ simp
  ¬∑ simpa using mod_mul_add_of_lt a b h

@[simp] lemma mod_mul_self_right (a b : V) : (b * a) % b = 0 := by
  simp [mul_comm]

@[simp] lemma mod_eq_self_of_lt {a b : V} (h : a < b) : a % b = a := by
  simpa using mod_mul_add_of_lt 0 b h

@[simp] lemma mod_lt (a : V) {b} (pos : 0 < b) : a % b < b := by
  rcases div_spec_of_pos' a pos with ‚ü®r, hr, ha‚ü©
  have : ((a / b) * b + r) % b = r := mod_mul_add_of_lt _ _ hr
  have : a % b = r := by simpa [‚Üêha] using this
  simp [this, hr]

@[simp] lemma mod_le (a b : V) : a % b ‚â§ a := by
  simp [mod_def]

instance mod_polybounded : Bounded‚ÇÇ ((¬∑ % ¬∑) : V ‚Üí V ‚Üí V) := ‚ü®#0, by intro v; simp‚ü©

lemma mod_eq_zero_iff_dvd {a b : V} : b % a = 0 ‚Üî a ‚à£ b := by
  simp [mod_def]
  constructor
  ¬∑ intro H; exact mul_div_self_of_dvd.mp (le_antisymm (mul_div_le b a) H)
  ¬∑ intro H; simp [mul_div_self_of_dvd.mpr H]

@[simp] lemma mod_add_remove_right {a b : V} (pos : 0 < b) : (a + b) % b = a % b := by
  simpa using mod_add_mul a 1 pos

lemma mod_add_remove_right_of_dvd {a b m : V} (h : m ‚à£ b) (pos : 0 < m) : (a + b) % m = a % m := by
  rcases h with ‚ü®b, rfl‚ü©; simp [pos]

@[simp] lemma mod_add_remove_left {a b : V} (pos : 0 < a) : (a + b) % a = b % a := by
  simpa using mod_mul_add 1 b pos

lemma mod_add_remove_left_of_dvd {a b m : V} (h : m ‚à£ a) (pos : 0 < m) : (a + b) % m = b % m := by
  rcases h with ‚ü®b, rfl‚ü©; simp [pos]

lemma mod_add {a b m : V} (pos : 0 < m) : (a + b) % m = (a % m + b % m) % m := calc
  (a + b) % m = ((m * (a / m) + a % m) + (m * (b / m) + b % m)) % m := by simp [div_add_mod]
  _           = (m * (a / m) + m * (b / m) + (a % m) + (b % m)) % m := by simp [‚Üêadd_assoc, add_right_comm]
  _           = (a % m + b % m) % m                                 := by simp [add_assoc, pos]

lemma mod_mul {a b m : V} (pos : 0 < m) : (a * b) % m = ((a % m) * (b % m)) % m := calc
  (a * b) % m = ((m * (a / m) + (a % m)) * (m * (b / m) + b % m)) % m := by simp [div_add_mod]
  _           = ((a % m) * (b % m)) % m                               := by simp [add_mul, mul_add, pos, mul_left_comm _ m, add_assoc, mul_assoc]

@[simp] lemma mod_div (a b : V) : a % b / b = 0 := by
  rcases zero_le b with (rfl | pos)
  ¬∑ simp
  ¬∑ exact div_eq_zero_of_lt b (by simp [pos])

@[simp] lemma mod_one (a : V) : a % 1 = 0 := lt_one_iff_eq_zero.mp <| mod_lt a (by simp)

lemma mod_two (a : V) : a % 2 = 0 ‚à® a % 2 = 1 :=
  le_one_iff_eq_zero_or_one.mp <| lt_two_iff_le_one.mp <| mod_lt a (b := 2) (by simp)

@[simp] lemma mod_two_not_zero_iff {a : V} : ¬¨a % 2 = 0 ‚Üî a % 2 = 1 := by
  rcases mod_two a with (h | h) <;> simp [*]

@[simp] lemma mod_two_not_one_iff {a : V} : ¬¨a % 2 = 1 ‚Üî a % 2 = 0 := by
  rcases mod_two a with (h | h) <;> simp [*]

end mod

lemma two_dvd_mul {a b : V} : 2 ‚à£ a * b ‚Üí 2 ‚à£ a ‚à® 2 ‚à£ b := by
  intro H; by_contra A
  simp [not_or] at A
  have ha : a % 2 = 1 := by
    have : a % 2 = 0 ‚à® a % 2 = 1 := mod_two a
    simpa [show a % 2 ‚â† 0 from by simpa [‚Üêmod_eq_zero_iff_dvd] using A.1] using this
  have hb : b % 2 = 1 := by
    have : b % 2 = 0 ‚à® b % 2 = 1 :=
      le_one_iff_eq_zero_or_one.mp <| lt_two_iff_le_one.mp <| mod_lt b (b := 2) (by simp)
    simpa [show b % 2 ‚â† 0 from by simpa [‚Üêmod_eq_zero_iff_dvd] using A.2] using this
  have : a * b % 2 = 1 := by simp [mod_mul, ha, hb]
  have : ¬¨2 ‚à£ a * b := by simp [‚Üêmod_eq_zero_iff_dvd, this]
  contradiction

lemma even_or_odd (a : V) : ‚àÉ x, a = 2 * x ‚à® a = 2 * x + 1 :=
  ‚ü®a / 2, by
    have : 2 * (a / 2) + (a % 2) = a := div_add_mod a 2
    rcases mod_two a with (e | e) <;> { simp[e] at this; simp [this] }‚ü©

lemma even_or_odd' (a : V) : a = 2 * (a / 2) ‚à® a = 2 * (a / 2) + 1 := by
  have : 2 * (a / 2) + (a % 2) = a := div_add_mod a 2
  rcases mod_two a with (e | e) <;>  simp [e] at this <;> simp [*]

lemma two_prime : Prime (2 : V) := ‚ü®by simp, by simp, by intro a b h; exact two_dvd_mul h‚ü©

section sqrt

lemma sqrt_exists_unique (a : V) : ‚àÉ! x, x * x ‚â§ a ‚àß a < (x + 1) * (x + 1) := by
  have : ‚àÉ x, x * x ‚â§ a ‚àß a < (x + 1) * (x + 1) := by
    have : a < (a + 1) * (a + 1) ‚Üí ‚àÉ x, x * x ‚â§ a ‚àß a < (x + 1) * (x + 1) := by
      simpa using open_leastNumber (P := Œª x ‚Ü¶ x * x ‚â§ a) ‚ü®‚Äúx. x * x ‚â§ &a‚Äù, by simp, by simp‚ü©
    have hn : a < (a + 1) * (a + 1) := calc
      a ‚â§ a * a             := le_mul_self a
      _ < a * a + 1         := lt_add_one (a * a)
      _ ‚â§ (a + 1) * (a + 1) := by simp [add_mul_self_eq]
    exact this hn
  rcases this with ‚ü®x, hx‚ü©
  exact ExistsUnique.intro x hx (by
    intro y hy
    by_contra ne
    wlog lt : x < y
    ¬∑ exact this a y hy x hx (Ne.symm ne) (Ne.lt_of_le ne $ by simpa using lt)
    have : a < a := calc
      a < (x + 1) * (x + 1) := hx.2
      _ ‚â§ y * y             := mul_self_le_mul_self (by simp) (lt_iff_succ_le.mp lt)
      _ ‚â§ a                 := hy.1
    simp at this)

def sqrt (a : V) : V := Classical.choose! (sqrt_exists_unique a)

prefix:75 "‚àö" => sqrt

@[simp] lemma sqrt_spec_le (a : V) : ‚àöa * ‚àöa ‚â§ a := (Classical.choose!_spec (sqrt_exists_unique a)).1

@[simp] lemma sqrt_spec_lt (a : V) : a < (‚àöa + 1) * (‚àöa + 1) := (Classical.choose!_spec (sqrt_exists_unique a)).2

lemma sqrt_graph {a b : V} : b = ‚àöa ‚Üî b * b ‚â§ a ‚àß a < (b + 1) * (b + 1) := Classical.choose!_eq_iff _

def _root_.LO.FirstOrder.Arith.sqrtDef : ùö∫‚ÇÄ.Semisentence 2 :=
  .mkSigma ‚Äúb a. b * b ‚â§ a ‚àß a < (b + 1) * (b + 1)‚Äù (by simp[Hierarchy.pi_zero_iff_sigma_zero])

lemma sqrt_defined : ùö∫‚ÇÄ-Function‚ÇÅ (Œª a : V ‚Ü¶ ‚àöa) via sqrtDef := by
  intro v; simp[sqrt_graph, sqrtDef, Matrix.vecHead, Matrix.vecTail]

@[simp] lemma sqrt_defined_iff (v) :
    Semiformula.Evalbm V v sqrtDef.val ‚Üî v 0 = ‚àö(v 1) := sqrt_defined.df.iff v

instance sqrt_definable : ùö∫‚ÇÄ-Function‚ÇÅ ((‚àö¬∑) : V ‚Üí V) := sqrt_defined.to_definable

lemma eq_sqrt (x a : V) : x * x ‚â§ a ‚àß a < (x + 1) * (x + 1) ‚Üí x = ‚àöa := Classical.choose_uniq (sqrt_exists_unique a)

lemma sqrt_eq_of_le_of_lt {x a : V} (le : x * x ‚â§ a) (lt : a < (x + 1) * (x + 1)) : ‚àöa = x :=
  Eq.symm <| eq_sqrt x a ‚ü®le, lt‚ü©

lemma sqrt_eq_of_le_of_le {x a : V} (le : x * x ‚â§ a) (h : a ‚â§ x * x + 2 * x) : ‚àöa = x :=
  sqrt_eq_of_le_of_lt le (by simp [add_mul_self_eq]; exact le_iff_lt_succ.mp h)

@[simp] lemma sq_sqrt_le (a : V) : (‚àöa) ^ 2 ‚â§ a := by simp [sq]

@[simp] lemma sqrt_lt_sq (a : V) : a < (‚àöa + 1) ^ 2 := by simp [sq]

@[simp] lemma sqrt_mul_self (a : V) : ‚àö(a * a) = a :=
  Eq.symm <| eq_sqrt a (a * a) (by simp; exact mul_self_lt_mul_self (by simp) (by simp))

@[simp] lemma sqrt_sq (a : V) : ‚àö(a^2) = a := by simp [sq]

@[simp] lemma sqrt_zero : ‚àö(0 : V) = 0 := by simpa using sqrt_mul_self (0 : V)

@[simp] lemma sqrt_one : ‚àö(1 : V) = 1 := by simpa using sqrt_mul_self (1 : V)

lemma sqrt_two : ‚àö(2 : V) = 1 :=
  Eq.symm <| eq_sqrt 1 2 (by simp [one_le_two, one_add_one_eq_two, one_lt_two])

lemma sqrt_three : ‚àö(3 : V) = 1 :=
  Eq.symm <| eq_sqrt 1 3 <| by simp [one_add_one_eq_two, two_mul_two_eq_four, ‚Üêthree_add_one_eq_four]

@[simp] lemma sqrt_four : ‚àö(4 : V) = 2 := by
  simp [‚Üêtwo_mul_two_eq_four]

@[simp] lemma two_ne_square (a : V) : 2 ‚â† a^2 := by
  intro h
  rcases show a = ‚àö2 from by rw [h]; simp with rfl
  simp [sqrt_two] at h

@[simp] lemma sqrt_le_add (a : V) : a ‚â§ ‚àöa * ‚àöa + 2 * ‚àöa :=
  le_iff_lt_succ.mpr (by have := sqrt_spec_lt a; rw [add_mul_self_eq] at this; simpa using this)

@[simp] lemma sqrt_le_self (a : V) : ‚àöa ‚â§ a := by
  by_contra A
  have : a < a := calc
    a ‚â§ a^2    := le_sq a
    _ < (‚àöa)^2 := by simpa [sq] using mul_self_lt_mul_self (by simp) (by simpa using A)
    _ ‚â§ a      := sq_sqrt_le a
  simp_all

instance : Bounded‚ÇÅ ((‚àö¬∑) : V ‚Üí V) := ‚ü®#0, by intro v; simp‚ü©

lemma sqrt_lt_self_of_one_lt {a : V} (h : 1 < a) : ‚àöa < a := by
  by_contra A
  have : a * a ‚â§ ‚àöa * ‚àöa := mul_self_le_mul_self (by simp) (by simpa using A)
  have : a * a ‚â§ a := le_trans this (sqrt_spec_le a)
  exact not_lt.mpr this (lt_mul_self h)

lemma sqrt_le_of_le_sq {a b : V} : a ‚â§ b^2 ‚Üí ‚àöa ‚â§ b := by
  intro h; by_contra A
  have : a < a := calc
    a ‚â§ b^2    := h
    _ < (‚àöa)^2 := sq_lt_sq.mpr (by simpa using A)
    _ ‚â§ a      := by simp
  simp_all

lemma sq_lt_of_lt_sqrt {a b : V} : a < ‚àöb ‚Üí a^2 < b := by
  intro h; by_contra A
  exact not_le.mpr h (sqrt_le_of_le_sq $ show b ‚â§ a^2 from by simpa using A)

end sqrt

section pair

open Classical

-- https://github.com/leanprover-community/mathlib4/blob/b075cdd0e6ad8b5a3295e7484b2ae59e9b2ec2a7/Mathlib/Data/Nat/Pairing.lean#L37
def pair (a b : V) : V := if a < b then b * b + a else a * a + a + b

--notation "‚ü™" a ", " b "‚ü´" => pair a b

/-- `!‚ü™x, y, z, ...‚ü´` notation for `Seq` -/
syntax "‚ü™" term,* "‚ü´" : term

macro_rules
  | `(‚ü™$term:term, $terms:term,*‚ü´) => `(pair $term ‚ü™$terms,*‚ü´)
  | `(‚ü™$term:term‚ü´) => `($term)

@[app_unexpander pair]
def pairUnexpander : Lean.PrettyPrinter.Unexpander
  | `($_ $term $term2) => `(‚ü™$term, $term2‚ü´)
  | _ => throw ()

lemma pair_graph {a b c : V} :
    c = ‚ü™a, b‚ü´ ‚Üî (a < b ‚àß c = b * b + a) ‚à® (b ‚â§ a ‚àß c = a * a + a + b) := by
  simp [pair]
  by_cases h : a < b
  ¬∑ simp [h, show ¬¨b ‚â§ a from by simpa using h]
  ¬∑ simp [h, show b ‚â§ a from by simpa using h]

def _root_.LO.FirstOrder.Arith.pairDef : ùö∫‚ÇÄ.Semisentence 3 :=
  .mkSigma ‚Äúc a b. (a < b ‚àß c = b * b + a) ‚à® (b ‚â§ a ‚àß c = a * a + a + b)‚Äù (by simp)

lemma pair_defined : ùö∫‚ÇÄ-Function‚ÇÇ (Œª a b : V ‚Ü¶ ‚ü™a, b‚ü´) via pairDef := by
  intro v; simp [pair_graph, pairDef]

@[simp] lemma pair_defined_iff (v) :
    Semiformula.Evalbm V v pairDef.val ‚Üî v 0 = ‚ü™v 1, v 2‚ü´ := pair_defined.df.iff v

instance pair_definable : ùö∫‚ÇÄ-Function‚ÇÇ (pair : V ‚Üí V ‚Üí V) := pair_defined.to_definable

instance : Bounded‚ÇÇ (pair : V ‚Üí V ‚Üí V) :=
  ‚ü®‚Äòx y. (y * y + x) + (x * x + x + y)‚Äô, by intro v; simp [pair]; split_ifs <;> try simp [pair, *]‚ü©

def unpair (a : V) : V √ó V := if a - ‚àöa * ‚àöa < ‚àöa then (a - ‚àöa * ‚àöa, ‚àöa) else (‚àöa, a - ‚àöa * ‚àöa - ‚àöa)

abbrev pi‚ÇÅ (a : V) : V := (unpair a).1

abbrev pi‚ÇÇ (a : V) : V := (unpair a).2

prefix: 80 "œÄ‚ÇÅ" => pi‚ÇÅ

prefix: 80 "œÄ‚ÇÇ" => pi‚ÇÇ

@[simp] lemma pair_unpair (a : V) : ‚ü™œÄ‚ÇÅ a, œÄ‚ÇÇ a‚ü´ = a := by
  simp [pi‚ÇÅ, pi‚ÇÇ, unpair]
  split_ifs with h
  ¬∑ simp [pair, h]
  ¬∑ simp; simp [pair, h]
    have : a - ‚àöa * ‚àöa - ‚àöa ‚â§ ‚àöa := by simp [add_comm (2 * ‚àöa), ‚Üêtwo_mul]
    simp [not_lt.mpr this]
    have :‚àöa ‚â§ a - ‚àöa * ‚àöa := by simpa using h
    calc
      ‚àöa * ‚àöa + ‚àöa + (a - ‚àöa * ‚àöa - ‚àöa) = ‚àöa * ‚àöa + (a - ‚àöa * ‚àöa) := by simp [add_assoc]
                                                                        rw [add_tsub_self_of_le, add_tsub_self_of_le] <;> simp [this]
      _                                 = a                       := add_tsub_self_of_le (by simp)

@[simp] lemma unpair_pair (a b : V) : unpair ‚ü™a, b‚ü´ = (a, b) := by
  simp [pair]; split_ifs with h
  ¬∑ have : ‚àö(b * b + a) = b := sqrt_eq_of_le_of_le (by simp) (by simp; exact le_trans (le_of_lt h) (by simp))
    simp [unpair, this, show ¬¨b ‚â§ a from by simpa using h]
  ¬∑ have : ‚àö(a * a + (a + b)) = a :=
      sqrt_eq_of_le_of_le (by simp [add_assoc]) (by simp [add_assoc, two_mul, show b ‚â§ a from by simpa using h])
    simp [unpair, this, add_assoc]

@[simp] lemma pi‚ÇÅ_pair (a b : V) : œÄ‚ÇÅ ‚ü™a, b‚ü´ = a := by simp [pi‚ÇÅ]

@[simp] lemma pi‚ÇÇ_pair (a b : V) : œÄ‚ÇÇ ‚ü™a, b‚ü´ = b := by simp [pi‚ÇÇ]

def pairEquiv : V √ó V ‚âÉ V := ‚ü®Function.uncurry pair, unpair, fun ‚ü®a, b‚ü© => unpair_pair a b, pair_unpair‚ü©

@[simp] lemma pi‚ÇÅ_le_self (a : V) : œÄ‚ÇÅ a ‚â§ a := by simp [pi‚ÇÅ, unpair]; split_ifs <;> simp

@[simp] lemma pi‚ÇÇ_le_self (a : V) : œÄ‚ÇÇ a ‚â§ a := by simp [pi‚ÇÇ, unpair]; split_ifs <;> simp [add_assoc]

@[simp] lemma le_pair_left (a b : V) : a ‚â§ ‚ü™a, b‚ü´ := by simpa using pi‚ÇÅ_le_self ‚ü™a, b‚ü´

@[simp] lemma le_pair_right (a b : V) : b ‚â§ ‚ü™a, b‚ü´ := by simpa using pi‚ÇÇ_le_self ‚ü™a, b‚ü´

@[simp] lemma lt_pair_left_of_pos {a} (pos : 0 < a) (b : V) : a < ‚ü™a, b‚ü´ := by
  simp [pair]; split_ifs
  ¬∑ simp; exact pos_iff_ne_zero.mp <| pos_of_gt (by assumption)
  ¬∑ calc
      a < a * a + a     := lt_add_of_pos_left a (by simpa using (pos_iff_ne_zero.mp pos))
      _ ‚â§ a * a + a + b := by simp

instance : Bounded‚ÇÅ (pi‚ÇÅ : V ‚Üí V) := ‚ü®#0, by intro v; simp‚ü©

instance : Bounded‚ÇÅ (pi‚ÇÇ : V ‚Üí V) := ‚ü®#0, by intro v; simp‚ü©

def _root_.LO.FirstOrder.Arith.pi‚ÇÅDef : ùö∫‚ÇÄ.Semisentence 2 :=
  .mkSigma ‚Äúx p. ‚àÉ y <‚Å∫ p, !pairDef p x y‚Äù (by simp)

def _root_.LO.FirstOrder.Arith.pi‚ÇÇDef : ùö∫‚ÇÄ.Semisentence 2 :=
  .mkSigma ‚Äúy p. ‚àÉ x <‚Å∫ p, !pairDef p x y‚Äù (by simp)

lemma pi‚ÇÅ_defined : ùö∫‚ÇÄ-Function‚ÇÅ (pi‚ÇÅ : V ‚Üí V) via pi‚ÇÅDef := by
  intro v; simp [pi‚ÇÅDef]
  constructor
  ¬∑ intro h; exact ‚ü®œÄ‚ÇÇ v 1, by simp [‚Üêle_iff_lt_succ],  by simp [h]‚ü©
  ¬∑ rintro ‚ü®a, _, e‚ü©; simp [show v 1 = ‚ü™v 0, a‚ü´ from e]

@[simp] lemma pi‚ÇÅ_defined_iff (v) :
    Semiformula.Evalbm V v pi‚ÇÅDef.val ‚Üî v 0 = œÄ‚ÇÅ (v 1) := pi‚ÇÅ_defined.df.iff v

instance pi‚ÇÅ_definable : ùö∫‚ÇÄ-Function‚ÇÅ (pi‚ÇÅ : V ‚Üí V) := pi‚ÇÅ_defined.to_definable‚ÇÄ

lemma pi‚ÇÇ_defined : ùö∫‚ÇÄ-Function‚ÇÅ (pi‚ÇÇ : V ‚Üí V) via pi‚ÇÇDef := by
  intro v; simp [pi‚ÇÇDef]
  constructor
  ¬∑ intro h; exact ‚ü®œÄ‚ÇÅ v 1, by simp [‚Üêle_iff_lt_succ], by simp [h]‚ü©
  ¬∑ rintro ‚ü®a, _, e‚ü©; simp [show v 1 = ‚ü™a, v 0‚ü´ from e]

@[simp] lemma pi‚ÇÇ_defined_iff (v) :
    Semiformula.Evalbm V v pi‚ÇÇDef.val ‚Üî v 0 = œÄ‚ÇÇ (v 1) := pi‚ÇÇ_defined.df.iff v

instance pi‚ÇÇ_definable : ùö∫‚ÇÄ-Function‚ÇÅ (pi‚ÇÇ : V ‚Üí V) := pi‚ÇÇ_defined.to_definable‚ÇÄ

lemma pair_lt_pair_left {a‚ÇÅ a‚ÇÇ : V} (h : a‚ÇÅ < a‚ÇÇ) (b) : ‚ü™a‚ÇÅ, b‚ü´ < ‚ü™a‚ÇÇ, b‚ü´ := by
  by_cases h‚ÇÅ : a‚ÇÅ < b <;> simp [pair, h‚ÇÅ]
  ¬∑ by_cases h‚ÇÇ : a‚ÇÇ < b <;> simp [pair, h‚ÇÇ, h]
    calc
      b * b + a‚ÇÅ < b * b + b        := by simpa using h‚ÇÅ
      _          ‚â§ a‚ÇÇ * a‚ÇÇ + a‚ÇÇ     := add_le_add (mul_le_mul (by simpa using h‚ÇÇ) (by simpa using h‚ÇÇ) (by simp) (by simp)) (by simpa using h‚ÇÇ)
      _          ‚â§ a‚ÇÇ * a‚ÇÇ + a‚ÇÇ + b := by simp
  ¬∑ simp[show ¬¨a‚ÇÇ < b from by simp; exact le_trans (by simpa using h‚ÇÅ) (le_of_lt h)]
    apply _root_.add_lt_add (by simpa [‚Üêsq] using h) h

lemma pair_le_pair_left {a‚ÇÅ a‚ÇÇ : V} (h : a‚ÇÅ ‚â§ a‚ÇÇ) (b) : ‚ü™a‚ÇÅ, b‚ü´ ‚â§ ‚ü™a‚ÇÇ, b‚ü´ := by
  rcases h with (rfl | lt)
  ¬∑ simp
  ¬∑ exact le_of_lt (pair_lt_pair_left lt b)

lemma pair_lt_pair_right (a : V) {b‚ÇÅ b‚ÇÇ} (h : b‚ÇÅ < b‚ÇÇ) : ‚ü™a, b‚ÇÅ‚ü´ < ‚ü™a, b‚ÇÇ‚ü´ := by
  by_cases h‚ÇÅ : a < b‚ÇÅ <;> simp [pair, h‚ÇÅ]
  ¬∑ simpa [lt_trans h‚ÇÅ h, ‚Üêsq] using h
  ¬∑ by_cases h‚ÇÇ : a < b‚ÇÇ <;> simp [h‚ÇÇ, h]
    calc
      a * a + a + b‚ÇÅ < (a + 1) * (a + 1) + b‚ÇÅ := by simp [add_mul_self_eq]; apply lt_succ_iff_le.mpr; simp
      _              ‚â§ b‚ÇÇ * b‚ÇÇ + b‚ÇÅ           := by simpa [‚Üêsq, succ_le_iff_lt] using h‚ÇÇ
      _              ‚â§ b‚ÇÇ * b‚ÇÇ + a            := by simpa using h‚ÇÅ

lemma pair_le_pair_right (a : V) {b‚ÇÅ b‚ÇÇ} (h : b‚ÇÅ ‚â§ b‚ÇÇ) : ‚ü™a, b‚ÇÅ‚ü´ ‚â§ ‚ü™a, b‚ÇÇ‚ü´ := by
  rcases h with (rfl | lt)
  ¬∑ simp
  ¬∑ exact le_of_lt (pair_lt_pair_right a lt)

lemma pair_le_pair {a‚ÇÅ a‚ÇÇ b‚ÇÅ b‚ÇÇ : V} (ha : a‚ÇÅ ‚â§ a‚ÇÇ) (hb : b‚ÇÅ ‚â§ b‚ÇÇ) : ‚ü™a‚ÇÅ, b‚ÇÅ‚ü´ ‚â§ ‚ü™a‚ÇÇ, b‚ÇÇ‚ü´ :=
  calc
    ‚ü™a‚ÇÅ, b‚ÇÅ‚ü´ ‚â§ ‚ü™a‚ÇÇ, b‚ÇÅ‚ü´ := pair_le_pair_left ha b‚ÇÅ
    _        ‚â§ ‚ü™a‚ÇÇ, b‚ÇÇ‚ü´ := pair_le_pair_right a‚ÇÇ hb

lemma pair_lt_pair {a‚ÇÅ a‚ÇÇ b‚ÇÅ b‚ÇÇ : V} (ha : a‚ÇÅ < a‚ÇÇ) (hb : b‚ÇÅ < b‚ÇÇ) : ‚ü™a‚ÇÅ, b‚ÇÅ‚ü´ < ‚ü™a‚ÇÇ, b‚ÇÇ‚ü´ :=
  calc
    ‚ü™a‚ÇÅ, b‚ÇÅ‚ü´ < ‚ü™a‚ÇÇ, b‚ÇÅ‚ü´ := pair_lt_pair_left ha b‚ÇÅ
    _        < ‚ü™a‚ÇÇ, b‚ÇÇ‚ü´ := pair_lt_pair_right a‚ÇÇ hb

@[simp] lemma pair_polybound (a b : V) : ‚ü™a, b‚ü´ ‚â§ (a + b + 1)^2 := by
  by_cases h : a < b <;> simp [pair, h, sq, add_mul_self_eq, two_mul]
  ¬∑ simp [‚Üêadd_assoc, add_right_comm _ a]; simp [add_right_comm _ (b * b)]
  ¬∑ simp [‚Üêadd_assoc, add_right_comm _ b]; simp [add_right_comm _ a]; simp [add_assoc]

@[simp] lemma pair_ext_iff {a‚ÇÅ a‚ÇÇ b‚ÇÅ b‚ÇÇ : V} : ‚ü™a‚ÇÅ, b‚ÇÅ‚ü´ = ‚ü™a‚ÇÇ, b‚ÇÇ‚ü´ ‚Üî a‚ÇÅ = a‚ÇÇ ‚àß b‚ÇÅ = b‚ÇÇ :=
  ‚ü®fun e ‚Ü¶ ‚ü®by simpa using congr_arg (œÄ‚ÇÅ ¬∑) e, by simpa using congr_arg (œÄ‚ÇÇ ¬∑) e‚ü©, by rintro ‚ü®rfl, rfl‚ü©; simp‚ü©

section

def _root_.LO.FirstOrder.Arith.pair‚ÇÉDef : ùö∫‚ÇÄ.Semisentence 4 :=
  .mkSigma ‚Äúp a b c. ‚àÉ bc <‚Å∫ p, !pairDef p a bc ‚àß !pairDef bc b c‚Äù (by simp)

def _root_.LO.FirstOrder.Arith.pair‚ÇÑDef : ùö∫‚ÇÄ.Semisentence 5 :=
  .mkSigma ‚Äúp a b c d. ‚àÉ bcd <‚Å∫ p, ‚àÉ cd <‚Å∫ bcd, !pairDef p a bcd ‚àß !pairDef bcd b cd ‚àß !pairDef cd c d‚Äù (by simp)

def _root_.LO.FirstOrder.Arith.pair‚ÇÖDef : ùö∫‚ÇÄ.Semisentence 6 :=
  .mkSigma ‚Äúp a b c d e. ‚àÉ bcde <‚Å∫ p, ‚àÉ cde <‚Å∫ bcde, ‚àÉ de <‚Å∫ cde, !pairDef p a bcde ‚àß !pairDef bcde b cde ‚àß !pairDef cde c de ‚àß !pairDef de d e‚Äù (by simp)

def _root_.LO.FirstOrder.Arith.pair‚ÇÜDef : ùö∫‚ÇÄ.Semisentence 7 :=
  .mkSigma ‚Äúp a b c d e f. ‚àÉ bcdef <‚Å∫ p, !pair‚ÇÖDef bcdef b c d e f ‚àß !pairDef p a bcdef‚Äù (by simp)

theorem fegergreg (v : Fin 4 ‚Üí ‚Ñï) : v (0 : Fin (Nat.succ 1)).succ.succ = v 2 := by { simp only [Nat.succ_eq_add_one,
  Nat.reduceAdd, Fin.isValue, Fin.succ_zero_eq_one, Fin.succ_one_eq_two] }

axiom P : Fin 3 ‚Üí Prop

theorem fin4 {n} : (2 : Fin (n + 3)).succ = 3 := rfl

@[simp] theorem Fin.succ_zero_eq_one'' {n} : (0 : Fin (n + 1)).succ = 1 := rfl

@[simp] theorem Fin.succ_two_eq_three {n} : (2 : Fin (n + 3)).succ = 3 := rfl

example (v : Fin 4 ‚Üí ‚Ñï) : v (2 : Fin 3).succ = v 3 := by { simp [fin4] }

theorem ss (v : Fin 4 ‚Üí ‚Ñï) : v (Fin.succ (0 : Fin (Nat.succ 1))).succ = v 2 := by { simp [Nat.succ_eq_add_one, Nat.reduceAdd, Fin.isValue, Fin.succ_zero_eq_one, Fin.succ_one_eq_two] }

lemma pair‚ÇÉ_defined : ùö∫‚ÇÄ-Function‚ÇÉ ((‚ü™¬∑, ¬∑, ¬∑‚ü´) : V ‚Üí V ‚Üí V ‚Üí V) via pair‚ÇÉDef := by
  intro v; simp [pair‚ÇÉDef]
  rintro h; simp [h]

@[simp] lemma eval_pair‚ÇÉDef (v) :
    Semiformula.Evalbm V v pair‚ÇÉDef.val ‚Üî v 0 = ‚ü™v 1, v 2, v 3‚ü´ := pair‚ÇÉ_defined.df.iff v

lemma pair‚ÇÑ_defined : ùö∫‚ÇÄ-Function‚ÇÑ ((‚ü™¬∑, ¬∑, ¬∑, ¬∑‚ü´) : V ‚Üí V ‚Üí V ‚Üí V ‚Üí V) via pair‚ÇÑDef := by
  intro v; simp [pair‚ÇÑDef]
  constructor
  ¬∑ intro h; simp only [Fin.isValue, h, pair_ext_iff, true_and]
    exact ‚ü®_, by simp, _, by simp, rfl, rfl, rfl‚ü©
  ¬∑ rintro ‚ü®_, _, _, _, h, rfl, rfl‚ü©; exact h

@[simp] lemma eval_pair‚ÇÑDef (v) :
    Semiformula.Evalbm V v pair‚ÇÑDef.val ‚Üî v 0 = ‚ü™v 1, v 2, v 3, v 4‚ü´ := pair‚ÇÑ_defined.df.iff v

lemma pair‚ÇÖ_defined : ùö∫‚ÇÄ.DefinedFunction (fun v : Fin 5 ‚Üí V ‚Ü¶ (‚ü™v 0, v 1, v 2, v 3, v 4‚ü´)) pair‚ÇÖDef := by
  intro v; simp [pair‚ÇÖDef]
  constructor
  ¬∑ intro h; simp only [Fin.isValue, h, pair_ext_iff, true_and]
    exact ‚ü®_, le_pair_right _ _, _, le_pair_right _ _, _, le_pair_right _ _, rfl, rfl, rfl, rfl‚ü©
  ¬∑ rintro ‚ü®_, _, _, _, _, _, h, rfl, rfl, rfl‚ü©; exact h

@[simp] lemma eval_pair‚ÇÖDef (v) :
    Semiformula.Evalbm V v pair‚ÇÖDef.val ‚Üî v 0 = ‚ü™v 1, v 2, v 3, v 4, v 5‚ü´ := pair‚ÇÖ_defined.df.iff v

lemma pair‚ÇÜ_defined : ùö∫‚ÇÄ.DefinedFunction (fun v : Fin 6 ‚Üí V ‚Ü¶ (‚ü™v 0, v 1, v 2, v 3, v 4, v 5‚ü´)) pair‚ÇÜDef := by
  intro v; simp [pair‚ÇÜDef]
  constructor
  ¬∑ intro h; simp only [Fin.isValue, h, pair_ext_iff, true_and]
    exact ‚ü®_, le_pair_right _ _, rfl, rfl‚ü©
  ¬∑ rintro ‚ü®_, _, rfl, h‚ü©; exact h

@[simp] lemma eval_pair‚ÇÜDef (v) :
    Semiformula.Evalbm V v pair‚ÇÜDef.val ‚Üî v 0 = ‚ü™v 1, v 2, v 3, v 4, v 5, v 6‚ü´ := pair‚ÇÜ_defined.df.iff v

end

def npair : {n : ‚Ñï} ‚Üí (v : Fin n ‚Üí V) ‚Üí V
  | 0,     _ => 0
  | _ + 1, v => ‚ü™v 0, npair (v ¬∑.succ)‚ü´

@[simp] lemma npair_zero (v : Fin 0 ‚Üí V) : npair v = 0 := by simp [npair]

lemma npair_succ (x) (v : Fin n ‚Üí V) : npair (x :> v) = ‚ü™x, npair v‚ü´ := by simp [npair]

def unNpair : {n : ‚Ñï} ‚Üí Fin n ‚Üí V ‚Üí V
  | 0,     i, _ => i.elim0
  | _ + 1, i, x => Fin.cases (œÄ‚ÇÅ x) (fun i ‚Ü¶ unNpair i (œÄ‚ÇÇ x)) i

@[simp] lemma unNpair_npair {n} (i : Fin n) (v : Fin n ‚Üí V) : unNpair i (npair v) = v i := by
  induction' n with n ih <;> simp [npair, unNpair, *]
  ¬∑ exact i.elim0
  ¬∑ cases i using Fin.cases <;> simp

section

def _root_.LO.FirstOrder.Arith.unNpairDef : {n : ‚Ñï} ‚Üí (i : Fin n) ‚Üí ùö∫‚ÇÄ.Semisentence 2
  | 0,     i => i.elim0
  | n + 1, i =>
    Fin.cases pi‚ÇÅDef (fun i ‚Ü¶ .mkSigma ‚Äúz v. ‚àÉ r <‚Å∫ v, !pi‚ÇÇDef r v ‚àß !(unNpairDef i) z r‚Äù (by simp)) i

lemma unNpair_defined {n} (i : Fin n) : ùö∫‚ÇÄ-Function‚ÇÅ (unNpair i : V ‚Üí V) via unNpairDef i := by
  induction' n with n ih
  ¬∑ exact i.elim0
  ¬∑ intro v
    cases' i using Fin.cases with i
    ¬∑ simp [unNpairDef, unNpair]
    ¬∑ simp [unNpairDef, unNpair, (ih i).df.iff]
      constructor
      ¬∑ intro h; exact ‚ü®œÄ‚ÇÇ (v 1), by simp, rfl, h‚ü©
      ¬∑ rintro ‚ü®x, _, rfl, h‚ü©; exact h

@[simp] lemma eval_unNpairDef {n} (i : Fin n) (v) :
    Semiformula.Evalbm V v (unNpairDef i).val ‚Üî v 0 = unNpair i (v 1) := (unNpair_defined i).df.iff v

@[definability, simp] instance unNpair_definable {n} (i : Fin n) (Œì) : Œì-Function‚ÇÅ (unNpair i : V ‚Üí V) :=
  (unNpair_defined i).to_definable‚ÇÄ

end

end pair

end IOpen

section polynomial_induction

variable [V ‚äß‚Çò* ùêàopen]

@[elab_as_elim]
lemma hierarchy_polynomial_induction (Œì m) [V ‚äß‚Çò* Theory.indScheme ‚Ñí‚Çí·µ£ (Arith.Hierarchy Œì m)]
    {P : V ‚Üí Prop} (hP : Œì-[m]-Predicate P)
    (zero : P 0) (even : ‚àÄ x > 0, P x ‚Üí P (2 * x)) (odd : ‚àÄ x, P x ‚Üí P (2 * x + 1)) : ‚àÄ x, P x := by
  intro x; induction x using order_induction_h
  ¬∑ exact Œì
  ¬∑ exact m
  ¬∑ exact hP
  case inst => exact inferInstance
  case ind x IH =>
    rcases zero_le x with (rfl | pos)
    ¬∑ exact zero
    ¬∑ have : x / 2 < x := div_lt_of_pos_of_one_lt pos one_lt_two
      rcases even_or_odd' x with (hx | hx)
      ¬∑ simpa [‚Üêhx] using even (x / 2) (by by_contra A; simp at A; simp [show x = 0 from by simpa [A] using hx] at pos) (IH (x / 2) this)
      ¬∑ simpa [‚Üêhx] using odd (x / 2) (IH (x / 2) this)

end polynomial_induction

@[elab_as_elim] lemma hierarchy_polynomial_induction_oRing_sigma‚ÇÄ [V ‚äß‚Çò* ùêàùö∫‚ÇÄ] {P : V ‚Üí Prop} (hP : ùö∫‚ÇÄ-Predicate P)
    (zero : P 0) (even : ‚àÄ x > 0, P x ‚Üí P (2 * x)) (odd : ‚àÄ x, P x ‚Üí P (2 * x + 1)) : ‚àÄ x, P x :=
  hierarchy_polynomial_induction ùö∫ 0 (P := P) hP zero even odd

@[elab_as_elim] lemma hierarchy_polynomial_induction_oRing_sigma‚ÇÅ [V ‚äß‚Çò* ùêàùö∫‚ÇÅ] {P : V ‚Üí Prop} (hP : ùö∫‚ÇÅ-Predicate P)
    (zero : P 0) (even : ‚àÄ x > 0, P x ‚Üí P (2 * x)) (odd : ‚àÄ x, P x ‚Üí P (2 * x + 1)) : ‚àÄ x, P x :=
  hierarchy_polynomial_induction ùö∫ 1 (P := P) hP zero even odd

@[elab_as_elim] lemma hierarchy_polynomial_induction_oRing_pi‚ÇÅ [V ‚äß‚Çò* ùêàùö∑‚ÇÅ] {P : V ‚Üí Prop} (hP : ùö∑‚ÇÅ-Predicate P)
    (zero : P 0) (even : ‚àÄ x > 0, P x ‚Üí P (2 * x)) (odd : ‚àÄ x, P x ‚Üí P (2 * x + 1)) : ‚àÄ x, P x :=
  hierarchy_polynomial_induction ùö∑ 1 (P := P) hP zero even odd

variable [V ‚äß‚Çò* ùêàopen]

lemma nat_cast_pair (n m : ‚Ñï) : (‚ü™n, m‚ü´ : ‚Ñï) = ‚ü™(‚Üën : V), (‚Üëm : V)‚ü´ := by simp [pair]

lemma nat_pair_eq (m n : ‚Ñï) : ‚ü™n, m‚ü´ = Nat.pair n m := by simp [Arith.pair, Nat.pair]

lemma pair_coe_eq_coe_pair (m n : ‚Ñï) :  ‚ü™n, m‚ü´ = (Nat.pair n m : V) := by simp [nat_cast_pair, nat_pair_eq]

end

end LO.Arith
