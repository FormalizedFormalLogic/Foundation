import Foundation.Modal.Kripke.Filtration
import Foundation.Modal.Entailment.KT
import Foundation.Modal.Hilbert.Normal.Basic
import Foundation.Modal.Logic.Basic
import Foundation.Vorspiel.List.Chain


namespace LO.Modal


namespace Axioms

variable (p‚ÇÄ p‚ÇÅ p‚ÇÇ q : Formula Œ±)

protected abbrev Fi.ant : Formula Œ± := (
  q ‚ãè ‚ñ°(q ‚ûù ‚óá(‚àºq ‚ãè ‚óáq)) ‚ãè
  ‚óáp‚ÇÄ ‚ãè (‚ñ°(p‚ÇÄ ‚ûù ‚àº‚óáp‚ÇÅ ‚ãè ‚àº‚óáp‚ÇÇ)) ‚ãè
  ‚óáp‚ÇÅ ‚ãè (‚ñ°(p‚ÇÅ ‚ûù ‚àº‚óáp‚ÇÇ ‚ãè ‚àº‚óáp‚ÇÄ)) ‚ãè
  ‚óáp‚ÇÇ ‚ãè (‚ñ°(p‚ÇÇ ‚ûù ‚àº‚óáp‚ÇÄ ‚ãè ‚àº‚óáp‚ÇÅ))
)

protected abbrev Fi := Fi.ant p‚ÇÄ p‚ÇÅ p‚ÇÇ q ‚ûù ‚óá(‚óáp‚ÇÄ ‚ãè ‚óáp‚ÇÅ ‚ãè ‚àº‚óáp‚ÇÇ)

end Axioms



open Formula (atom)
open Formula.Kripke
open Kripke

protected abbrev Hilbert.S4Fi : Hilbert.Normal ‚Ñï := ‚ü®{Axioms.K (.atom 0) (.atom 1), Axioms.T (.atom 0), Axioms.Four (.atom 0), Axioms.Fi (.atom 0) (.atom 1) (.atom 2) (.atom 3)}‚ü©
protected abbrev S4Fi := Hilbert.S4Fi.logic
notation "ùêíùüíùêÖùê¢" => Modal.S4Fi

section S4Fi.unprovable_AxiomFi_ant

def S4Fi.unprovable_AxiomFi_ant.countermodel : Kripke.Model where
  World := (Unit √ó Fin 2) ‚äï (‚Ñï √ó Fin 3)
  Rel := fun x y =>
    match x, y with
    | Sum.inl (_, _), _ => True
    | Sum.inr _, Sum.inl _ => False
    | Sum.inr (n, i), Sum.inr (m, j) =>
      if      n = m     then i = j
      else if n = m + 1 then i ‚â† j
      else    n ‚â• m + 2
  Val w a :=
    match w, a with
    | Sum.inl (_, i), 3 => i = 0
    | Sum.inr (0, 0), 0 => True
    | Sum.inr (0, 1), 1 => True
    | Sum.inr (0, 2), 2 => True
    | _, _ => False

instance : S4Fi.unprovable_AxiomFi_ant.countermodel.IsReflexive := ‚ü®by
  intro x;
  match x with | Sum.inl _ | Sum.inr _ => simp [S4Fi.unprovable_AxiomFi_ant.countermodel]
‚ü©

instance : S4Fi.unprovable_AxiomFi_ant.countermodel.IsTransitive := ‚ü®by
  intro x y z;
  match x, y, z with
  | Sum.inl _, _, _ | Sum.inr _, Sum.inl _, _ | Sum.inr _, Sum.inr _, Sum.inl _ => simp [S4Fi.unprovable_AxiomFi_ant.countermodel]
  | Sum.inr (n, i), Sum.inr (m, j), Sum.inr (k, l) =>
    dsimp [S4Fi.unprovable_AxiomFi_ant.countermodel];
    grind;
‚ü©

/-- if `i ‚â§ 2`, `x ‚äß i` iff `x = (0, i)` -/
lemma S4Fi.unprovable_AxiomFi_ant.countermodel.iff_at_level0_satisfies {x : countermodel.World} {i : Fin 3} : Satisfies countermodel x (atom i.1) ‚Üî x = Sum.inr (0, i) := by
  constructor
  . contrapose!;
    match i with | 0 | 1 | 2 => simp_all [Satisfies, S4Fi.unprovable_AxiomFi_ant.countermodel];
  . rintro rfl;
    match i with
    | 0 | 1 | 2 =>
      simp [countermodel, Satisfies];

/-- if `i ‚â§ 2`, `(0, i)` can see only `(0, i)` -/
lemma S4Fi.unprovable_AxiomFi_ant.countermodel.only_self_at_level0 {y : countermodel} {i : Fin 3} : Sum.inr (0, i) ‚â∫ y ‚Üî y = Sum.inr (0, i) := by
  match y with
  | Sum.inl _ => simp [S4Fi.unprovable_AxiomFi_ant.countermodel, Frame.Rel'];
  | Sum.inr (m, j) => simp [Frame.Rel', S4Fi.unprovable_AxiomFi_ant.countermodel]; tauto;

set_option push_neg.use_distrib true in
lemma S4Fi.unprovable_AxiomFi_ant.valid_AxiomFi : unprovable_AxiomFi_ant.countermodel.toFrame ‚äß Axioms.Fi (atom 0) (atom 1) (atom 2) (atom 3) := by
  intro V x;
  apply Satisfies.imp_def.mpr;

  intro h;
  repeat rw [Satisfies.and_def] at h;

  have ‚ü®h‚ÇÅ, h‚ÇÇ, hy‚ÇÄ, h‚ÇÉ, hy‚ÇÅ, h‚ÇÑ, hy‚ÇÇ, h‚ÇÖ‚ü© := h;
  clear h;

  replace ‚ü®y‚ÇÄ, Rxy‚ÇÄ, hy‚ÇÄ‚ü© := Satisfies.dia_def.mp hy‚ÇÄ;
  replace ‚ü®y‚ÇÅ, Rxy‚ÇÅ, hy‚ÇÅ‚ü© := Satisfies.dia_def.mp hy‚ÇÅ;
  replace ‚ü®y‚ÇÇ, Rxy‚ÇÇ, hy‚ÇÇ‚ü© := Satisfies.dia_def.mp hy‚ÇÇ;

  obtain ‚ü®i, rfl‚ü© : ‚àÉ i, x = Sum.inl ((), i) := by
    match x with
    | Sum.inl ((), i) => use i;
    | Sum.inr (n, i)  =>
      exfalso;
      sorry;
  have ‚ü®Ry‚ÇÄ‚ÇÅ, Ry‚ÇÄ‚ÇÇ‚ü© : ¬¨y‚ÇÄ ‚â∫ y‚ÇÅ ‚àß ¬¨y‚ÇÄ ‚â∫ y‚ÇÇ := by
    by_contra! hC;
    rcases Satisfies.and_def.mp $ @h‚ÇÉ y‚ÇÄ (by simp [Frame.Rel', unprovable_AxiomFi_ant.countermodel]) hy‚ÇÄ with ‚ü®hy‚ÇÅ, hy‚ÇÇ‚ü©;
    rcases hC with (Ry | Ry);
    . apply (Satisfies.not_dia_def.mp hy‚ÇÅ _) Ry; simpa;
    . apply (Satisfies.not_dia_def.mp hy‚ÇÇ _) Ry; simpa;
  have ‚ü®Ry‚ÇÅ‚ÇÇ, Ry‚ÇÅ‚ÇÄ‚ü© : ¬¨y‚ÇÅ ‚â∫ y‚ÇÇ ‚àß ¬¨y‚ÇÅ ‚â∫ y‚ÇÄ := by
    by_contra! hC;
    rcases Satisfies.and_def.mp $ @h‚ÇÑ y‚ÇÅ (by simp [Frame.Rel', unprovable_AxiomFi_ant.countermodel]) hy‚ÇÅ with ‚ü®hy‚ÇÇ, hy‚ÇÄ‚ü©;
    rcases hC with (Ry | Ry);
    . apply (Satisfies.not_dia_def.mp hy‚ÇÇ _) Ry; simpa;
    . apply (Satisfies.not_dia_def.mp hy‚ÇÄ _) Ry; simpa;
  have ‚ü®Ry‚ÇÇ‚ÇÄ, Ry‚ÇÇ‚ÇÅ‚ü© : ¬¨y‚ÇÇ ‚â∫ y‚ÇÄ ‚àß ¬¨y‚ÇÇ ‚â∫ y‚ÇÅ := by
    by_contra! hC;
    rcases Satisfies.and_def.mp $ @h‚ÇÖ y‚ÇÇ (by simp [Frame.Rel', unprovable_AxiomFi_ant.countermodel]) hy‚ÇÇ with ‚ü®hy‚ÇÄ, hy‚ÇÅ‚ü©;
    rcases hC with (Ry | Ry);
    . apply (Satisfies.not_dia_def.mp hy‚ÇÄ _) Ry; simpa;
    . apply (Satisfies.not_dia_def.mp hy‚ÇÅ _) Ry; simpa;

  match y‚ÇÄ, y‚ÇÅ, y‚ÇÇ with
  | Sum.inl y‚ÇÄ, _, _
  | _, Sum.inl y‚ÇÅ, _
  | _, _, Sum.inl y‚ÇÇ =>
    sorry;
    -- simp_all [Frame.Rel', countermodel];
  | Sum.inr (n‚ÇÄ, i‚ÇÄ), Sum.inr (n‚ÇÅ, i‚ÇÅ), Sum.inr (n‚ÇÇ, i‚ÇÇ) =>
    clear Ry‚ÇÄ‚ÇÅ Ry‚ÇÄ‚ÇÇ Ry‚ÇÅ‚ÇÇ Ry‚ÇÅ‚ÇÄ Ry‚ÇÇ‚ÇÄ Ry‚ÇÇ‚ÇÅ Rxy‚ÇÄ Rxy‚ÇÅ Rxy‚ÇÇ;
    apply Satisfies.dia_def.mpr;
    let z : unprovable_AxiomFi_ant.countermodel.toFrame.World := Sum.inr (
      (max n‚ÇÄ n‚ÇÅ) + 1,
      match i‚ÇÄ, i‚ÇÅ with
      | 0, 0 => 1
      | 0, 1 => 2
      | 0, 2 => 1
      | 1, 0 => 2
      | 1, 1 => 2
      | 1, 2 => 0
      | 2, 0 => 1
      | 2, 1 => 0
      | 2, 2 => 0
    );
    have Rz‚ÇÄ : z ‚â∫ (Sum.inr (n‚ÇÄ, i‚ÇÄ)) := by
      dsimp [z];
      rcases (show max n‚ÇÄ n‚ÇÅ = n‚ÇÄ ‚à® max n‚ÇÄ n‚ÇÅ = n‚ÇÅ by omega) with (h | h);
      . simp [h, Frame.Rel', countermodel];
        split <;> trivial;
      . simp [h, Frame.Rel', countermodel];
        split;
        . omega;
        . split;
          . split <;> trivial;
          . omega;
    have Rz‚ÇÅ : z ‚â∫ (Sum.inr (n‚ÇÅ, i‚ÇÅ)) := by
      dsimp [z];
      rcases (show max n‚ÇÄ n‚ÇÅ = n‚ÇÄ ‚à® max n‚ÇÄ n‚ÇÅ = n‚ÇÅ by omega) with (h | h);
      . simp [h, Frame.Rel', countermodel];
        split;
        . omega;
        . split;
          . split <;> trivial;
          . omega;
      . simp [h, Frame.Rel', countermodel];
        split <;> trivial;
    use z;
    constructor;
    . simp [Frame.Rel', countermodel]
    . apply Satisfies.and_def.mpr;
      constructor;
      . apply Satisfies.dia_def.mpr;
        use Sum.inr (n‚ÇÄ, i‚ÇÄ);
      . apply Satisfies.and_def.mpr;
        constructor;
        . apply Satisfies.dia_def.mpr;
          use Sum.inr (n‚ÇÅ, i‚ÇÅ);
        . apply Satisfies.not_def.mpr;
          by_contra! hC;
          obtain ‚ü®u, Ryu, hu‚ü© := Satisfies.dia_def.mp hC;
          obtain ‚ü®hu‚ÇÄ, hu‚ÇÅ‚ü© := Satisfies.and_def.mp $ @h‚ÇÖ u (countermodel.trans (by sorry) Ryu) hu;
          match u with
          | Sum.inl u => simp [z, Frame.Rel', countermodel] at Ryu;
          | Sum.inr (m, j) =>
            simp [z, Frame.Rel', countermodel] at Ryu;
            split at Ryu;
            . rcases (show n‚ÇÄ + 1 = m ‚à® n‚ÇÅ + 1 = m by omega) with (rfl | rfl);
              . apply Satisfies.not_dia_def.mp hu‚ÇÄ (Sum.inr (n‚ÇÄ, i‚ÇÄ)) ?_ $ hy‚ÇÄ;
                convert Rz‚ÇÄ;
                . omega;
                . exact Ryu.symm;
              . apply Satisfies.not_dia_def.mp hu‚ÇÅ (Sum.inr (n‚ÇÅ, i‚ÇÅ)) ?_ $ hy‚ÇÅ;
                convert Rz‚ÇÅ;
                . omega;
                . exact Ryu.symm;
            . split at Ryu;
              . sorry;
              . sorry;

lemma S4Fi.unprovable_AxiomFi_ant.countermodel.countermodel_S4Fi : unprovable_AxiomFi_ant.countermodel.toFrame ‚äß* ùêíùüíùêÖùê¢ := by
  constructor;
  intro œÜ hœÜ;
  simp only [Entailment.theory, Set.mem_setOf_eq] at hœÜ;
  induction hœÜ using Hilbert.Normal.rec! with
  | mdp ihœÜœà ihœÜ => apply ValidOnFrame.mdp ihœÜœà ihœÜ;
  | nec ihœÜ => apply ValidOnFrame.nec ihœÜ;
  | imply‚ÇÅ => apply ValidOnFrame.imply‚ÇÅ;
  | imply‚ÇÇ => apply ValidOnFrame.imply‚ÇÇ;
  | ec => apply ValidOnFrame.elimContra;
  | axm s ih =>
    rcases ih with (rfl | rfl | rfl | rfl);
    . apply ValidOnFrame.axiomK;
    . apply @validate_AxiomT_of_reflexive countermodel.toFrame (s 0);
    . apply @validate_AxiomFour_of_transitive countermodel.toFrame (s 0);
    . apply Formula.Kripke.ValidOnFrame.subst;
      apply S4Fi.unprovable_AxiomFi_ant.valid_AxiomFi;

lemma S4Fi.unprovable_AxiomFi_ant : ùêíùüíùêÖùê¢ ‚ä¨ ‚àºAxioms.Fi.ant (.atom 0) (.atom 1) (.atom 2) (.atom 3) := by
  suffices ‚àÉ M : Model, M ‚äß* ùêíùüíùêÖùê¢ ‚àß ‚àÉ x : M, x ‚äß (Axioms.Fi.ant (.atom 0) (.atom 1) (.atom 2) (.atom 3)) by
    by_contra! hC;
    obtain ‚ü®M, hM‚ÇÅ, ‚ü®x, hM‚ÇÇ‚ü©‚ü© := this;
    apply Satisfies.not_def.mp $ @hM‚ÇÅ.realize (f := ‚àº(Axioms.Fi.ant (.atom 0) (.atom 1) (.atom 2) (.atom 3))) _ _ _ _ _ ?_ x;
    . assumption;
    . simpa using hC;
  use S4Fi.unprovable_AxiomFi_ant.countermodel;
  constructor;
  . constructor;
    intro œÜ hœÜ;
    apply S4Fi.unprovable_AxiomFi_ant.countermodel.countermodel_S4Fi.realize;
    assumption;
  . use Sum.inl ((), 0);
    simp only [Fin.isValue, Semantics.And.realize_and];
    refine ‚ü®?_, ?_, ?_, ?_, ?_, ?_, ?_, ?_‚ü©;
    . tauto;
    . intro x Rœâx;
      match x with
      | Sum.inl ((), 1) | Sum.inr (n, i) => simp [Satisfies, unprovable_AxiomFi_ant.countermodel];
      | Sum.inl ((), 0) =>
        intro _;
        apply Satisfies.dia_def.mpr;
        use Sum.inl ((), 1);
        constructor;
        . tauto;
        . apply Satisfies.and_def.mpr;
          constructor;
          . apply Satisfies.not_def.mpr;
            simp [Semantics.Realize, Satisfies, unprovable_AxiomFi_ant.countermodel];
          . apply Satisfies.dia_def.mpr;
            use Sum.inl ((), 0);
            constructor;
            . tauto;
            . simp [Semantics.Realize, Satisfies, unprovable_AxiomFi_ant.countermodel];
    . apply Satisfies.dia_def.mpr;
      use Sum.inr (0, 0);
      tauto;
    . intro x Rœâx hx;
      replace hx := @unprovable_AxiomFi_ant.countermodel.iff_at_level0_satisfies x 0 |>.mp hx;
      subst hx;
      apply Satisfies.and_def.mpr;
      constructor <;>
      . apply Satisfies.not_dia_def.mpr;
        intro y R0y;
        have := @unprovable_AxiomFi_ant.countermodel.only_self_at_level0 y 0 |>.mp R0y;
        subst y;
        simp [Semantics.Realize, Satisfies, unprovable_AxiomFi_ant.countermodel];
    . apply Satisfies.dia_def.mpr;
      use Sum.inr (0, 1);
      tauto;
    . intro x Rœâx hx;
      replace hx := @unprovable_AxiomFi_ant.countermodel.iff_at_level0_satisfies x 1 |>.mp hx;
      subst hx;
      apply Satisfies.and_def.mpr;
      constructor <;>
      . apply Satisfies.not_dia_def.mpr;
        intro y R0y;
        have := @unprovable_AxiomFi_ant.countermodel.only_self_at_level0 y 1 |>.mp R0y;
        subst y;
        simp [Semantics.Realize, Satisfies, unprovable_AxiomFi_ant.countermodel];
    . apply Satisfies.dia_def.mpr;
      use Sum.inr (0, 2);
      tauto;
    . intro x Rœâx hx;
      replace hx := @unprovable_AxiomFi_ant.countermodel.iff_at_level0_satisfies x 2 |>.mp hx;
      subst hx;
      apply Satisfies.and_def.mpr;
      constructor <;>
      . apply Satisfies.not_dia_def.mpr;
        intro y R0y;
        have := @unprovable_AxiomFi_ant.countermodel.only_self_at_level0 y 2 |>.mp R0y;
        subst y;
        simp [Semantics.Realize, Satisfies, unprovable_AxiomFi_ant.countermodel];

end S4Fi.unprovable_AxiomFi_ant


section

lemma S4Fi.infinite_of_not_valid_neg_AxiomFi_ant {M : Kripke.Model} (hM : M ‚äß* ùêíùüíùêÖùê¢) : ¬¨(M ‚äß ‚àºAxioms.Fi.ant (.atom 0) (.atom 1) (.atom 2) (.atom 3)) ‚Üí Infinite M := by
  sorry

end

lemma S4Fi.no_finite_model_property : ¬¨(‚àÄ œÜ, ùêíùüíùêÖùê¢ ‚ä¨ œÜ ‚Üí ‚àÉ M : Kripke.Model, Finite M ‚àß M ‚äß* ùêíùüíùêÖùê¢ ‚àß ¬¨M ‚äß œÜ) := by
  push_neg;
  use ‚àºAxioms.Fi.ant (.atom 0) (.atom 1) (.atom 2) (.atom 3);
  constructor;
  . exact S4Fi.unprovable_AxiomFi_ant;
  . rintro M hM‚ÇÅ hM‚ÇÇ;
    by_contra hC;
    apply not_finite_iff_infinite.mpr $ infinite_of_not_valid_neg_AxiomFi_ant hM‚ÇÇ hC;
    assumption;

end LO.Modal
