import Foundation.Modal.ComplementClosedConsistentFinset
import Foundation.Modal.Kripke.Logic.Grz.Soundness

namespace LO.Modal

namespace Formula

variable {Œ± : Type u} [DecidableEq Œ±]
variable {œÜ œà œá : Formula ‚Ñï}

@[grind] noncomputable abbrev subformulasGrz (œÜ : Formula Œ±) := œÜ.subformulas ‚à™ (œÜ.subformulas.prebox.image (Œª œà => ‚ñ°(œà ‚ûù ‚ñ°œà)))

namespace subformulasGrz

@[simp, grind] lemma mem_self : œÜ ‚àà œÜ.subformulasGrz := by simp [subformulasGrz, subformulas.mem_self]

@[grind] protected lemma mem_of_mem_subformula (h : œà ‚àà œÜ.subformulas) : œà ‚àà œÜ.subformulasGrz := by simp_all [subformulasGrz]

@[grind ‚áí] lemma mem_boximpbox (h : œà ‚àà œÜ.subformulas.prebox) : ‚ñ°(œà ‚ûù ‚ñ°œà) ‚àà œÜ.subformulasGrz := by simp_all [subformulasGrz]

@[grind ‚áí]
protected lemma mem_imp (h : (œà ‚ûù œá) ‚àà œÜ.subformulasGrz) : œà ‚àà œÜ.subformulasGrz ‚àß œá ‚àà œÜ.subformulasGrz := by
  simp_all only [
    Finset.mem_union, Finset.mem_image, Finset.mem_preimage, Function.iterate_one,
    reduceCtorEq, and_false, exists_const, or_false
  ]
  grind

example {_ : œÜ ‚àà œÜ.subformulasGrz} : œÜ ‚àà œÜ.subformulasGrz := by grind
example {_ : œà ‚ûù œá ‚àà œÜ.subformulasGrz} : œà ‚àà œÜ.subformulasGrz := by grind
example {_ : œà ‚ûù œá ‚àà œÜ.subformulasGrz} : œá ‚àà œÜ.subformulasGrz := by grind

end subformulasGrz

end Formula


open Formula Formula.Kripke
open LO.Entailment LO.Entailment.FiniteContext LO.Modal.Entailment
open ComplementClosedConsistentFinset
open Kripke

namespace Hilbert.Grz.Kripke

variable {S} [Entailment (Formula ‚Ñï) S]
variable {ùì¢ : S} [Entailment.Consistent ùì¢] [Entailment.Grz ùì¢]

variable {œÜ œà : Formula ‚Ñï}

abbrev miniCanonicalFrame (ùì¢ : S) [Entailment.Grz ùì¢] [Entailment.Consistent ùì¢] (œÜ : Formula ‚Ñï) : Kripke.Frame where
  World := ComplementClosedConsistentFinset ùì¢ (œÜ.subformulasGrz)
  Rel X Y :=
    (‚àÄ œà ‚àà (œÜ.subformulasGrz).prebox, ‚ñ°œà ‚àà X ‚Üí ‚ñ°œà ‚àà Y) ‚àß
    ((‚àÄ œà ‚àà (œÜ.subformulasGrz).prebox, ‚ñ°œà ‚àà Y ‚Üí ‚ñ°œà ‚àà X) ‚Üí X = Y)

instance : (miniCanonicalFrame ùì¢ œÜ).IsReflexive where
  refl := by tauto_set

instance : (miniCanonicalFrame ùì¢ œÜ).IsAntisymmetric where
  antisymm := by
    rintro X Y ‚ü®_, h‚ÇÅ‚ü© ‚ü®h‚ÇÇ, _‚ü©
    exact h‚ÇÅ h‚ÇÇ

instance : (miniCanonicalFrame ùì¢ œÜ).IsTransitive where
  trans := by
    rintro X Y Z ‚ü®RXY‚ÇÅ, RXY‚ÇÇ‚ü© ‚ü®RYZ‚ÇÅ, RYZ‚ÇÇ‚ü©
    constructor
    . rintro œà hq‚ÇÅ hq‚ÇÇ
      exact RYZ‚ÇÅ œà hq‚ÇÅ $ RXY‚ÇÅ œà hq‚ÇÅ hq‚ÇÇ
    . intro h
      have eXY : X = Y := RXY‚ÇÇ $ by
        intro œà hs hq
        exact h œà hs $ RYZ‚ÇÅ œà hs hq
      have eYZ : Y = Z := RYZ‚ÇÇ $ by
        intro œà hs hq
        exact RXY‚ÇÅ œà hs $ h œà hs hq
      subst_vars
      tauto

instance : (miniCanonicalFrame ùì¢ œÜ).IsFiniteGrz where


abbrev miniCanonicalModel (ùì¢ : S) [Entailment.Grz ùì¢] [Entailment.Consistent ùì¢] (œÜ : Formula ‚Ñï) : Kripke.Model where
  toFrame := miniCanonicalFrame ùì¢ œÜ
  Val X a := (atom a) ‚àà X

omit [Consistent ùì¢] [Entailment.Grz ùì¢] in
lemma truthlemma_lemma1
  {X : ComplementClosedConsistentFinset ùì¢ (œÜ.subformulasGrz)} (hq : ‚ñ°œà ‚àà œÜ.subformulas)
  : ((X.1.prebox.box) ‚à™ {‚ñ°(œà ‚ûù ‚ñ°œà), -œà}) ‚äÜ (œÜ.subformulasGrz)‚Åª := by
  simp only [FormulaFinset.complementary]
  intro œá hr
  replace hr : œá = ‚ñ°(œà ‚ûù ‚ñ°œà) ‚à® (‚àÉ a, ‚ñ°a ‚àà X ‚àß ‚ñ°a = œá) ‚à® œá = -œà := by
    simpa [Finset.mem_union] using hr
  apply Finset.mem_union.mpr
  rcases hr with (rfl | ‚ü®œá, hr, rfl‚ü© | rfl)
  . left
    simp
    tauto
  . have := X.closed.subset hr
    left
    exact FormulaFinset.complementary_mem_box (by grind) this
  . right
    simp only [Finset.mem_image, Finset.mem_union, Finset.mem_preimage, Function.iterate_one]
    use œà
    grind

omit [Consistent ùì¢] in
lemma truthlemma_lemma2
  {X : ComplementClosedConsistentFinset ùì¢ (œÜ.subformulasGrz)}
  (hœà‚ÇÅ : ‚ñ°œà ‚àà œÜ.subformulas)
  (hœà‚ÇÇ : ‚ñ°œà ‚àâ X)
  : FormulaFinset.Consistent ùì¢ ((X.1.prebox.box) ‚à™ {‚ñ°(œà ‚ûù ‚ñ°œà), -œà}) := by
    apply FormulaFinset.intro_union_consistent
    rintro Œì‚ÇÅ Œì‚ÇÇ hŒì‚ÇÅ hŒì‚ÇÇ
    by_contra! hC
    apply hœà‚ÇÇ
    have := Context.weakening! (Œì := Œì‚ÇÅ ‚à™ Œì‚ÇÇ) (Œî := insert (-œà) (insert (‚ñ°(œà ‚ûù ‚ñ°œà)) Œì‚ÇÅ)) ?_ hC
    . replace := Context.deduct! this
      replace := of_imply_complement_bot this
      replace := Context.deduct! this
      replace := Context.nec! this
      replace := axiomGrz! ‚®Ä this
      replace := Context.nec! this
      replace := Context.boxbox_in_context_to_box this
      replace : X.1.toSet.prebox.box.box *‚ä¢[ùì¢]! ‚ñ°œà := Context.weakening! ?_ this
      . replace := Context.boxbox_in_context_to_box this
        replace : X *‚ä¢[ùì¢]! ‚ñ°œà := Context.weakening! ?_ this
        . exact membership_iff (subformulasGrz.mem_of_mem_subformula hœà‚ÇÅ) |>.mpr this
        . intro Œæ hŒæ
          obtain ‚ü®Œæ, hŒæ, rfl‚ü© := hŒæ
          tauto
      . intro Œæ hŒæ
        obtain ‚ü®Œæ, hŒæ, rfl‚ü© := hŒæ
        have := hŒì‚ÇÅ hŒæ
        simp at this ‚ä¢
        obtain ‚ü®œá, hœá, rfl‚ü© := this
        use œá
    . intro Œæ
      simp only [Set.mem_union, Finset.mem_coe, Set.mem_insert_iff]
      rintro (hŒæ‚ÇÅ | hŒæ‚ÇÇ)
      . have := hŒì‚ÇÅ hŒæ‚ÇÅ; tauto
      . have := hŒì‚ÇÇ hŒæ‚ÇÇ
        simp at this
        tauto

omit [Consistent ùì¢] in
lemma truthlemma_lemma3 : ùì¢ ‚ä¢! (œÜ ‚ãè ‚ñ°(œÜ ‚ûù ‚ñ°œÜ)) ‚ûù ‚ñ°œÜ := by
  refine C!_trans ?_ $ inner_mdp! (ùì¢ := ùì¢) (œÜ := œÜ) (œà := ‚ñ°œÜ)
  apply CKK!_of_C!'
  exact axiomT!

lemma truthlemma {X : (miniCanonicalModel ùì¢ œÜ).World} (q_sub : œà ‚àà œÜ.subformulas) :
  Satisfies (miniCanonicalModel ùì¢ œÜ) X œà ‚Üî œà ‚àà X := by
  induction œà generalizing X with
  | hatom => simp [Satisfies]
  | hfalsum => simp [Satisfies]
  | himp œà œá ihq ihr =>
    constructor
    . contrapose
      intro h
      apply Satisfies.not_imp.mpr
      apply Satisfies.and_def.mpr
      constructor
      . apply ihq (by grind) |>.mpr
        exact iff_not_mem_imp (œà := œà) (œá := œá) |>.mp h |>.1
      . apply ihr (by grind) |>.not.mpr
        exact iff_not_mem_compl (by grind) |>.not.mpr $ by
          push_neg
          exact iff_not_mem_imp (œà := œà) (œá := œá) |>.mp h |>.2
    . contrapose
      intro h
      replace h := Satisfies.and_def.mp $ Satisfies.not_imp.mp h
      obtain ‚ü®hq, hr‚ü© := h
      replace hq := ihq (by grind) |>.mp hq
      replace hr := ihr (by grind) |>.not.mp hr
      apply iff_not_mem_imp (œà := œà) (œá := œá) |>.mpr
      constructor
      . assumption
      . simpa using iff_not_mem_compl (by grind) |>.not.mp hr
  | hbox œà ih =>
    constructor
    . contrapose
      by_cases w : œà ‚àà X
      . intro h
        obtain ‚ü®Y, hY‚ü© := lindenbaum (ùì¢ := ùì¢) (truthlemma_lemma1 q_sub) (truthlemma_lemma2 q_sub h)
        simp only [Finset.union_subset_iff] at hY
        simp only [Satisfies]; push_neg
        use Y
        constructor
        . constructor
          . intro œá _ hr‚ÇÇ
            apply hY.1
            simpa
          . apply imp_iff_not_or (b := X = Y) |>.mpr
            left; push_neg
            use (œà ‚ûù ‚ñ°œà)
            refine ‚ü®?_, ?_, ?_‚ü©
            . simp_all
            . apply hY.2
              simp
            . by_contra hC
              have : ‚ÜëX *‚ä¢[ùì¢]! œà := membership_iff (by grind) |>.mp w
              have : ‚ÜëX *‚ä¢[ùì¢]! ‚ñ°(œà ‚ûù ‚ñ°œà) := membership_iff (by simp; right; assumption) |>.mp hC
              have : ‚ÜëX *‚ä¢[ùì¢]! (œà ‚ãè ‚ñ°(œà ‚ûù ‚ñ°œà)) ‚ûù ‚ñ°œà := Context.of! $ truthlemma_lemma3
              have : ‚ÜëX *‚ä¢[ùì¢]! ‚ñ°œà := this ‚®Ä K!_intro (by assumption) (by assumption)
              have : ‚ñ°œà ‚àà X := membership_iff (by grind) |>.mpr this
              contradiction
        . apply ih (by grind) |>.not.mpr
          apply iff_not_mem_compl (by grind) |>.not.mpr
          push_neg
          apply hY.2
          simp
      . intro _
        simp only [Satisfies]; push_neg
        use X
        constructor
        . apply Frame.refl
        . exact ih (by grind) |>.not.mpr w
    . intro h Y RXY
      apply ih (by grind) |>.mpr
      have : ‚ÜëY *‚ä¢[ùì¢]! ‚ñ°œà ‚ûù œà := Context.of! $ axiomT!
      have : ‚ÜëY *‚ä¢[ùì¢]! œà := this ‚®Ä (membership_iff (by grind) |>.mp (RXY.1 œà (by simp; grind) h))
      exact membership_iff (by grind) |>.mpr this

lemma complete_of_mem_miniCanonicalFrame
  (C : Kripke.FrameClass)
  (hC : ‚àÄ {œÜ}, miniCanonicalFrame ùì¢ œÜ ‚àà C)
  : Complete ùì¢ C := ‚ü®by
  intro œÜ
  contrapose
  intro h
  apply Semantics.set_models_iff.not.mpr
  push_neg
  use (miniCanonicalFrame ùì¢ œÜ)
  constructor
  . apply hC
  . apply ValidOnFrame.not_of_exists_valuation_world
    obtain ‚ü®X, hX‚ÇÅ‚ü© := lindenbaum (ùì¢ := ùì¢) (Œ¶ := {-œÜ}) (Œ® := œÜ.subformulasGrz)
      (by
        simp only [Finset.singleton_subset_iff]
        apply FormulaFinset.complementary_comp
        grind
      )
      (FormulaFinset.unprovable_iff_singleton_compl_consistent.mpr h)
    use (miniCanonicalModel _ œÜ).Val, X
    apply truthlemma (by grind) |>.not.mpr
    exact iff_not_mem_compl (by grind) |>.not.mpr $ by
      push_neg
      apply hX‚ÇÅ
      tauto
‚ü©

instance : Complete Hilbert.Grz FrameClass.finite_Grz := complete_of_mem_miniCanonicalFrame FrameClass.finite_Grz $ by
  simp only [Set.mem_setOf_eq]
  intro œÜ
  infer_instance


instance : Hilbert.S4McK ‚™± Hilbert.Grz := by
  constructor
  . apply Hilbert.Kripke.weakerThan_of_subset_frameClass FrameClass.S4McK FrameClass.finite_Grz
    intro F hF
    simp_all only [Set.mem_setOf_eq]
    infer_instance
  . apply Entailment.not_weakerThan_iff.mpr
    use Axioms.Grz (.atom 0)
    constructor
    . simp
    . apply Sound.not_provable_of_countermodel (ùìú := FrameClass.S4McK)
      apply Kripke.not_validOnFrameClass_of_exists_model_world
      use ‚ü®‚ü®Fin 3, Œª x y => y = 2 ‚à® x = 0 ‚à® x = 1‚ü©, Œª w _ => w = 1 ‚à® w = 2‚ü©, 0
      constructor
      . exact {
          refl := by omega,
          trans := by omega,
          mckinsey := by simp
        }
      . suffices ‚àÄ (x : Fin 3), (‚àÄ (y : Fin 3), x = 0 ‚à® x = 1 ‚Üí y = 1 ‚à® y = 2 ‚Üí ‚àÄ (z : Fin 3), y = 0 ‚à® y = 1 ‚Üí z = 1 ‚à® z = 2) ‚Üí x ‚â† 1 ‚Üí x = 2 by
          simpa [Semantics.Realize, Satisfies]
        intro x hx hxn1
        by_contra hxn2
        rcases @hx 1 (by omega) (by tauto) x (by omega)
        . contradiction
        . contradiction

instance : Hilbert.S4 ‚™± Hilbert.Grz := calc
  Hilbert.S4 ‚™± Hilbert.S4McK := by infer_instance
  _          ‚™± Hilbert.Grz   := by infer_instance

end Hilbert.Grz.Kripke

instance : Modal.S4McK ‚™± Modal.Grz := inferInstance

end LO.Modal
