import Foundation.Modal.Kripke.Completeness
import Foundation.Vorspiel.Relation.Supplemental
import Foundation.Vorspiel.Relation.Iterate

section

open LO.Modal

def GeachConfluent (t : Axioms.Geach.Taple) (R : Rel Œ± Œ±) := ‚àÄ ‚¶Éx y z : Œ±‚¶Ñ, (R.iterate t.i x y) ‚àß (R.iterate t.j x z) ‚Üí ‚àÉ u, (R.iterate t.m y u) ‚àß (R.iterate t.n z u)

namespace GeachConfluent

variable {rel : Rel Œ± Œ±}

lemma serial_def : Serial rel ‚Üî (GeachConfluent ‚ü®0, 0, 1, 1‚ü© rel) := by simp [GeachConfluent, Serial];

lemma reflexive_def : Reflexive rel ‚Üî (GeachConfluent ‚ü®0, 0, 1, 0‚ü© rel) := by simp [GeachConfluent, Reflexive];

lemma symmetric_def : Symmetric rel ‚Üî (GeachConfluent ‚ü®0, 1, 0, 1‚ü© rel) := by
  simp [GeachConfluent, Symmetric];
  constructor;
  . rintro h x y z rfl Rxz; exact h Rxz;
  . intro h x y Rxy; exact h rfl Rxy;

lemma transitive_def : Transitive rel ‚Üî (GeachConfluent ‚ü®0, 2, 1, 0‚ü© rel) := by
  simp [GeachConfluent, Transitive];
  constructor;
  . rintro h x y z rfl w Rxw Rwz; exact h Rxw Rwz;
  . intro h x y z Rxy Ryz; exact h rfl y Rxy Ryz

lemma euclidean_def : Euclidean rel ‚Üî (GeachConfluent ‚ü®1, 1, 0, 1‚ü© rel) := by simp [GeachConfluent, Euclidean];

lemma confluent_def : Confluent rel ‚Üî (GeachConfluent ‚ü®1, 1, 1, 1‚ü© rel) := by simp [GeachConfluent, Confluent];

lemma coreflexive_def : Coreflexive rel ‚Üî (GeachConfluent ‚ü®0, 1, 0, 0‚ü© rel) := by
  simp [GeachConfluent, Coreflexive];
  constructor;
  . rintro h x y z rfl Rxz; have := h Rxz; tauto;
  . intro h x y Rxy; have := h rfl Rxy; tauto;

lemma functional_def : Functional rel ‚Üî (GeachConfluent ‚ü®1, 1, 0, 0‚ü© rel) := by
  simp [GeachConfluent, Functional];
  constructor <;> tauto;

lemma dense_def : Dense rel ‚Üî (GeachConfluent ‚ü®0, 1, 2, 0‚ü© rel) := by
  simp [GeachConfluent, Dense];
  constructor;
  . rintro h x y z rfl Rxz; exact h Rxz;
  . intro h x y Rxy; exact h rfl Rxy;

@[simp]
lemma satisfies_eq : GeachConfluent (Œ± := Œ±) t (¬∑ = ¬∑) := by simp [GeachConfluent];

end GeachConfluent


class IsGeachConfluent (g) (Œ±) (R : Rel Œ± Œ±) where
  geachean : GeachConfluent g R

section

variable {rel : Rel Œ± Œ±}

instance [IsGeachConfluent ‚ü®0, 2, 1, 0‚ü© _ rel] : IsTrans _ rel := ‚ü®by
  intro a b c Rab Rac;
  apply @GeachConfluent.transitive_def Œ± rel |>.mpr IsGeachConfluent.geachean Rab Rac;
‚ü©
instance [IsTrans _ rel] : IsGeachConfluent ‚ü®0, 2, 1, 0‚ü© _ rel := ‚ü®by
  apply @GeachConfluent.transitive_def Œ± rel |>.mp;
  exact IsTrans.trans;
‚ü©


instance [IsGeachConfluent ‚ü®0, 0, 1, 0‚ü© _ rel] : IsRefl _ rel := ‚ü®by
  intro a;
  apply @GeachConfluent.reflexive_def Œ± rel |>.mpr IsGeachConfluent.geachean;
‚ü©

instance [IsRefl _ rel] : IsGeachConfluent ‚ü®0, 0, 1, 0‚ü© _ rel := ‚ü®by
  apply @GeachConfluent.reflexive_def Œ± rel |>.mp;
  exact IsRefl.refl;
‚ü©


instance [IsGeachConfluent ‚ü®0, 1, 0, 1‚ü© _ rel] : IsSymm _ rel := ‚ü®by
  intro a b Rab;
  apply @GeachConfluent.symmetric_def Œ± rel |>.mpr IsGeachConfluent.geachean;
  exact Rab;
‚ü©

instance [IsSymm _ rel] : IsGeachConfluent ‚ü®0, 1, 0, 1‚ü© _ rel := ‚ü®by
  apply @GeachConfluent.symmetric_def Œ± rel |>.mp;
  exact IsSymm.symm;
‚ü©


instance [IsGeachConfluent ‚ü®0, 0, 1, 1‚ü© _ rel] : IsSerial _ rel := ‚ü®by
  intro a;
  apply @GeachConfluent.serial_def Œ± rel |>.mpr IsGeachConfluent.geachean;
‚ü©

instance [IsSerial _ rel] : IsGeachConfluent ‚ü®0, 0, 1, 1‚ü© _ rel := ‚ü®by
  apply @GeachConfluent.serial_def Œ± rel |>.mp;
  exact IsSerial.serial;
‚ü©


instance [IsGeachConfluent ‚ü®1, 1, 0, 1‚ü© _ rel] : IsEuclidean _ rel := ‚ü®by
  intro a b c Rab Rac;
  apply @GeachConfluent.euclidean_def Œ± rel |>.mpr IsGeachConfluent.geachean Rab Rac;
‚ü©

instance [IsEuclidean _ rel] : IsGeachConfluent ‚ü®1, 1, 0, 1‚ü© _ rel := ‚ü®by
  apply @GeachConfluent.euclidean_def Œ± rel |>.mp;
  exact IsEuclidean.euclidean;
‚ü©


instance [IsGeachConfluent ‚ü®1, 1, 1, 1‚ü© _ rel] : IsConfluent _ rel := ‚ü®by
  rintro a b c ‚ü®Rab, Rba‚ü©;
  apply @GeachConfluent.confluent_def Œ± rel |>.mpr IsGeachConfluent.geachean;
  exact ‚ü®Rab, Rba‚ü©;
‚ü©

instance [IsConfluent _ rel] : IsGeachConfluent ‚ü®1, 1, 1, 1‚ü© _ rel := ‚ü®by
  apply @GeachConfluent.confluent_def Œ± rel |>.mp;
  exact IsConfluent.confluent;
‚ü©


instance [IsGeachConfluent ‚ü®0, 1, 0, 0‚ü© _ rel] : IsCoreflexive _ rel := ‚ü®by
  intro a b Rab;
  apply @GeachConfluent.coreflexive_def Œ± rel |>.mpr IsGeachConfluent.geachean;
  exact Rab;
‚ü©

instance [IsCoreflexive _ rel] : IsGeachConfluent ‚ü®0, 1, 0, 0‚ü© _ rel := ‚ü®by
  apply @GeachConfluent.coreflexive_def Œ± rel |>.mp;
  exact IsCoreflexive.coreflexive;
‚ü©

end

end



namespace LO.Modal

open LO.Modal.Entailment


namespace Kripke

instance whitepoint.instIsGeachConfluent : IsGeachConfluent g _ whitepoint.Rel := ‚ü®by
  rintro x y z ‚ü®Rxy, Rxz‚ü©;
  use ();
  constructor;
  . apply Rel.iterate.true_any; tauto;
  . apply Rel.iterate.true_any; tauto;
‚ü©

open Formula.Kripke



section definability

variable {F : Kripke.Frame} (g)

lemma validate_AxiomGeach_of_GeachConfluent [IsGeachConfluent g _ F.Rel] : F ‚äß (Axioms.Geach g (.atom 0)) := by
  rintro V x h;
  apply Satisfies.multibox_def.mpr;
  obtain ‚ü®y, Rxy, hbp‚ü© := Satisfies.multidia_def.mp h;
  intro z Rxz;
  apply Satisfies.multidia_def.mpr;
  obtain ‚ü®u, Ryu, Rzu‚ü© := IsGeachConfluent.geachean ‚ü®Rxy, Rxz‚ü©;
  use u;
  constructor;
  . assumption;
  . exact (Satisfies.multibox_def.mp hbp) Ryu;

section

lemma validate_AxiomT_of_reflexive [refl : IsRefl _ F] : F ‚äß (Axioms.T (.atom 0)) := validate_AxiomGeach_of_GeachConfluent ‚ü®0, 0, 1, 0‚ü©
lemma validate_AxiomD_of_serial [ser : IsSerial _ F.Rel] : F ‚äß (Axioms.D (.atom 0)) := validate_AxiomGeach_of_GeachConfluent ‚ü®0, 0, 1, 1‚ü©
lemma validate_AxiomB_of_symmetric [sym : IsSymm _ F.Rel] : F ‚äß (Axioms.B (.atom 0)) := validate_AxiomGeach_of_GeachConfluent ‚ü®0, 1, 0, 1‚ü©
lemma validate_AxiomFour_of_transitive [trans : IsTrans _ F] : F ‚äß (Axioms.Four (.atom 0)) := validate_AxiomGeach_of_GeachConfluent ‚ü®0, 2, 1, 0‚ü©
lemma validate_AxiomFive_of_euclidean [eucl : IsEuclidean _ F.Rel] : F ‚äß (Axioms.Five (.atom 0)) := validate_AxiomGeach_of_GeachConfluent ‚ü®1, 1, 0, 1‚ü©
lemma validate_AxiomPoint2_of_confluent [conf : IsConfluent _ F.Rel] : F ‚äß (Axioms.Point2 (.atom 0)) := validate_AxiomGeach_of_GeachConfluent ‚ü®1, 1, 1, 1‚ü©
lemma validate_AxiomTc_of_coreflexive [corefl : IsCoreflexive _ F.Rel] : F ‚äß (Axioms.Tc (.atom 0)) := validate_AxiomGeach_of_GeachConfluent ‚ü®0, 1, 0, 0‚ü©

end


lemma geachean_of_validate_AxiomGeach : F ‚äß (Axioms.Geach g (.atom 0)) ‚Üí (GeachConfluent g) F.Rel := by
  rintro h x y z ‚ü®Rxy, Rxz‚ü©;
  let V : Kripke.Valuation F := Œª v _ => y ‚â∫^[g.m] v;
  have : Satisfies ‚ü®F, V‚ü© x (‚óá^[g.i](‚ñ°^[g.m](.atom 0))) := by
    apply Satisfies.multidia_def.mpr;
    use y;
    constructor;
    . assumption;
    . apply Satisfies.multibox_def.mpr;
      aesop;
  have : Satisfies ‚ü®F, V‚ü© x (‚ñ°^[g.j](‚óá^[g.n]Formula.atom 0)) := h V x this;
  have : Satisfies ‚ü®F, V‚ü© z (‚óá^[g.n]Formula.atom 0) := Satisfies.multibox_def.mp this Rxz;
  obtain ‚ü®u, Rzu, Ryu‚ü© := Satisfies.multidia_def.mp this;
  exact ‚ü®u, Ryu, Rzu‚ü©;

/-
instance FrameClass.multiGeachConfluent.definability (G) : (FrameClass.multiGeachConfluent G).DefinedBy (G.image (Œª t => Axioms.Geach t (.atom 0))) := by
  unfold FrameClass.multiGeachConfluent MultiGeachConfluent Axioms.Geach;
  constructor;
  intro F;
  constructor;
  . rintro hF œÜ ‚ü®g, ‚ü®hg, rfl‚ü©‚ü© V x h;
    obtain ‚ü®y, Rxy, hbp‚ü© := Satisfies.multidia_def.mp h;
    apply Satisfies.multibox_def.mpr;
    intro z Rxz;
    apply Satisfies.multidia_def.mpr;
    obtain ‚ü®u, Ryu, Rzu‚ü© := hF g hg ‚ü®Rxy, Rxz‚ü©;
    use u;
    constructor;
    . assumption;
    . exact (Satisfies.multibox_def.mp hbp) Ryu;
  . rintro h g hg x y z ‚ü®Rxy, Rxz‚ü©;
    let V : Kripke.Valuation F := Œª v _ => y ‚â∫^[g.m] v;
    have : Satisfies ‚ü®F, V‚ü© x (‚óá^[g.i](‚ñ°^[g.m](.atom 0))) := by
      apply Satisfies.multidia_def.mpr;
      use y;
      constructor;
      . assumption;
      . apply Satisfies.multibox_def.mpr;
        aesop;
    have : Satisfies ‚ü®F, V‚ü© x (‚ñ°^[g.j](‚óá^[g.n]Formula.atom 0)) := h (Axioms.Geach g (.atom 0)) (by tauto) V x this;
    have : Satisfies ‚ü®F, V‚ü© z (‚óá^[g.n]Formula.atom 0) := Satisfies.multibox_def.mp this Rxz;
    obtain ‚ü®u, Rzu, Ryu‚ü© := Satisfies.multidia_def.mp this;
    exact ‚ü®u, Ryu, Rzu‚ü©;
-/

section

variable {F : Frame}

lemma reflexive_of_validate_AxiomT (h : F ‚äß (Axioms.T (.atom 0))) : Reflexive F.Rel := by
  rw [GeachConfluent.reflexive_def];
  apply geachean_of_validate_AxiomGeach;
  exact h;

lemma transitive_of_validate_AxiomFour (h : F ‚äß (Axioms.Four (.atom 0))) : Transitive F.Rel := by
  rw [GeachConfluent.transitive_def];
  apply geachean_of_validate_AxiomGeach;
  exact h;

lemma euclidean_of_validate_AxiomFive (h : F ‚äß (Axioms.Five (.atom 0))) : Euclidean F.Rel := by
  rw [GeachConfluent.euclidean_def];
  apply geachean_of_validate_AxiomGeach;
  exact h;

lemma symmetric_of_validate_AxiomB (h : F ‚äß (Axioms.B (.atom 0))) : Symmetric F.Rel := by
  rw [GeachConfluent.symmetric_def];
  apply geachean_of_validate_AxiomGeach;
  exact h;

lemma serial_of_validate_AxiomD (h : F ‚äß (Axioms.D (.atom 0))) : Serial F.Rel := by
  rw [GeachConfluent.serial_def];
  apply geachean_of_validate_AxiomGeach;
  exact h;

lemma coreflexive_of_validate_AxiomTc (h : F ‚äß (Axioms.Tc (.atom 0))) : Coreflexive F.Rel := by
  rw [GeachConfluent.coreflexive_def];
  apply geachean_of_validate_AxiomGeach;
  exact h;

lemma confluent_of_validate_AxiomPoint2 (h : F ‚äß (Axioms.Point2 (.atom 0))) : Confluent F.Rel := by
  rw [GeachConfluent.confluent_def];
  apply geachean_of_validate_AxiomGeach;
  exact h;

end

end definability


section canonicality

variable [Entailment (Formula ‚Ñï) S]
variable {ùì¢ : S} [Entailment.Consistent ùì¢] [Entailment.K ùì¢]

open Formula.Kripke
open Entailment
open MaximalConsistentTableau
open canonicalModel

namespace Canonical

instance isGeachConfluent [Entailment.HasAxiomGeach g ùì¢] : IsGeachConfluent g _ (canonicalFrame ùì¢).Rel := ‚ü®by
  rintro x y z ‚ü®Rxy, Rxz‚ü©;
  have ‚ü®u, hu‚ü© := lindenbaum (ùì¢ := ùì¢) (t‚ÇÄ := ‚ü®y.1.1.premultibox g.m, z.1.2.premultidia g.n‚ü©) $ by
    rintro Œì Œî hŒì hŒî;
    by_contra! hC;
    have hŒ≥ : ‚ñ°^[g.m](Œì.conj) ‚àà y.1.1 := y.mdp_mem‚ÇÅ_provable collect_multibox_fconj! $ iff_mem‚ÇÅ_fconj.mpr (by simpa using hŒì);
    have hŒ¥ : ‚óá^[g.n](Œî.disj) ‚àà z.1.2 := mdp_mem‚ÇÇ_provable distribute_multidia_fdisj! $ iff_mem‚ÇÇ_fdisj.mpr (by simpa using hŒî);
    generalize Œì.conj = Œ≥ at hŒ≥ hC;
    generalize Œî.disj = Œ¥ at hŒ¥ hC;
    have : ùì¢ ‚ä¢! ‚ñ°^[g.m]Œ≥ ‚ûù ‚ñ°^[g.m]Œ¥ := imply_multibox_distribute'! hC;
    have : ‚ñ°^[g.m]Œ¥ ‚àà y.1.1 := mdp_mem‚ÇÅ_provable this hŒ≥;
    have : ‚óá^[g.i](‚ñ°^[g.m]Œ¥) ‚àà x.1.1 := def_multirel_multidia_mem‚ÇÅ.mp Rxy this;
    have : ‚ñ°^[g.j](‚óá^[g.n]Œ¥) ‚àà x.1.1 := mdp_mem‚ÇÅ_provable axiomGeach! this;
    have : ‚óá^[g.n]Œ¥ ‚àà z.1.1 := def_multirel_multibox_mem‚ÇÅ.mp Rxz this;
    have : ‚óá^[g.n]Œ¥ ‚àâ z.1.2 := iff_not_mem‚ÇÇ_mem‚ÇÅ.mpr this;
    contradiction;
  use u;
  constructor;
  . apply def_multirel_multibox_mem‚ÇÅ.mpr;
    intro œÜ hœÜ;
    exact hu.1 hœÜ;
  . apply def_multirel_multidia_mem‚ÇÇ.mpr;
    intro œÜ hœÜ;
    exact hu.2 hœÜ;
‚ü©

instance isTrans [Entailment.HasAxiomFour ùì¢] : IsTrans _ (canonicalFrame ùì¢).Rel := inferInstance
instance [Entailment.HasAxiomT ùì¢] : IsRefl _ (canonicalFrame ùì¢).Rel := inferInstance
instance [Entailment.HasAxiomFive ùì¢] : IsEuclidean _ (canonicalFrame ùì¢).Rel := inferInstance
instance [Entailment.HasAxiomD ùì¢] : IsSerial _ (canonicalFrame ùì¢).Rel := inferInstance
instance [Entailment.HasAxiomB ùì¢] : IsSymm _ (canonicalFrame ùì¢).Rel := inferInstance
instance [Entailment.HasAxiomTc ùì¢] : IsCoreflexive _ (canonicalFrame ùì¢).Rel := inferInstance
instance [Entailment.HasAxiomPoint2 ùì¢] : IsConfluent _ (canonicalFrame ùì¢).Rel := inferInstance
instance [Entailment.HasAxiomT ùì¢] [Entailment.HasAxiomFour ùì¢] : IsPreorder _ (canonicalFrame ùì¢).Rel where
instance [Entailment.HasAxiomT ùì¢] [Entailment.HasAxiomFour ùì¢] [Entailment.HasAxiomB ùì¢] : IsEquiv _ (canonicalFrame ùì¢).Rel where

end Canonical

end canonicality


end Kripke

end LO.Modal
