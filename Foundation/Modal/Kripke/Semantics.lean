import Foundation.Vorspiel.BinaryRelations
import Foundation.Vorspiel.RelItr
import Foundation.Logic.System
import Foundation.Modal.Formula
import Foundation.Modal.Hilbert

namespace LO.Modal

open System


namespace Kripke

structure Frame where
  World : Type
  Rel : Rel World World
  [world_nonempty : Nonempty World]

instance : CoeSort Frame (Type) := ‚ü®Frame.World‚ü©
instance : CoeFun Frame (Œª F => F.World ‚Üí F.World ‚Üí Prop) := ‚ü®Frame.Rel‚ü©
instance {F : Frame} : Nonempty F.World := F.world_nonempty

abbrev Frame.Rel' {F : Frame} (x y : F.World) := F.Rel x y
infix:45 " ‚â∫ " => Frame.Rel'

protected abbrev Frame.RelItr' {F : Frame} (n : ‚Ñï) := F.Rel.iterate n
notation x:45 " ‚â∫^[" n "] " y:46 => Frame.RelItr' n x y

def Frame.isFinite (F : Frame) := Finite F.World

abbrev reflexivePointFrame : Frame where
  World := Unit
  Rel := fun _ _ => True

abbrev irreflexivePointFrame : Frame where
  World := Unit
  Rel := fun _ _ => False


abbrev FrameClass := Set Frame

section

abbrev AllFrameClass : FrameClass := Set.univ

abbrev SymmetricFrameClass : FrameClass := { F : Kripke.Frame | Symmetric F }

abbrev ConfluentFrameClass : FrameClass := { F : Kripke.Frame | Confluent F }

abbrev ConnectedFrameClass : FrameClass := { F : Kripke.Frame | Connected F }

abbrev EuclideanFrameClass : FrameClass := { F : Kripke.Frame | Euclidean F }

end

abbrev Valuation (F : Frame) := F.World ‚Üí ‚Ñï ‚Üí Prop

structure Model extends Frame where
  Val : Valuation toFrame
instance : CoeFun (Model) (Œª M => M.World ‚Üí ‚Ñï ‚Üí Prop) := ‚ü®fun m => m.Val‚ü©

end Kripke



namespace Formula.Kripke

def Satisfies (M : Kripke.Model) (x : M.World) : Formula ‚Ñï ‚Üí Prop
  | atom a  => M x a
  | ‚ä•  => False
  | œÜ ‚ûù œà => (Satisfies M x œÜ) ‚ûù (Satisfies M x œà)
  | ‚ñ°œÜ   => ‚àÄ y, x ‚â∫ y ‚Üí (Satisfies M y œÜ)

namespace Satisfies

protected instance semantics {M : Kripke.Model} : Semantics (Formula ‚Ñï) (M.World) := ‚ü®fun x ‚Ü¶ Formula.Kripke.Satisfies M x‚ü©

variable {M : Kripke.Model} {x : M.World} {œÜ œà : Formula ‚Ñï}

@[simp]
protected lemma iff_models : x ‚äß œÜ ‚Üî Kripke.Satisfies M x œÜ := iff_of_eq rfl

lemma box_def : x ‚äß ‚ñ°œÜ ‚Üî ‚àÄ y, x ‚â∫ y ‚Üí y ‚äß œÜ := by simp [Kripke.Satisfies];

lemma dia_def : x ‚äß ‚óáœÜ ‚Üî ‚àÉ y, x ‚â∫ y ‚àß y ‚äß œÜ := by simp [Kripke.Satisfies];

lemma not_def : x ‚äß ‚àºœÜ ‚Üî ¬¨(x ‚äß œÜ) := by
  induction œÜ using Formula.rec' generalizing x with
  | _ => simp_all [Satisfies];
instance : Semantics.Not (M.World) := ‚ü®not_def‚ü©

lemma imp_def : x ‚äß œÜ ‚ûù œà ‚Üî (x ‚äß œÜ) ‚Üí (x ‚äß œà) := by tauto;
instance : Semantics.Imp (M.World) := ‚ü®imp_def‚ü©

lemma or_def : x ‚äß œÜ ‚ãé œà ‚Üî x ‚äß œÜ ‚à® x ‚äß œà := by simp [Satisfies]; tauto;
instance : Semantics.Or (M.World) := ‚ü®or_def‚ü©

lemma and_def : x ‚äß œÜ ‚ãè œà ‚Üî x ‚äß œÜ ‚àß x ‚äß œà := by simp [Satisfies];
instance : Semantics.And (M.World) := ‚ü®and_def‚ü©

protected instance : Semantics.Tarski (M.World) where
  realize_top := by tauto;
  realize_bot := by tauto;

lemma negneg_def : x ‚äß ‚àº‚àºœÜ ‚Üî x ‚äß œÜ := by simp [Satisfies];

lemma multibox_def : x ‚äß ‚ñ°^[n]œÜ ‚Üî ‚àÄ {y}, x ‚â∫^[n] y ‚Üí y ‚äß œÜ := by
  induction n generalizing x with
  | zero => aesop;
  | succ n ih =>
    constructor;
    . intro h y Rxy;
      simp [Kripke.Satisfies] at h;
      obtain ‚ü®u, Rxu, Ruy‚ü© := Rxy;
      exact (ih.mp $ h _ Rxu) Ruy;
    . simp;
      intro h y Rxy;
      apply ih.mpr;
      intro u Ryu;
      exact h _ Rxy Ryu;

lemma multidia_def : x ‚äß ‚óá^[n]œÜ ‚Üî ‚àÉ y, x ‚â∫^[n] y ‚àß y ‚äß œÜ := by
  induction n generalizing x with
  | zero => simp;
  | succ n ih =>
    constructor;
    . intro h;
      replace h : x ‚äß (‚óá‚óá^[n]œÜ) := by simpa using h;
      obtain ‚ü®v, hwv, hv‚ü© := dia_def.mp h;
      obtain ‚ü®x, hvx, hx‚ü© := ih.mp hv;
      use x;
      constructor;
      . use v;
      . assumption;
    . intro h;
      obtain ‚ü®y, Rxy, hy‚ü© := h;
      obtain ‚ü®u, Rxu, Ruy‚ü© := Rxy;
      simp;
      apply dia_def.mpr;
      use u;
      constructor;
      . exact Rxu;
      . apply ih.mpr;
        use y;

lemma trans (hpq : x ‚äß œÜ ‚ûù œà) (hqr : x ‚äß œà ‚ûù œá) : x ‚äß œÜ ‚ûù œá := by simp_all;

lemma mdp (hpq : x ‚äß œÜ ‚ûù œà) (hp : x ‚äß œÜ) : x ‚äß œà := by simp_all;

lemma dia_dual : x ‚äß ‚óáœÜ ‚Üî x ‚äß ‚àº‚ñ°(‚àºœÜ) := by simp [Satisfies];

lemma box_dual : x ‚äß ‚ñ°œÜ ‚Üî x ‚äß ‚àº‚óá(‚àºœÜ) := by simp [Satisfies];

lemma not_imp : ¬¨(x ‚äß œÜ ‚ûù œà) ‚Üî x ‚äß œÜ ‚ãè ‚àºœà := by simp [Satisfies];

end Satisfies


def ValidOnModel (M : Kripke.Model) (œÜ : Formula ‚Ñï) := ‚àÄ x : M.World, x ‚äß œÜ

namespace ValidOnModel

instance semantics : Semantics (Formula ‚Ñï) (Kripke.Model) := ‚ü®fun M ‚Ü¶ Formula.Kripke.ValidOnModel M‚ü©

@[simp] protected lemma iff_models {M : Kripke.Model} : M ‚äß f ‚Üî Kripke.ValidOnModel M f := iff_of_eq rfl

instance : Semantics.Bot (Kripke.Model) where
  realize_bot M := by simp [Kripke.ValidOnModel, Kripke.Satisfies];

variable {M : Kripke.Model} {œÜ œà œá : Formula ‚Ñï}

protected lemma mdp (hpq : M ‚äß œÜ ‚ûù œà) (hp : M ‚äß œÜ) : M ‚äß œà := by
  intro x;
  exact (Satisfies.imp_def.mp $ hpq x) (hp x);

protected lemma nec (h : M ‚äß œÜ) : M ‚äß ‚ñ°œÜ := by
  intro x y _;
  exact h y;

protected lemma verum : M ‚äß ‚ä§ := by intro; tauto;

protected lemma imply‚ÇÅ : M ‚äß (Axioms.Imply‚ÇÅ œÜ œà) := by simp [ValidOnModel]; tauto;

protected lemma imply‚ÇÇ : M ‚äß (Axioms.Imply‚ÇÇ œÜ œà œá) := by simp [ValidOnModel]; tauto;

protected lemma elimContra : M ‚äß (Axioms.ElimContra œÜ œà) := by simp [ValidOnModel, Satisfies]; tauto;

protected lemma axiomK : M ‚äß (Axioms.K œÜ œà)  := by
  intro V;
  apply Satisfies.imp_def.mpr;
  intro hpq;
  apply Satisfies.imp_def.mpr;
  intro hp x Rxy;
  replace hpq := Satisfies.imp_def.mp $ hpq x Rxy;
  replace hp := hp x Rxy;
  exact hpq hp;

end ValidOnModel


def ValidOnFrame (F : Kripke.Frame) (œÜ : Formula ‚Ñï) := ‚àÄ V, (‚ü®F, V‚ü© : Kripke.Model) ‚äß œÜ

namespace ValidOnFrame

instance semantics : Semantics (Formula ‚Ñï) (Kripke.Frame) := ‚ü®fun F ‚Ü¶ Formula.Kripke.ValidOnFrame F‚ü©

variable {F : Kripke.Frame}

@[simp] protected lemma models_iff : F ‚äß œÜ ‚Üî Kripke.ValidOnFrame F œÜ := iff_of_eq rfl

instance : Semantics.Bot (Kripke.Frame) where
  realize_bot _ := by simp [Kripke.ValidOnFrame];

protected lemma nec (h : F ‚äß œÜ) : F ‚äß ‚ñ°œÜ := by
  intro V x y _;
  exact h V y;

protected lemma mdp (hpq : F ‚äß œÜ ‚ûù œà) (hp : F ‚äß œÜ) : F ‚äß œà := by
  intro V x;
  exact (hpq V x) (hp V x);

protected lemma verum : F ‚äß ‚ä§ := by intros _; tauto;

protected lemma imply‚ÇÅ : F ‚äß (Axioms.Imply‚ÇÅ œÜ œà) := by intro V; exact ValidOnModel.imply‚ÇÅ (M := ‚ü®F, V‚ü©);

protected lemma imply‚ÇÇ : F ‚äß (Axioms.Imply‚ÇÇ œÜ œà œá) := by intro V; exact ValidOnModel.imply‚ÇÇ (M := ‚ü®F, V‚ü©);

protected lemma elimContra : F ‚äß (Axioms.ElimContra œÜ œà) := by intro V; exact ValidOnModel.elimContra (M := ‚ü®F, V‚ü©);

protected lemma axiomK : F ‚äß (Axioms.K œÜ œà) := by intro V; exact ValidOnModel.axiomK (M := ‚ü®F, V‚ü©);

protected lemma axiomK_set : F ‚äß* ùóû := by
  simp [Semantics.realizeSet_iff];
  rintro f x y rfl;
  exact ValidOnFrame.axiomK;

end ValidOnFrame


@[simp] def ValidOnFrameClass (C : Kripke.FrameClass) (œÜ : Formula ‚Ñï) := ‚àÄ {F}, F ‚àà C ‚Üí F ‚äß œÜ

namespace ValidOnFrameClass

protected instance semantics : Semantics (Formula ‚Ñï) (Kripke.FrameClass) := ‚ü®fun C ‚Ü¶ Kripke.ValidOnFrameClass C‚ü©

variable {C : Kripke.FrameClass}

@[simp] protected lemma models_iff : C ‚äß œÜ ‚Üî Formula.Kripke.ValidOnFrameClass C œÜ := iff_of_eq rfl

protected lemma nec (h : C ‚äß œÜ) : C ‚äß ‚ñ°œÜ := by
  intro _ hF;
  apply Kripke.ValidOnFrame.nec;
  exact h hF;

protected lemma mdp (hpq : C ‚äß œÜ ‚ûù œà) (hp : C ‚äß œÜ) : C ‚äß œà := by
  intro _ hF;
  exact Kripke.ValidOnFrame.mdp (hpq hF) (hp hF)

end ValidOnFrameClass

end Formula.Kripke


namespace Kripke

def Frame.theorems (F : Kripke.Frame) : Theory ‚Ñï := { œÜ | F ‚äß œÜ }

def FrameClass.DefinedBy (C : Kripke.FrameClass) (T : Theory ‚Ñï) := ‚àÄ F, F ‚àà C ‚Üî F ‚äß* T

section definability

variable {F : Kripke.Frame}

instance AllFrameClass.isDefinedBy : AllFrameClass.DefinedBy ùóû := by
  intro œÜ;
  simp [Frame.theorems];
  rintro _ œÜ œà rfl;
  exact Formula.Kripke.ValidOnFrame.axiomK;

end definability

end Kripke


namespace Hilbert

open Kripke

namespace Kripke

variable {H : Hilbert ‚Ñï} {œÜ : Formula ‚Ñï}
variable {C : FrameClass} {T : Theory ‚Ñï}

open Formula.Kripke

lemma sound_hilbert_of_frameclass (definedBy : C.DefinedBy T) : (Hilbert.ExtK T : Hilbert ‚Ñï) ‚ä¢! œÜ ‚Üí C ‚äß œÜ := by
  intro hœÜ F hF;
  induction hœÜ using Hilbert.Deduction.inducition_with_necOnly! with
  | hImply‚ÇÅ => apply ValidOnFrame.imply‚ÇÅ;
  | hImply‚ÇÇ => apply ValidOnFrame.imply‚ÇÇ;
  | hElimContra => apply ValidOnFrame.elimContra;
  | hMdp ihpq ihp => exact ValidOnFrame.mdp ihpq ihp;
  | hNec ih => exact ValidOnFrame.nec ih;
  | hMaxm h =>
    simp at h;
    rcases h with (‚ü®_, _, rfl‚ü© | hR);
    . exact Formula.Kripke.ValidOnFrame.axiomK;
    . apply Semantics.realizeSet_iff.mp (definedBy F |>.mp hF);
      assumption;

lemma sound_of_equiv_frameclass_hilbert (definedBy : C.DefinedBy T) (heq : H =‚Çõ (Hilbert.ExtK T)) : H ‚ä¢! œÜ ‚Üí C ‚äß œÜ := by
  intro hœÜ;
  apply sound_hilbert_of_frameclass (T := T) (definedBy);
  exact Equiv.iff.mp heq œÜ |>.mp hœÜ;

lemma instSound (definedBy : C.DefinedBy T) (heq : H =‚Çõ (Hilbert.ExtK T)) : Sound H C := ‚ü®sound_of_equiv_frameclass_hilbert definedBy heq‚ü©

lemma unprovable_bot [sound : Sound H C] (hNonempty : C.Nonempty) : H ‚ä¨ ‚ä• := by
  apply not_imp_not.mpr sound.sound;
  simp [Semantics.Realize];
  obtain ‚ü®F, hF‚ü© := hNonempty;
  use F;
  constructor;
  . exact hF;
  . exact Semantics.Bot.realize_bot (F := Formula ‚Ñï) (M := Kripke.Frame) F;

lemma instConsistent [Sound H C] (h_nonempty : C.Nonempty) : H.Consistent := System.Consistent.of_unprovable $ unprovable_bot h_nonempty

end Kripke


namespace K

instance Kripke.sound : Sound (Hilbert.K ‚Ñï) (AllFrameClass) := Kripke.instSound (definedBy := Kripke.AllFrameClass.isDefinedBy) (heq := by simp [ExtK.K_is_extK_of_AxiomK])

instance consistent : System.Consistent (Hilbert.K ‚Ñï) := Kripke.instConsistent (C := AllFrameClass) $ by
  use reflexivePointFrame;
  tauto;

end K


section

open Formula (atom)
open Formula.Kripke

lemma K_strictlyWeakerThan_KD : (Hilbert.K ‚Ñï) <‚Çõ (Hilbert.KD ‚Ñï) := by
  constructor;
  . apply K_weakerThan_KD;
  . simp [weakerThan_iff];
    use (‚ñ°(atom 0) ‚ûù ‚óá(atom 0));
    constructor;
    . exact axiomD!;
    . apply K.Kripke.sound.not_provable_of_countermodel;
      simp [ValidOnModel, ValidOnFrame, Satisfies];
      use ‚ü®Fin 1, Œª _ _ => False‚ü©, (Œª w _ => w = 0), 0;
      simp [Semantics.Realize, Satisfies];

theorem K_strictlyWeakerThan_KB : (Hilbert.K ‚Ñï) <‚Çõ (Hilbert.KB ‚Ñï) := by
  constructor;
  . apply K_weakerThan_KB;
  . simp [weakerThan_iff];
    use ((atom 0) ‚ûù ‚ñ°‚óá(atom 0));
    constructor;
    . exact axiomB!;
    . apply K.Kripke.sound.not_provable_of_countermodel;
      simp [ValidOnModel, ValidOnFrame, Satisfies];
      use ‚ü®Fin 2, Œª x y => x = 0 ‚àß y = 1‚ü©, (Œª w _ => w = 0), 0;
      simp [Semantics.Realize, Satisfies];
      use 1;

theorem K_strictlyWeakerThan_K4 : (Hilbert.K ‚Ñï) <‚Çõ (Hilbert.K4 ‚Ñï) := by
  constructor;
  . apply K_weakerThan_K4;
  . simp [weakerThan_iff];
    use (‚ñ°(atom 0) ‚ûù ‚ñ°‚ñ°(atom 0));
    constructor;
    . exact axiomFour!;
    . apply K.Kripke.sound.not_provable_of_countermodel;
      simp [ValidOnModel, ValidOnFrame, Satisfies];
      use ‚ü®Fin 2, Œª x y => x ‚â† y‚ü©, (Œª w _ => w = 1), 0;
      simp [Semantics.Realize, Satisfies];
      constructor;
      . intro x;
        match x with
        | 0 => tauto;
        | 1 => tauto;
      . use 1;
        constructor;
        . tauto;
        . use 0; tauto;

theorem K_strictlyWeakerThan_K5 : (Hilbert.K ‚Ñï) <‚Çõ (Hilbert.K5 ‚Ñï) := by
  constructor;
  . apply K_weakerThan_K5;
  . simp [weakerThan_iff];
    use (‚óá(atom default) ‚ûù ‚ñ°‚óá(atom default));
    constructor;
    . exact axiomFive!;
    . apply K.Kripke.sound.not_provable_of_countermodel;
      simp [ValidOnModel, ValidOnFrame, Satisfies];
      use ‚ü®Fin 2, Œª x _ => x = 0‚ü©, (Œª w _ => w = 0), 0;
      simp [Semantics.Realize, Satisfies];
      use 1;
      tauto;

end


section

variable {Ax‚ÇÅ Ax‚ÇÇ : Theory ‚Ñï} (C‚ÇÅ C‚ÇÇ : FrameClass)

lemma Kripke.weakerThan_of_subset_FrameClass
  [sound‚ÇÅ : Sound (Hilbert.ExtK Ax‚ÇÅ) C‚ÇÅ] [complete‚ÇÇ : Complete (Hilbert.ExtK Ax‚ÇÇ) C‚ÇÇ]
  (hùîΩ : C‚ÇÇ ‚äÜ C‚ÇÅ)
  : (Hilbert.ExtK Ax‚ÇÅ) ‚â§‚Çõ (Hilbert.ExtK Ax‚ÇÇ) := by
  apply System.weakerThan_iff.mpr;
  intro œÜ hp;
  apply complete‚ÇÇ.complete;
  intro F hF;
  exact sound‚ÇÅ.sound hp $ hùîΩ hF;

lemma Kripke.equiv_of_eq_FrameClass
  [sound‚ÇÅ : Sound (Hilbert.ExtK Ax‚ÇÅ) C‚ÇÅ] [sound‚ÇÇ : Sound (Hilbert.ExtK Ax‚ÇÇ) C‚ÇÇ]
  [complete‚ÇÅ : Complete (Hilbert.ExtK Ax‚ÇÅ) C‚ÇÅ] [complete‚ÇÇ : Complete (Hilbert.ExtK Ax‚ÇÇ) C‚ÇÇ]
  (hC : C‚ÇÅ = C‚ÇÇ) : (Hilbert.ExtK Ax‚ÇÅ) =‚Çõ (Hilbert.ExtK Ax‚ÇÇ) := by
  apply System.Equiv.antisymm_iff.mpr;
  constructor;
  . apply weakerThan_of_subset_FrameClass C‚ÇÅ C‚ÇÇ; subst_vars; rfl;
  . apply weakerThan_of_subset_FrameClass C‚ÇÇ C‚ÇÅ; subst_vars; rfl;

end

end Hilbert


/-
namespace Kripke

open Formula.Kripke (ValidOnFrame ValidOnModel Satisfies)

variable {C : Kripke.FrameClass} {F : Kripke.Frame}
         {œÜ œà : Formula ‚Ñï}

protected lemma axiomK : C ‚äß* ùóû := by
  simp only [Semantics.RealizeSet.setOf_iff];
  rintro f ‚ü®œÜ, œà, _‚ü© F _;
  apply (Semantics.RealizeSet.setOf_iff.mp $ ValidOnFrame.axiomK_set) f;
  use œÜ, œà;

protected lemma nec (h : C ‚äß œÜ) : C ‚äß ‚ñ°œÜ := by
  intro _ hF;
  apply ValidOnFrame.nec;
  exact h hF;

protected lemma mdp (hpq : C ‚äß œÜ ‚ûù œà) (hp : C ‚äß œÜ) : C ‚äß œà := by
  intro _ hF;
  exact Formula.Kripke.ValidOnFrame.mdp (hpq hF) (hp hF)

lemma iff_not_validOnFrameClass : ¬¨(C ‚äß œÜ) ‚Üî ‚àÉ F ‚àà C, ‚àÉ V x, ¬¨Satisfies ‚ü®F, V‚ü© x œÜ := by
  simp [ValidOnFrame, ValidOnModel, Satisfies];
  tauto;

lemma iff_not_set_validOnFrameClass : ¬¨(C ‚äß* T) ‚Üî ‚àÉ œÜ ‚àà T, ‚àÉ F ‚àà C, ‚àÉ V x, ¬¨Satisfies ‚ü®F, V‚ü© x œÜ := by
  simp [Semantics.realizeSet_iff, ValidOnFrame, ValidOnModel, Satisfies];
  tauto;

lemma iff_not_validOnFrame : ¬¨(F ‚äß* T) ‚Üî ‚àÉ œÜ ‚àà T, ‚àÉ V x, ¬¨Satisfies ‚ü®F, V‚ü© x œÜ := by
  simp [Semantics.realizeSet_iff, ValidOnFrame, ValidOnModel, Satisfies];
  tauto;



abbrev FrameClassOfTheory (T : Theory ‚Ñï) : FrameClass := { F | F ‚äß* T }
notation "ùîΩ(" T ")"  => FrameClassOfTheory T

abbrev FiniteFrameClassOfTheory (T : Theory ‚Ñï) : FiniteFrameClass := { FF | FF.toFrame ‚äß* T }
notation "ùîΩÍü≥(" T ")"  => FiniteFrameClassOfTheory T

def definability_union_frameclass_of_theory {T‚ÇÅ T‚ÇÇ : Theory ‚Ñï}
  (defi‚ÇÅ : ùîΩ(T‚ÇÅ).DefinedBy ùîΩ‚ÇÅ) (defi‚ÇÇ : ùîΩ(T‚ÇÇ).DefinedBy ùîΩ‚ÇÇ) (nonempty : (ùîΩ‚ÇÅ ‚à© ùîΩ‚ÇÇ).Nonempty)
  : ùîΩ(T‚ÇÅ ‚à™ T‚ÇÇ).DefinedBy (ùîΩ‚ÇÅ ‚à© ùîΩ‚ÇÇ) where
  define := by
    simp;
    intro F;
    constructor;
    . rintro ‚ü®hF‚ÇÅ, hF‚ÇÇ‚ü©;
      constructor;
      . simpa using defi‚ÇÅ.define.mp hF‚ÇÅ;
      . simpa using defi‚ÇÇ.define.mp hF‚ÇÇ;
    . rintro ‚ü®hF‚ÇÅ, hF‚ÇÇ‚ü©;
      constructor;
      . exact defi‚ÇÅ.define.mpr hF‚ÇÅ;
      . exact defi‚ÇÇ.define.mpr hF‚ÇÇ;
  nonempty := nonempty

def characterizability_union_frameclass_of_theory {T‚ÇÅ T‚ÇÇ : Theory ‚Ñï}
  (char‚ÇÅ : ùîΩ(T‚ÇÅ).Characteraizable ùîΩ‚ÇÅ) (char‚ÇÇ : ùîΩ(T‚ÇÇ).Characteraizable ùîΩ‚ÇÇ)
  (nonempty : (ùîΩ‚ÇÅ ‚à© ùîΩ‚ÇÇ).Nonempty)
  : ùîΩ(T‚ÇÅ ‚à™ T‚ÇÇ).Characteraizable (ùîΩ‚ÇÅ ‚à© ùîΩ‚ÇÇ) where
  characterize := by
    simp;
    intro F hF‚ÇÅ hF‚ÇÇ;
    constructor;
    . simpa using char‚ÇÅ.characterize hF‚ÇÅ;
    . simpa using char‚ÇÇ.characterize hF‚ÇÇ;
  nonempty := nonempty

abbrev FrameClassOfHilbert (H : Hilbert ‚Ñï) : FrameClass.Dep ‚Ñï := ùîΩ(H.theorems)
notation "ùîΩ(" H ")"  => FrameClassOfHilbert H

open Hilbert.Deduction

instance {Ax : Theory ‚Ñï} {ùîΩ : FrameClass} [defi : ùîΩ(Ax).DefinedBy ùîΩ] : ùîΩ(Hilbert.ExtK Ax).DefinedBy ùîΩ where
  define := by
    simp only [Hilbert.theorems, System.theory, Semantics.RealizeSet.setOf_iff, ValidOnFrame.models_iff, Set.mem_setOf_eq];
    intro F;
    constructor;
    . intro h;
      apply defi.define.mp;
      constructor;
      intro œÜ hp;
      exact h œÜ $ maxm! $ by right; exact hp;
    . intro hF œÜ hp;
      induction hp using inducition_with_necOnly! with
      | hMaxm h =>
        simp at h;
        rcases h with (‚ü®_, _, rfl‚ü© | hR);
        . simp_all [ValidOnFrame, ValidOnModel, Satisfies];
        . have := defi.define.mpr hF
          simp at this;
          exact this.RealizeSet hR;
      | hMdp ihpq ihp => exact Formula.Kripke.ValidOnFrame.mdp ihpq ihp;
      | hNec ih => exact Formula.Kripke.ValidOnFrame.nec ih;
      | _ => first
        | exact Formula.Kripke.ValidOnFrame.imply‚ÇÅ;
        | exact Formula.Kripke.ValidOnFrame.imply‚ÇÇ;
        | exact Formula.Kripke.ValidOnFrame.elimContra;
  nonempty := defi.nonempty

instance {Ax : Theory ‚Ñï} {ùîΩ : FrameClass} [char : ùîΩ(Ax).Characteraizable ùîΩ] : ùîΩ(Hilbert.ExtK Ax).Characteraizable ùîΩ where
  characterize := by
    simp only [Hilbert.theorems, System.theory, Semantics.RealizeSet.setOf_iff, ValidOnFrame.models_iff, Set.mem_setOf_eq];
    intro F hF œÜ hp;
    induction hp using inducition_with_necOnly! with
    | hMaxm h =>
      simp at h;
      rcases h with (‚ü®_, _, rfl‚ü© | hR);
      . simp_all [ValidOnFrame, ValidOnModel, Satisfies];
      . have := char.characterize hF
        simp at this;
        exact this.RealizeSet hR;
    | hMdp ihpq ihp => exact Formula.Kripke.ValidOnFrame.mdp ihpq ihp;
    | hNec ih => exact Formula.Kripke.ValidOnFrame.nec ih;
    | _ => first
      | exact Formula.Kripke.ValidOnFrame.imply‚ÇÅ;
      | exact Formula.Kripke.ValidOnFrame.imply‚ÇÇ;
      | exact Formula.Kripke.ValidOnFrame.elimContra;
  nonempty := char.nonempty


abbrev FiniteFrameClassOfHilbert (H : Hilbert ‚Ñï) : FiniteFrameClass.Dep ‚Ñï := ùîΩ(H)Íü≥
notation "ùîΩÍü≥(" H ")"  => FiniteFrameClassOfHilbert H

instance {Ax : Set (Formula ‚Ñï)} {ùîΩ : FiniteFrameClass}  [defi : ùîΩÍü≥(Ax).DefinedBy ùîΩ] : ùîΩÍü≥(Hilbert.ExtK Ax).DefinedBy ùîΩ where
  define := by
    simp only [Hilbert.theorems, System.theory, Semantics.RealizeSet.setOf_iff, ValidOnFrame.models_iff, Set.mem_setOf_eq];
    intro F;
    constructor;
    . intro h;
      apply defi.define.mp;
      constructor;
      intro œÜ hp;
      exact h œÜ $ maxm! $ by right; exact hp;
    . intro hF œÜ hp;
      induction hp using inducition_with_necOnly! with
      | hMaxm h =>
        simp at h;
        rcases h with (‚ü®_, _, rfl‚ü© | hR);
        . simp_all [ValidOnFrame, ValidOnModel, Satisfies];
        . have := defi.define.mpr hF
          simp at this;
          exact this.RealizeSet hR;
      | hMdp ihpq ihp => exact Formula.Kripke.ValidOnFrame.mdp ihpq ihp;
      | hNec ih => exact Formula.Kripke.ValidOnFrame.nec ih;
      | _ => first
        | exact Formula.Kripke.ValidOnFrame.imply‚ÇÅ;
        | exact Formula.Kripke.ValidOnFrame.imply‚ÇÇ;
        | exact Formula.Kripke.ValidOnFrame.elimContra;
  nonempty := defi.nonempty

instance {Ax : Set (Formula ‚Ñï)} {ùîΩ : FiniteFrameClass} [char : ùîΩÍü≥(Ax).Characteraizable ùîΩ] : ùîΩÍü≥(Hilbert.ExtK Ax).Characteraizable ùîΩ where
  characterize := by
    simp only [Hilbert.theorems, System.theory, Semantics.RealizeSet.setOf_iff, ValidOnFrame.models_iff, Set.mem_setOf_eq];
    intro F hF œÜ hp;
    induction hp using inducition_with_necOnly! with
    | hMaxm h =>
      simp at h;
      rcases h with (‚ü®_, _, rfl‚ü© | hR);
      . simp_all [ValidOnFrame, ValidOnModel, Satisfies];
      . have := char.characterize hF
        simp at this;
        exact this.RealizeSet hR;
    | hMdp ihpq ihp => exact Formula.Kripke.ValidOnFrame.mdp ihpq ihp;
    | hNec ih => exact Formula.Kripke.ValidOnFrame.nec ih;
    | _ => first
      | exact Formula.Kripke.ValidOnFrame.imply‚ÇÅ;
      | exact Formula.Kripke.ValidOnFrame.imply‚ÇÇ;
      | exact Formula.Kripke.ValidOnFrame.elimContra;
  nonempty := char.nonempty

section sound

variable {‚Ñï : Type u}
variable {H : Hilbert ‚Ñï} {œÜ : Formula ‚Ñï}

lemma sound : H ‚ä¢! œÜ ‚Üí ùîΩ(H) ‚äß œÜ := by
  intro hp F hF;
  simp [Hilbert.theorems, System.theory] at hF;
  exact hF œÜ hp;
instance : Sound H ùîΩ(H) := ‚ü®sound‚ü©

lemma sound_finite : H ‚ä¢! œÜ ‚Üí ùîΩÍü≥(H) ‚äß œÜ := by
  intro hp F hF;
  simp [Hilbert.theorems, System.theory] at hF;
  obtain ‚ü®FF, hFF‚ÇÅ, rfl‚ü© := hF;
  exact hFF‚ÇÅ œÜ hp;
instance : Sound H ùîΩÍü≥(H) := ‚ü®sound_finite‚ü©

lemma unprovable_bot (hc : ùîΩ(H).Nonempty) : H ‚ä¨ ‚ä• := by
  apply (not_imp_not.mpr (sound (‚Ñï := ‚Ñï)));
  simp [Semantics.Realize];
  obtain ‚ü®F, hF‚ü© := hc;
  use F;
  constructor;
  . exact hF;
  . exact Semantics.Bot.realize_bot (F := Formula ‚Ñï) (M := Kripke.Frame) F;
instance (hc : ùîΩ(H).Nonempty) : System.Consistent H := System.Consistent.of_unprovable $ unprovable_bot hc

lemma unprovable_bot_finite (hc : ùîΩÍü≥(H).Nonempty) : H ‚ä¨ ‚ä• := by
  apply (not_imp_not.mpr (sound_finite (‚Ñï := ‚Ñï)));
  simp [Semantics.Realize];
  obtain ‚ü®F, hF‚ü© := hc;
  use F;
  constructor;
  . exact hF;
  . exact Semantics.Bot.realize_bot (F := Formula ‚Ñï) (M := Kripke.Frame) F;
instance (hc : ùîΩÍü≥(H).Nonempty) : System.Consistent H := System.Consistent.of_unprovable $ unprovable_bot_finite hc

lemma sound_of_characterizability {ùîΩ : FrameClass} [char : ùîΩ(H).Characteraizable ùîΩ]
  : H ‚ä¢! œÜ ‚Üí ùîΩ ‚äß œÜ := by
  intro h F hF;
  apply sound h;
  apply char.characterize hF;
instance {ùîΩ : FrameClass} [ùîΩ(H).Characteraizable ùîΩ] : Sound H ùîΩ := ‚ü®sound_of_characterizability‚ü©

lemma sound_of_finite_characterizability {ùîΩ : FiniteFrameClass} [char : ùîΩÍü≥(H).Characteraizable ùîΩ]
  : H ‚ä¢! œÜ ‚Üí ùîΩ ‚äß œÜ := by
  intro h F hF;
  apply sound_finite h;
  obtain ‚ü®FF, hFF, rfl‚ü© := hF;
  use FF;
  constructor;
  . exact char.characterize hFF;
  . rfl;
instance {ùîΩ : FiniteFrameClass} [ùîΩÍü≥(H).Characteraizable ùîΩ] : Sound H ùîΩ := ‚ü®sound_of_finite_characterizability‚ü©

lemma unprovable_bot_of_characterizability {ùîΩ : FrameClass} [char : ùîΩ(H).Characteraizable ùîΩ] : H ‚ä¨ ‚ä• := by
  apply unprovable_bot;
  obtain ‚ü®F, hF‚ü© := char.nonempty;
  use F;
  apply char.characterize hF;
instance [FrameClass.Characteraizable.{u} ùîΩ(H) ùîΩ] : System.Consistent H
  := System.Consistent.of_unprovable $ unprovable_bot_of_characterizability

lemma unprovable_bot_of_finite_characterizability {ùîΩ : FiniteFrameClass}  [char : ùîΩÍü≥(H).Characteraizable ùîΩ] : H ‚ä¨ ‚ä• := by
  apply unprovable_bot_finite;
  obtain ‚ü®F, hF‚ü© := char.nonempty;
  use F;
  apply char.characterize hF;
instance {ùîΩ : FiniteFrameClass} [FiniteFrameClass.Characteraizable.{u} ùîΩÍü≥(H) ùîΩ] : System.Consistent H
  := System.Consistent.of_unprovable $ unprovable_bot_of_finite_characterizability

end sound

instance empty_axiom_definability : ùîΩ((‚àÖ : Theory ‚Ñï)).DefinedBy AllFrameClass where
  define := by simp;
  nonempty :=  ‚ü®‚ü®PUnit,  Œª _ _ => True‚ü©, trivial‚ü©

private instance K_definability' : ùîΩ(((Hilbert.ExtK ‚àÖ) : Hilbert ‚Ñï)).DefinedBy AllFrameClass := inferInstance

instance K_definability : ùîΩ(Hilbert.K ‚Ñï).DefinedBy AllFrameClass := by
  convert K_definability';
  exact Hilbert.ExtK.K_is_extK_of_empty;

instance K_sound : Sound (Hilbert.K ‚Ñï) (AllFrameClass) := inferInstance

instance K_consistent : System.Consistent (Hilbert.K ‚Ñï) := inferInstance


lemma restrict_finite : C ‚äß œÜ ‚Üí CÍü≥ ‚äß œÜ := by
  intro h F hF;
  obtain ‚ü®FF, hFF‚ÇÅ, rfl‚ü© := hF;
  exact h (by simpa)

instance {H : Hilbert ‚Ñï} [sound : Sound H C] : Sound H CÍü≥ := ‚ü®by
  intro œÜ h;
  exact restrict_finite $ sound.sound h;
‚ü©

instance : Sound (Hilbert.K ‚Ñï) (AllFrameClassÍü≥) := inferInstance

lemma exists_finite_frame : ¬¨CÍü≥ ‚äß œÜ ‚Üî ‚àÉ F ‚àà ùîΩÍü≥, ¬¨F ‚äß œÜ := by simp;

class FiniteFrameProperty (H : Hilbert ‚Ñï) (ùîΩ : FrameClass) where
  [complete : Complete H ùîΩÍü≥]
  [sound : Sound H ùîΩÍü≥]

end Kripke



namespace Hilbert

section

open Formula (atom)
open Formula.Kripke
open Kripke (K_sound)

theorem K_strictlyWeakerThan_KD [DecidableEq ‚Ñï] [Inhabited ‚Ñï] : (Hilbert.K ‚Ñï) <‚Çõ (Hilbert.KD ‚Ñï) := by
  constructor;
  . apply K_weakerThan_KD;
  . simp [weakerThan_iff];
    use (‚ñ°(atom default) ‚ûù ‚óá(atom default));
    constructor;
    . exact Deduction.maxm! (by simp);
    . apply K_sound.not_provable_of_countermodel;
      simp [ValidOnFrame, ValidOnModel];
      use ‚ü®Fin 1, Œª _ _ => False‚ü©, (Œª w _ => w = 0), 0;
      simp [Satisfies];

theorem K_strictlyWeakerThan_KB [DecidableEq ‚Ñï] [Inhabited ‚Ñï] : (Hilbert.K ‚Ñï) <‚Çõ (Hilbert.KB ‚Ñï) := by
  constructor;
  . apply K_weakerThan_KB;
  . simp [weakerThan_iff];
    use ((atom default) ‚ûù ‚ñ°‚óá(atom default));
    constructor;
    . exact Deduction.maxm! (by simp);
    . apply K_sound.not_provable_of_countermodel;
      simp [ValidOnFrame, ValidOnModel];
      use ‚ü®Fin 2, Œª x y => x = 0 ‚àß y = 1‚ü©, (Œª w _ => w = 0), 0;
      simp [Satisfies];
      use 1;

theorem K_strictlyWeakerThan_K4 [DecidableEq ‚Ñï] [Inhabited ‚Ñï] : (Hilbert.K ‚Ñï) <‚Çõ (Hilbert.K4 ‚Ñï) := by
  constructor;
  . apply K_weakerThan_K4;
  . simp [weakerThan_iff];
    use (‚ñ°(atom default) ‚ûù ‚ñ°‚ñ°(atom default));
    constructor;
    . exact Deduction.maxm! (by simp);
    . apply K_sound.not_provable_of_countermodel;
      simp [ValidOnFrame, ValidOnModel];
      use ‚ü®Fin 2, Œª x y => x ‚â† y‚ü©, (Œª w _ => w = 1), 0;
      simp [Satisfies];
      constructor;
      . intro y;
        match y with
        | 0 => aesop;
        | 1 => simp;
      . use 1;
        constructor;
        . aesop;
        . use 0; aesop;

theorem K_strictlyWeakerThan_K5 [DecidableEq ‚Ñï] [Inhabited ‚Ñï] : (Hilbert.K ‚Ñï) <‚Çõ (Hilbert.K5 ‚Ñï)  := by
  constructor;
  . apply K_weakerThan_K5;
  . simp [weakerThan_iff];
    use (‚óá(atom default) ‚ûù ‚ñ°‚óá(atom default));
    constructor;
    . exact Deduction.maxm! (by simp);
    . apply K_sound.not_provable_of_countermodel;
      simp [ValidOnFrame, ValidOnModel];
      use ‚ü®Fin 2, Œª x _ => x = 0‚ü©, (Œª w _ => w = 0), 0;
      simp [Satisfies];
      use 1;
      simp;

end


section

variable {Ax‚ÇÅ Ax‚ÇÇ : Theory ‚Ñï} (ùîΩ‚ÇÅ ùîΩ‚ÇÇ : FrameClass)

lemma weakerThan_of_subset_FrameClass
  [sound‚ÇÅ : Sound (Hilbert.ExtK Ax‚ÇÅ) ùîΩ‚ÇÅ] [complete‚ÇÇ : Complete (Hilbert.ExtK Ax‚ÇÇ) ùîΩ‚ÇÇ]
  (hùîΩ : ùîΩ‚ÇÇ ‚äÜ ùîΩ‚ÇÅ)
  : (Hilbert.ExtK Ax‚ÇÅ) ‚â§‚Çõ (Hilbert.ExtK Ax‚ÇÇ) := by
  apply System.weakerThan_iff.mpr;
  intro œÜ hp;
  apply complete‚ÇÇ.complete;
  intro F hF;
  exact sound‚ÇÅ.sound hp $ hùîΩ hF;

lemma equiv_of_eq_FrameClass
  [sound‚ÇÅ : Sound (Hilbert.ExtK Ax‚ÇÅ) ùîΩ‚ÇÅ] [sound‚ÇÇ : Sound (Hilbert.ExtK Ax‚ÇÇ) ùîΩ‚ÇÇ]
  [complete‚ÇÅ : Complete (Hilbert.ExtK Ax‚ÇÅ) ùîΩ‚ÇÅ] [complete‚ÇÇ : Complete (Hilbert.ExtK Ax‚ÇÇ) ùîΩ‚ÇÇ]
  (hùîΩ : ùîΩ‚ÇÅ = ùîΩ‚ÇÇ) : (Hilbert.ExtK Ax‚ÇÅ) =‚Çõ (Hilbert.ExtK Ax‚ÇÇ) := by
  apply System.Equiv.antisymm_iff.mpr;
  constructor;
  . apply weakerThan_of_subset_FrameClass ùîΩ‚ÇÅ ùîΩ‚ÇÇ; subst_vars; rfl;
  . apply weakerThan_of_subset_FrameClass ùîΩ‚ÇÇ ùîΩ‚ÇÅ; subst_vars; rfl;

end

end Hilbert
-/

end LO.Modal
