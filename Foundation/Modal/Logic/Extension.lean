import Foundation.Logic.HilbertStyle.Supplemental
import Foundation.Modal.Logic.Basic
import Foundation.Meta.ClProver

namespace LO.Modal

open LO.Entailment LO.Modal.Entailment

variable {L L‚ÇÄ L‚ÇÅ L‚ÇÇ L‚ÇÉ : Logic Œ±}

namespace Logic


section

variable [DecidableEq Œ±] [L.IsQuasiNormal]

lemma lconj_subst {X : List (Formula Œ±)} {s : Substitution Œ±} : L ‚ä¢! (X.map (¬∑‚ü¶s‚üß)).conj‚ÇÇ ‚ûù X.conj‚ÇÇ‚ü¶s‚üß := by
  induction X using List.induction_with_singleton with
  | hnil => simp;
  | hsingle => simp;
  | hcons œÜ X hœÜ ih =>
    suffices L ‚ä¢! œÜ‚ü¶s‚üß ‚ãè ‚ãÄ(X.map (¬∑‚ü¶s‚üß)) ‚ûù œÜ‚ü¶s‚üß ‚ãè (‚ãÄX)‚ü¶s‚üß by
      simpa [List.conj‚ÇÇ_cons_nonempty hœÜ, List.conj‚ÇÇ_cons_nonempty (show X.map (¬∑‚ü¶s‚üß) ‚â† [] by simpa), -iff_provable];
    cl_prover [ih];

lemma fconj_subst {X : Finset (Formula Œ±)} {s : Substitution Œ±} : L ‚ä¢! (X.image (¬∑‚ü¶s‚üß)).conj ‚ûù X.conj‚ü¶s‚üß := by
  apply C!_trans ?_ $ lconj_subst (L := L) (X := X.toList) (s := s);
  apply right_Conj‚ÇÇ!_intro;
  intro œÜ hœÜ;
  apply left_Fconj!_intro;
  simp_all;

end


inductive sumQuasiNormal (L‚ÇÅ L‚ÇÇ : Logic Œ±) : Logic Œ±
  | mem‚ÇÅ {œÜ}    : L‚ÇÅ ‚ä¢! œÜ ‚Üí sumQuasiNormal L‚ÇÅ L‚ÇÇ œÜ
  | mem‚ÇÇ {œÜ}    : L‚ÇÇ ‚ä¢! œÜ ‚Üí sumQuasiNormal L‚ÇÅ L‚ÇÇ œÜ
  | mdp  {œÜ œà}  : sumQuasiNormal L‚ÇÅ L‚ÇÇ (œÜ ‚ûù œà) ‚Üí sumQuasiNormal L‚ÇÅ L‚ÇÇ œÜ ‚Üí sumQuasiNormal L‚ÇÅ L‚ÇÇ œà
  | subst {œÜ s} : sumQuasiNormal L‚ÇÅ L‚ÇÇ œÜ ‚Üí sumQuasiNormal L‚ÇÅ L‚ÇÇ (œÜ‚ü¶s‚üß)

namespace sumQuasiNormal

variable {œÜ œà : Formula Œ±}

lemma mem‚ÇÅ! (hœÜ : L‚ÇÅ ‚ä¢! œÜ) : sumQuasiNormal L‚ÇÅ L‚ÇÇ ‚ä¢! œÜ := by
  apply iff_provable.mpr;
  apply sumQuasiNormal.mem‚ÇÅ hœÜ;

lemma mem‚ÇÇ! (hœÜ : L‚ÇÇ ‚ä¢! œÜ) : sumQuasiNormal L‚ÇÅ L‚ÇÇ ‚ä¢! œÜ := by
  apply iff_provable.mpr;
  apply sumQuasiNormal.mem‚ÇÇ hœÜ;

instance : Entailment.ModusPonens (sumQuasiNormal L‚ÇÅ L‚ÇÇ) where
  mdp hœÜœà hœÜ := by
    constructor;
    apply sumQuasiNormal.mdp;
    . exact PLift.down hœÜœà;
    . exact PLift.down hœÜ;

instance : (sumQuasiNormal L‚ÇÅ L‚ÇÇ).Substitution where
  subst s hœÜ := by
    constructor;
    apply sumQuasiNormal.subst;
    exact PLift.down hœÜ;

lemma rec!
  {motive : (œÜ : Formula Œ±) ‚Üí ((sumQuasiNormal L‚ÇÅ L‚ÇÇ) ‚ä¢! œÜ) ‚Üí Sort}
  (mem‚ÇÅ  : ‚àÄ {œÜ}, (h : L‚ÇÅ ‚ä¢! œÜ) ‚Üí motive œÜ (mem‚ÇÅ! h))
  (mem‚ÇÇ  : ‚àÄ {œÜ}, (h : L‚ÇÇ ‚ä¢! œÜ) ‚Üí motive œÜ (mem‚ÇÇ! h))
  (mdp   : ‚àÄ {œÜ œà : Formula Œ±},
           {hœÜœà : (sumQuasiNormal L‚ÇÅ L‚ÇÇ) ‚ä¢! œÜ ‚ûù œà} ‚Üí {hœÜ : (sumQuasiNormal L‚ÇÅ L‚ÇÇ) ‚ä¢! œÜ} ‚Üí
          motive (œÜ ‚ûù œà) hœÜœà ‚Üí motive œÜ hœÜ ‚Üí motive œà (hœÜœà ‚®Ä hœÜ)
  )
  (subst : ‚àÄ {œÜ s}, {hœÜ : (sumQuasiNormal L‚ÇÅ L‚ÇÇ) ‚ä¢! œÜ} ‚Üí (motive œÜ hœÜ) ‚Üí motive (œÜ‚ü¶s‚üß) (Logic.subst! _ hœÜ))
  : ‚àÄ {œÜ}, (h : sumQuasiNormal L‚ÇÅ L‚ÇÇ ‚ä¢! œÜ) ‚Üí motive œÜ h := by
  intro _ hœÜ;
  induction (iff_provable.mp $ hœÜ) with
  | mem‚ÇÅ h => apply mem‚ÇÅ h;
  | mem‚ÇÇ h => apply mem‚ÇÇ h;
  | mdp hœÜœà hœÜ ihœÜœà ihœÜ =>
    apply mdp;
    . apply ihœÜœà;
    . apply ihœÜ;
    . apply iff_provable.mpr; assumption;
    . apply iff_provable.mpr; assumption;
  | subst hœÜ ihœÜ =>
    apply subst;
    . apply ihœÜ;
    . apply iff_provable.mpr; assumption;

lemma symm : sumQuasiNormal L‚ÇÅ L‚ÇÇ = sumQuasiNormal L‚ÇÇ L‚ÇÅ := by
  ext œÜ;
  constructor;
  . intro h;
    induction h with
    | mem‚ÇÅ h => exact sumQuasiNormal.mem‚ÇÇ h;
    | mem‚ÇÇ h => exact sumQuasiNormal.mem‚ÇÅ h;
    | mdp _ _ ihœÜœà ihœÜ => exact sumQuasiNormal.mdp ihœÜœà ihœÜ;
    | subst _ ihœÜ => exact sumQuasiNormal.subst ihœÜ;
  . intro h;
    induction h with
    | mem‚ÇÅ h => exact sumQuasiNormal.mem‚ÇÇ h;
    | mem‚ÇÇ h => exact sumQuasiNormal.mem‚ÇÅ h;
    | mdp _ _ ihœÜœà ihœÜ => exact sumQuasiNormal.mdp ihœÜœà ihœÜ;
    | subst _ ihœÜ => exact sumQuasiNormal.subst ihœÜ;

variable [DecidableEq Œ±]

instance [Entailment.Cl L‚ÇÅ] : Entailment.Lukasiewicz (sumQuasiNormal L‚ÇÅ L‚ÇÇ) where
  imply‚ÇÅ _ _ := by constructor; apply sumQuasiNormal.mem‚ÇÅ; simp;
  imply‚ÇÇ _ _ _ := by constructor; apply sumQuasiNormal.mem‚ÇÅ; simp;
  elimContra _ _ := by constructor; apply sumQuasiNormal.mem‚ÇÅ; simp;

instance [L‚ÇÅ.IsQuasiNormal] : (sumQuasiNormal L‚ÇÅ L‚ÇÇ).IsQuasiNormal where
  K _ _ := by constructor; apply sumQuasiNormal.mem‚ÇÅ; simp;
  subst s hœÜ := by
    constructor;
    apply sumQuasiNormal.subst;
    exact PLift.down hœÜ;

instance [L‚ÇÇ.IsQuasiNormal] : (sumQuasiNormal L‚ÇÅ L‚ÇÇ).IsQuasiNormal := by
  rw [sumQuasiNormal.symm];
  infer_instance;

instance : L‚ÇÅ ‚™Ø sumQuasiNormal L‚ÇÅ L‚ÇÇ := by
  apply weakerThan_iff.mpr;
  intro œÜ hœÜ;
  exact mem‚ÇÅ! hœÜ;

instance : L‚ÇÇ ‚™Ø sumQuasiNormal L‚ÇÅ L‚ÇÇ := by
  rw [sumQuasiNormal.symm];
  infer_instance;

omit [DecidableEq Œ±] in
lemma iff_subset {X Y} : L.sumQuasiNormal Y ‚äÜ L.sumQuasiNormal X ‚Üî ‚àÄ œà ‚àà Y, L.sumQuasiNormal X ‚ä¢! œà := by
  suffices (‚àÄ œÜ, L.sumQuasiNormal Y ‚ä¢! œÜ ‚Üí L.sumQuasiNormal X ‚ä¢! œÜ) ‚Üî (‚àÄ œà ‚àà Y, L.sumQuasiNormal X ‚ä¢! œà) by
    apply Iff.trans ?_ this;
    constructor;
    . intro h œà; simpa using @h œà;
    . intro h œà; simpa using @h œà;
  constructor;
  . intro h œà hœà;
    apply h;
    apply Logic.sumQuasiNormal.mem‚ÇÇ!
    simpa using hœà;
  . intro h œà hœà;
    induction hœà using Logic.sumQuasiNormal.rec! with
    | mem‚ÇÅ hœà => apply Logic.sumQuasiNormal.mem‚ÇÅ! hœà;
    | mem‚ÇÇ hœà => apply h; simpa using hœà;
    | mdp ihœÜœà ihœÜ => exact ihœÜœà ‚®Ä ihœÜ;
    | subst ihœÜ => apply Logic.subst!; assumption;

section

variable [L‚ÇÅ.IsQuasiNormal]

open LO.Entailment

lemma provable_of_finite_provable : (‚àÉ X : Finset _, (X.toSet ‚äÜ L‚ÇÇ) ‚àß L‚ÇÅ ‚ä¢! X.conj ‚ûù œÜ) ‚Üí sumQuasiNormal L‚ÇÅ L‚ÇÇ ‚ä¢! œÜ := by
  rintro ‚ü®X, hX‚ÇÇ, hœÜ‚ü©;
  apply (WeakerThan.pbl (ùì£ := sumQuasiNormal L‚ÇÅ L‚ÇÇ) hœÜ) ‚®Ä ?_;
  apply FConj!_iff_forall_provable.mpr;
  intro œá hœá;
  apply mem‚ÇÇ!;
  apply iff_provable.mpr;
  apply hX‚ÇÇ hœá;

lemma finite_provable_of_provable (h : ‚àÄ Œæ ‚àà L‚ÇÇ, ‚àÄ s : Substitution _, Œæ‚ü¶s‚üß ‚àà L‚ÇÇ) :
  sumQuasiNormal L‚ÇÅ L‚ÇÇ ‚ä¢! œÜ ‚Üí ‚àÉ X : Finset _, (‚ÜëX ‚äÜ L‚ÇÇ) ‚àß L‚ÇÅ ‚ä¢! X.conj ‚ûù œÜ := by
  intro h;
  induction h using sumQuasiNormal.rec! with
  | mem‚ÇÅ h =>
    use ‚àÖ;
    constructor;
    . tauto;
    . cl_prover [h];
  | @mem‚ÇÇ œÜ h =>
    use {œÜ};
    constructor;
    . simpa using h;
    . simp;
  | @mdp œÜ œà _ _ ihœÜœà ihœÜ =>
    obtain ‚ü®X‚ÇÅ, _, hœÜœà‚ü© := ihœÜœà;
    obtain ‚ü®X‚ÇÇ, _, hœÜ‚ü© := ihœÜ;
    use X‚ÇÅ ‚à™ X‚ÇÇ;
    constructor;
    . simp_all;
    . suffices L‚ÇÅ ‚ä¢! (X‚ÇÅ.conj ‚ãè X‚ÇÇ.conj) ‚ûù œà by exact C!_trans CFconjUnionKFconj! this;
      cl_prover [hœÜœà, hœÜ];
  | @subst _ s _ ihœÜ =>
    obtain ‚ü®X, hX, hœÜ‚ü© := ihœÜ;
    use X.image (¬∑‚ü¶s‚üß);
    constructor;
    . intro Œæ hŒæ;
      obtain ‚ü®Œæ, _, rfl‚ü© : ‚àÉ x ‚àà X, x‚ü¶s‚üß = Œæ := by simpa using hŒæ;
      apply h;
      apply hX;
      assumption;
    . apply C!_trans ?_ (subst! s hœÜ);
      exact Logic.fconj_subst;

lemma iff_provable_finite_provable (h : ‚àÄ Œæ ‚àà L‚ÇÇ, ‚àÄ s : Substitution _, Œæ‚ü¶s‚üß ‚àà L‚ÇÇ)  :
  sumQuasiNormal L‚ÇÅ L‚ÇÇ ‚ä¢! œÜ ‚Üî ‚àÉ X : Finset _, (‚ÜëX ‚äÜ L‚ÇÇ) ‚àß L‚ÇÅ ‚ä¢! X.conj ‚ûù œÜ := ‚ü®finite_provable_of_provable h, provable_of_finite_provable‚ü©

end

end sumQuasiNormal

inductive sumNormal (L‚ÇÅ L‚ÇÇ : Logic Œ±) : Logic Œ±
  | mem‚ÇÅ {œÜ}    : L‚ÇÅ ‚ä¢! œÜ ‚Üí sumNormal L‚ÇÅ L‚ÇÇ œÜ
  | mem‚ÇÇ {œÜ}    : L‚ÇÇ ‚ä¢! œÜ ‚Üí sumNormal L‚ÇÅ L‚ÇÇ œÜ
  | mdp  {œÜ œà}  : sumNormal L‚ÇÅ L‚ÇÇ (œÜ ‚ûù œà) ‚Üí sumNormal L‚ÇÅ L‚ÇÇ œÜ ‚Üí sumNormal L‚ÇÅ L‚ÇÇ œà
  | subst {œÜ s} : sumNormal L‚ÇÅ L‚ÇÇ œÜ ‚Üí sumNormal L‚ÇÅ L‚ÇÇ (œÜ‚ü¶s‚üß)
  | nec {œÜ}     : sumNormal L‚ÇÅ L‚ÇÇ œÜ ‚Üí sumNormal L‚ÇÅ L‚ÇÇ (‚ñ°œÜ)

namespace sumNormal

variable {œÜ œà : Formula Œ±}

lemma mem‚ÇÅ! (hœÜ : L‚ÇÅ ‚ä¢! œÜ) : sumNormal L‚ÇÅ L‚ÇÇ ‚ä¢! œÜ := by
  apply iff_provable.mpr;
  apply sumNormal.mem‚ÇÅ hœÜ;

lemma mem‚ÇÇ! (hœÜ : L‚ÇÇ ‚ä¢! œÜ) : sumNormal L‚ÇÅ L‚ÇÇ ‚ä¢! œÜ := by
  apply iff_provable.mpr;
  apply sumNormal.mem‚ÇÇ hœÜ;

instance : Entailment.ModusPonens (sumNormal L‚ÇÅ L‚ÇÇ) where
  mdp hœÜœà hœÜ := by
    constructor;
    apply sumNormal.mdp;
    . exact PLift.down hœÜœà;
    . exact PLift.down hœÜ;

instance : Entailment.Necessitation (sumNormal L‚ÇÅ L‚ÇÇ) where
  nec hœÜ := by
    constructor;
    apply sumNormal.nec;
    exact PLift.down hœÜ;

instance : (sumNormal L‚ÇÅ L‚ÇÇ).Substitution where
  subst s hœÜ := by
    constructor;
    apply sumNormal.subst;
    exact PLift.down hœÜ;


lemma rec!
  {motive : (œÜ : Formula Œ±) ‚Üí ((sumNormal L‚ÇÅ L‚ÇÇ) ‚ä¢! œÜ) ‚Üí Sort}
  (mem‚ÇÅ  : ‚àÄ {œÜ}, (h : L‚ÇÅ ‚ä¢! œÜ) ‚Üí motive œÜ (mem‚ÇÅ! h))
  (mem‚ÇÇ  : ‚àÄ {œÜ}, (h : L‚ÇÇ ‚ä¢! œÜ) ‚Üí motive œÜ (mem‚ÇÇ! h))
  (mdp   : ‚àÄ {œÜ œà : Formula Œ±},
           {hœÜœà : (sumNormal L‚ÇÅ L‚ÇÇ) ‚ä¢! œÜ ‚ûù œà} ‚Üí {hœÜ : (sumNormal L‚ÇÅ L‚ÇÇ) ‚ä¢! œÜ} ‚Üí
          motive (œÜ ‚ûù œà) hœÜœà ‚Üí motive œÜ hœÜ ‚Üí motive œà (hœÜœà ‚®Ä hœÜ)
  )
  (nec   : ‚àÄ {œÜ}, {hœÜ : (sumNormal L‚ÇÅ L‚ÇÇ) ‚ä¢! œÜ} ‚Üí (motive œÜ hœÜ) ‚Üí motive (‚ñ°œÜ) (Entailment.nec! hœÜ))
  (subst : ‚àÄ {œÜ s}, {hœÜ : (sumNormal L‚ÇÅ L‚ÇÇ) ‚ä¢! œÜ} ‚Üí (motive œÜ hœÜ) ‚Üí motive (œÜ‚ü¶s‚üß) (Logic.subst! _ hœÜ))
  : ‚àÄ {œÜ}, (h : sumNormal L‚ÇÅ L‚ÇÇ ‚ä¢! œÜ) ‚Üí motive œÜ h := by
  intro _ hœÜ;
  induction (iff_provable.mp $ hœÜ) with
  | mem‚ÇÅ h => apply mem‚ÇÅ h;
  | mem‚ÇÇ h => apply mem‚ÇÇ h;
  | mdp hœÜœà hœÜ ihœÜœà ihœÜ =>
    apply mdp;
    . apply ihœÜœà;
    . apply ihœÜ;
    . apply iff_provable.mpr; assumption;
    . apply iff_provable.mpr; assumption;
  | nec hœÜ ihœÜ =>
    apply nec;
    . apply ihœÜ;
    . apply iff_provable.mpr; assumption;
  | subst hœÜ ihœÜ =>
    apply subst;
    . apply ihœÜ;
    . apply iff_provable.mpr; assumption;

lemma symm : sumNormal L‚ÇÅ L‚ÇÇ = sumNormal L‚ÇÇ L‚ÇÅ := by
  ext œÜ;
  constructor;
  . intro h;
    induction h with
    | mem‚ÇÅ h => exact sumNormal.mem‚ÇÇ h;
    | mem‚ÇÇ h => exact sumNormal.mem‚ÇÅ h;
    | mdp _ _ ihœÜœà ihœÜ => exact sumNormal.mdp ihœÜœà ihœÜ;
    | subst _ ihœÜ => exact sumNormal.subst ihœÜ;
    | nec _ ihœÜ => exact sumNormal.nec ihœÜ;
  . intro h;
    induction h with
    | mem‚ÇÅ h => exact sumNormal.mem‚ÇÇ h;
    | mem‚ÇÇ h => exact sumNormal.mem‚ÇÅ h;
    | mdp _ _ ihœÜœà ihœÜ => exact sumNormal.mdp ihœÜœà ihœÜ;
    | subst _ ihœÜ => exact sumNormal.subst ihœÜ;
    | nec _ ihœÜ => exact sumNormal.nec ihœÜ;

variable [DecidableEq Œ±]

instance [Entailment.Cl L‚ÇÅ] : Entailment.Lukasiewicz (sumNormal L‚ÇÅ L‚ÇÇ) where
  imply‚ÇÅ _ _ := by constructor; apply sumNormal.mem‚ÇÅ; simp;
  imply‚ÇÇ _ _ _ := by constructor; apply sumNormal.mem‚ÇÅ; simp;
  elimContra _ _ := by constructor; apply sumNormal.mem‚ÇÅ; simp;
  mdp hœÜœà hœÜ := by
    constructor;
    apply sumNormal.mdp;
    . exact PLift.down hœÜœà;
    . exact PLift.down hœÜ;

instance [L‚ÇÅ.IsNormal] : (sumNormal L‚ÇÅ L‚ÇÇ).IsNormal where
  K _ _ := by constructor; apply sumNormal.mem‚ÇÅ; simp;
  subst s hœÜ := by
    constructor;
    apply sumNormal.subst;
    exact PLift.down hœÜ;
  nec hœÜ := by
    constructor;
    apply sumNormal.nec;
    exact PLift.down hœÜ;

instance [L‚ÇÇ.IsNormal] : (sumNormal L‚ÇÅ L‚ÇÇ).IsNormal := by
  rw [sumNormal.symm];
  infer_instance;

instance : L‚ÇÅ ‚™Ø sumNormal L‚ÇÅ L‚ÇÇ := by
  apply weakerThan_iff.mpr;
  intro œÜ hœÜ;
  exact mem‚ÇÅ! hœÜ;

instance : L‚ÇÇ ‚™Ø sumNormal L‚ÇÅ L‚ÇÇ := by
  rw [sumNormal.symm];
  infer_instance;

end sumNormal

end Logic

end LO.Modal
