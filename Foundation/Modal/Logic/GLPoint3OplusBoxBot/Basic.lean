import Foundation.Modal.Logic.SumNormal
import Foundation.Modal.Maximal.Unprovability
import Mathlib.Data.ENat.Basic
import Foundation.Modal.Kripke.Logic.GL.Completeness
import Foundation.Modal.Kripke.Logic.Ver
import Foundation.Modal.Logic.Global


namespace LO.Modal

open Logic

variable {n : ‚Ñï‚àû}

protected def GLPoint3OplusBoxBot (n : ‚Ñï‚àû) :=
  match n with
  | .some n => Modal.GLPoint3.sumNormal {‚ñ°^[n]‚ä•}
  | .none   => Modal.GLPoint3

instance : (Modal.GLPoint3OplusBoxBot n).IsNormal := by
  dsimp [Modal.GLPoint3OplusBoxBot];
  split <;> infer_instance;

instance : Modal.GLPoint3 ‚™Ø Modal.GLPoint3OplusBoxBot n := by
  dsimp [Modal.GLPoint3OplusBoxBot];
  split <;> infer_instance;

@[simp]
lemma GLPoint3OplusBoxBot.boxbot {n : ‚Ñï} : Modal.GLPoint3OplusBoxBot n ‚ä¢! (‚ñ°^[n]‚ä•) := by
  apply Logic.sumNormal.mem‚ÇÇ!;
  tauto;

open LO.Entailment LO.Modal.Entailment in
@[simp]
lemma GLPoint3OplusBoxBot.axiomNVer {n : ‚Ñï} : Modal.GLPoint3OplusBoxBot n ‚ä¢! (‚ñ°^[n]œÜ) :=
  Modal.Entailment.multibox_axiomK'! (multinec! (by cl_prover)) ‚®Ä GLPoint3OplusBoxBot.boxbot

@[simp] lemma eq_GLPoint3OplusBoxBot_omega_GLPoint3 : (Modal.GLPoint3OplusBoxBot ‚ä§) = Modal.GLPoint3 := by simp [Modal.GLPoint3OplusBoxBot];


section

open Kripke
open LO.Entailment LO.Modal.Entailment
open Formula (atom)
open Formula.Kripke

lemma GLPoint3OplusBoxBot.weakerThan_succ {n : ‚Ñï} : (Modal.GLPoint3OplusBoxBot (n + 1)) ‚™Ø (Modal.GLPoint3OplusBoxBot n) := by
  apply weakerThan_iff.mpr;
  intro œÜ h;
  induction h using sumNormal.rec! with
  | mem‚ÇÅ h => apply Entailment.WeakerThan.pbl h;
  | @mem‚ÇÇ œÜ h =>
    suffices Modal.GLPoint3OplusBoxBot n ‚ä¢! (‚ñ°^[n]‚ä•) ‚ûù (‚ñ°^[(n + 1)](‚ä•)) by
      rw [(show œÜ = ‚ñ°^[(n + 1)]‚ä• by replace h := Logic.iff_provable.mp h; simp_all;)];
      exact this ‚®Ä (by simp);
    apply multibox_axiomK'!;
    apply multinec!;
    cl_prover;
  | mdp ihœÜœà ihœÜ => cl_prover [ihœÜœà, ihœÜ];
  | subst ih => apply Logic.subst! _ ih;
  | nec ih => apply nec! ih;

lemma GLPoint3OplusBoxBot.weakerThan_add {n k : ‚Ñï} : (Modal.GLPoint3OplusBoxBot (n + k)) ‚™Ø (Modal.GLPoint3OplusBoxBot n) := by
  induction k with
  | zero => simp [Modal.GLPoint3OplusBoxBot];
  | succ k ih =>
    trans (Modal.GLPoint3OplusBoxBot (n + k));
    . apply Modal.GLPoint3OplusBoxBot.weakerThan_succ;
    . assumption;

lemma GLPoint3OplusBoxBot.weakerThan_lt {n m : ‚Ñï} (hmn : m > n) : (Modal.GLPoint3OplusBoxBot m) ‚™Ø (Modal.GLPoint3OplusBoxBot n) := by
  rw [(show m = n + (m - n) by omega)];
  apply GLPoint3OplusBoxBot.weakerThan_add;

instance : (Modal.GLPoint3OplusBoxBot 1) ‚™Ø (Modal.GLPoint3OplusBoxBot 0) := GLPoint3OplusBoxBot.weakerThan_lt (by simp)
instance : (Modal.GLPoint3OplusBoxBot 2) ‚™Ø (Modal.GLPoint3OplusBoxBot 1) := GLPoint3OplusBoxBot.weakerThan_lt (by simp)

/--
  `<` on `Fin (k + 1)`, `m ‚â• n` can be reached by `n` times `<`-step.
-/
lemma _root_.HRel.Iterate.fin_lt_stepping_stones {k n : ‚Ñï} {m : Fin (k + 1)}
  (_ : n = 0 ‚Üí m = 0)
  (_ : n ‚â§ m)
  : HRel.Iterate (Œ± := Fin (k + 1)) (¬∑ < ¬∑) n 0 m := by
  induction n generalizing m with
  | zero =>
    simp_all;
  | succ n ih =>
    rw [HRel.Iterate.forward];
    use ‚ü®n, by omega‚ü©;
    constructor;
    . apply ih;
      . simp;
      . simp;
    . simpa;

lemma GLPoint3OplusBoxBot.strictlyWeakerThan_GLPoint3 {n : ‚Ñï} : (Modal.GLPoint3) ‚™± (Modal.GLPoint3OplusBoxBot n) := by
  apply strictlyWeakerThan_iff.mpr;
  constructor;
  . intro _ h;
    apply sumNormal.mem‚ÇÅ!;
    assumption;
  . use ‚ñ°^[n]‚ä•;
    constructor;
    . apply Sound.not_provable_of_countermodel (ùìú := Kripke.FrameClass.finite_GLPoint3);
      apply Kripke.not_validOnFrameClass_of_exists_model_world;
      let M : Model := ‚ü®‚ü®Fin (n + 1), Œª x y => (x < y)‚ü©, (Œª _ _ => True)‚ü©;
      use M, 0;
      constructor;
      . apply Set.mem_setOf_eq.mpr;
        exact {}
      . apply Satisfies.multibox_def.not.mpr;
        push_neg;
        use ‚ü®n, by omega‚ü©;
        constructor;
        . apply HRel.Iterate.fin_lt_stepping_stones <;> simp;
        . tauto;
    . simp;

instance : (Modal.GLPoint3) ‚™± (Modal.GLPoint3OplusBoxBot 2) := GLPoint3OplusBoxBot.strictlyWeakerThan_GLPoint3

lemma eq_GLPoint3OplusBoxBot_0_Univ : (Modal.GLPoint3OplusBoxBot 0) = Set.univ := by
  have : Modal.GLPoint3OplusBoxBot 0 ‚ä¢! ‚ä• := GLPoint3OplusBoxBot.boxbot;
  ext œÜ;
  suffices Modal.GLPoint3OplusBoxBot 0 ‚ä¢! ‚ä• by
    simp only [‚Üêiff_provable, Set.mem_univ, iff_true];
    cl_prover [this];
  apply sumNormal.mem‚ÇÇ!;
  apply Logic.iff_provable.mpr;
  simp;


lemma eq_GLPoint3OplusBoxBot_1_Ver : (Modal.GLPoint3OplusBoxBot 1) = Modal.Ver := by
  ext œÜ;
  constructor;
  . simp only [‚Üêiff_provable];
    intro h;
    induction h using sumNormal.rec! with
    | mem‚ÇÅ h => apply Entailment.WeakerThan.pbl h;
    | mem‚ÇÇ h => simp_all [Logic.iff_provable];
    | mdp ihœÜœà ihœÜ => cl_prover [ihœÜœà, ihœÜ];
    | subst ih => apply Logic.subst! _ ih;
    | nec ih => apply nec! ih;
  . suffices Modal.Ver ‚ä¢! œÜ ‚Üí Modal.GLPoint3OplusBoxBot 1 ‚ä¢! œÜ by simpa [Logic.iff_provable];
    intro h;
    induction h using Hilbert.Normal.rec! with
    | axm s h =>
      rcases h with (rfl | rfl);
      . simp;
      . apply axiomK''! (œÜ := ‚ä•);
        . apply nec!; cl_prover;
        . apply sumNormal.mem‚ÇÇ!;
          apply Logic.iff_provable.mpr;
          simp;
    | mdp ihœÜœà ihœÜ => cl_prover [ihœÜœà, ihœÜ]
    | nec ih => apply nec! ih;
    | _ => cl_prover;

instance : (Modal.GLPoint3OplusBoxBot 1) ‚âä Modal.Ver := by rw [eq_GLPoint3OplusBoxBot_1_Ver];

lemma GLPoint3OplusBoxBot.provable_weakPoint2_in_2 : Modal.GLPoint3OplusBoxBot 2 ‚ä¢! Axioms.WeakPoint2 (.atom 0) (.atom 1) := by
  suffices Modal.GLPoint3OplusBoxBot 2 ‚ä¢! Axioms.CD (.atom 0) by
    apply C!_trans (Logic.subst! (Œª _ => (‚ñ°(.atom 0) ‚ãè (.atom 1))) this);
    -- TODO: `K_prover`
    apply normal_provable_of_K_provable;
    apply Complete.complete (ùìú := Kripke.FrameClass.K);
    simp only [Formula.subst.subst_box, Formula.subst.subst_atom];
    intro F _ V x h y Rxy;
    apply Satisfies.or_def.mpr;
    right;
    exact (Satisfies.and_def.mp $ h y Rxy) |>.2;
  haveI : Modal.GLPoint3OplusBoxBot 2 ‚ä¢! ‚óá(.atom 0) ‚ûù ‚óá(.atom 0) ‚ãè (‚ñ°^[2](.atom 0)) := by
    have : Modal.GLPoint3OplusBoxBot 2 ‚ä¢! ‚ñ°^[2](.atom 0) := GLPoint3OplusBoxBot.axiomNVer;
    cl_prover [this];
  haveI : Modal.GLPoint3OplusBoxBot 2 ‚ä¢! ‚óá(.atom 0) ‚ûù ‚àº‚ñ°(‚ä°(.atom 0) ‚ûù ‚àº(.atom 0)) := C!_trans this $ by
    -- TODO: `K_prover`
    apply normal_provable_of_K_provable;
    apply Complete.complete (ùìú := Kripke.FrameClass.K);
    intro F _ V x h;
    replace h := Satisfies.and_def.mp h;
    obtain ‚ü®y, Rxy, h‚ÇÅ‚ü© := Satisfies.dia_def.mp h.1;
    apply Satisfies.not_box_def.mpr;
    use y;
    constructor;
    . assumption;
    . apply Satisfies.not_imp_def.mpr;
      constructor;
      . apply Satisfies.and_def.mpr;
        constructor;
        . assumption;
        . intro z Ryz;
          apply Satisfies.multibox_def.mp h.2;
          use y;
          tauto;
      . apply Satisfies.not_def.mp;
        apply Satisfies.negneg_def.mpr;
        assumption;
  haveI : Modal.GLPoint3OplusBoxBot 2 ‚ä¢! ‚óá(.atom 0) ‚ûù ‚ñ°(‚ä°(‚àº(.atom 0)) ‚ûù (.atom 0)) := C!_trans this $ by
    have : Modal.GLPoint3OplusBoxBot 2 ‚ä¢! ‚ñ°(‚ä°(.atom 0) ‚ûù (‚àº(.atom 0))) ‚ãé ‚ñ°(‚ä°(‚àº(.atom 0)) ‚ûù (.atom 0)) := sumNormal.mem‚ÇÅ! (by simp);
    cl_prover [this];
  haveI : Modal.GLPoint3OplusBoxBot 2 ‚ä¢! ‚óá(.atom 0) ‚ûù ‚ñ°^[2](‚àº.atom 0) ‚ûù ‚ñ°(.atom 0) := C!_trans this $ by
    apply C!_trans ?_ axiomK!;
    apply axiomK'!;
    apply nec!
    cl_prover;
  haveI : Modal.GLPoint3OplusBoxBot 2 ‚ä¢! ‚óá(.atom 0) ‚ûù ‚ñ°(.atom 0) := C!_trans this $ by
    have : Modal.GLPoint3OplusBoxBot 2 ‚ä¢! (‚ñ°^[2](‚àº(.atom 0))) := GLPoint3OplusBoxBot.axiomNVer;
    cl_prover [this];
  exact this;


lemma GLPoint2.provable_boxboxbot : Modal.GLPoint2 ‚ä¢! (‚ñ°^[2]‚ä•) := by
  have h‚ÇÅ : Modal.GLPoint2 ‚ä¢! ‚ñ°(‚àº‚ñ°‚ä•) ‚ûù ‚ñ°^[2]‚ä•  := by
    apply Entailment.WeakerThan.pbl (ùì¢ := Modal.GL);
    haveI : Modal.GL ‚ä¢! ‚ñ°(‚àº‚ñ°‚ä•) ‚ûù ‚ñ°‚ä• := by
      suffices Modal.GL ‚ä¢! ‚ñ°(‚ñ°‚ä• ‚ûù ‚ä•) ‚ûù ‚ñ°‚ä• by exact this;
      simp [axiomL!];
    haveI : Modal.GL ‚ä¢! ‚ñ°(‚àº‚ñ°‚ä•) ‚ûù ‚ñ°‚ñ°‚ä• := C!_trans this (by simp);
    exact this;
  have h‚ÇÇ : Modal.GLPoint2 ‚ä¢! ‚óá‚ñ°‚ä• ‚ûù ‚ñ°^[2]‚ä• := by
    haveI : Modal.GLPoint2 ‚ä¢! ‚óá‚ñ°‚ä• ‚ûù ‚óá(‚ñ°(‚àº‚ñ°‚ä•) ‚ãè ‚ñ°‚ä•) := by
      -- TODO: `K_prover`
      apply normal_provable_of_K_provable;
      apply Complete.complete (ùìú := Kripke.FrameClass.K);
      intro F _ V x h;
      obtain ‚ü®y, Rxy, hy‚ü© := Satisfies.dia_def.mp h;
      apply Satisfies.dia_def.mpr;
      use y;
      constructor;
      . assumption;
      . apply Satisfies.and_def.mpr;
        constructor;
        . intro z Ryz;
          have := hy z Ryz;
          simp [Satisfies] at this;
        . assumption;
    haveI : Modal.GLPoint2 ‚ä¢! ‚óá‚ñ°‚ä• ‚ûù ‚ñ°(‚óá(‚àº‚ñ°‚ä•) ‚ãé ‚ñ°‚ä•) := C!_trans this (by simp [axiomWeakPoint2!]);
    haveI : Modal.GLPoint2 ‚ä¢! ‚óá‚ñ°‚ä• ‚ûù ‚ñ°(‚àº‚ñ°‚ñ°‚ä• ‚ãé ‚ñ°‚ä•) := C!_trans this $ axiomK'! $ nec! $ by
      -- TODO: `K_prover`
      apply normal_provable_of_K_provable;
      apply Complete.complete (ùìú := Kripke.FrameClass.K);
      intro F _ V x h;
      apply Satisfies.or_def.mpr;
      rcases Satisfies.or_def.mp h with (h | h);
      . left;
        apply Satisfies.not_box_def.mpr;
        obtain ‚ü®y, Rxy, hy‚ü© := Satisfies.dia_def.mp h;
        use y;
        constructor;
        . assumption;
        . assumption;
      . tauto;
    haveI : Modal.GLPoint2 ‚ä¢! ‚óá‚ñ°‚ä• ‚ûù ‚ñ°(‚ñ°‚ñ°‚ä• ‚ûù ‚ñ°‚ä•) := C!_trans this $ axiomK'! $ nec! (by cl_prover);
    haveI : Modal.GLPoint2 ‚ä¢! ‚óá‚ñ°‚ä• ‚ûù ‚ñ°‚ñ°‚ä• := C!_trans this (by simp)
    exact this;
  have h‚ÇÉ : Modal.GLPoint2 ‚ä¢! ‚óá‚ñ°‚ä• ‚≠§ ‚àº‚ñ°(‚àº‚ñ°‚ä•) := dia_duality!;
  cl_prover [h‚ÇÅ, h‚ÇÇ, h‚ÇÉ];

lemma GLPoint2.provable_axiomWeakPoint3 : Modal.GLPoint2 ‚ä¢! (Axioms.WeakPoint3 (.atom 0) (.atom 1)) := by
  suffices Modal.GLPoint2 ‚ä¢! ‚óá((.atom 0) ‚ãè ‚ñ°(.atom 0)) ‚ûù ‚ñ°(.atom 0) by
    suffices Modal.GLPoint2 ‚ä¢! ‚àº‚ñ°(‚ä°atom 0 ‚ûù atom 1) ‚ûù ‚ñ°(‚ä°atom 1 ‚ûù atom 0) by cl_prover [this];
    apply C!_trans ?_ (Logic.subst! (Œª _ => ((‚ä°atom 1 ‚ûù atom 0))) this);
      -- TODO: `K_prover`
    apply normal_provable_of_K_provable;
    apply Complete.complete (ùìú := Kripke.FrameClass.K);
    simp only [Formula.subst.subst_dia, Formula.subst.subst_and, Formula.subst.subst_atom, Formula.subst.subst_box];
    intro F _ V x h;
    obtain ‚ü®y, Rxy, hy‚ü© := Satisfies.not_box_def.mp h;
    apply Satisfies.dia_def.mpr;
    use y;
    constructor;
    . assumption;
    . apply Satisfies.and_def.mpr;
      constructor;
      . intro h;
        replace h := Satisfies.and_def.mp h;
        tauto;
      . intro z Ryz hz;
        apply (Satisfies.and_def.mp $ Satisfies.not_imp_def.mp hy |>.1) |>.2;
        assumption;
  haveI : Modal.GLPoint2 ‚ä¢! ‚óá(((.atom 0) ‚ãè ‚ñ°(.atom 0))) ‚ûù ‚óá(((.atom 0) ‚ãè ‚ñ°(.atom 0)) ‚ãè ‚ñ°(‚àº((.atom 0) ‚ãè ‚ñ°(.atom 0)))) := by
    suffices Modal.GLPoint2 ‚ä¢! ‚ñ°((‚ñ°(‚àº(atom 0 ‚ãè ‚ñ°atom 0)) ‚ûù ‚àº(atom 0 ‚ãè ‚ñ°atom 0))) ‚ûù ‚ñ°(‚àº(atom 0 ‚ãè ‚ñ°atom 0)) by
      apply (?_ ‚®Ä this);
      -- TODO: `K_prover`
      suffices Modal.GLPoint2 ‚ä¢! (‚ñ°(‚ñ°(‚àº(atom 0)) ‚ûù ‚àº(atom 0)) ‚ûù ‚ñ°(‚àº(atom 0))) ‚ûù ‚óá(atom 0) ‚ûù ‚óá((atom 0) ‚ãè ‚ñ°(‚àº(atom 0))) by
        exact Logic.subst! (Œª _ => (atom 0 ‚ãè ‚ñ°atom 0)) this;
      apply normal_provable_of_K_provable;
      apply Complete.complete (ùìú := Kripke.FrameClass.K);
      intro F _ V x h‚ÇÅ;
      contrapose!;
      intro h‚ÇÇ;
      apply Satisfies.not_dia_def.mpr;
      intro y Rxy;
      apply (Satisfies.box_def.mp $ h‚ÇÅ ?_) y Rxy;
      intro z Rxz;
      replace h‚ÇÇ := Satisfies.dia_def.not.mp h‚ÇÇ;
      push_neg at h‚ÇÇ;
      have := Satisfies.and_def.not.mp $ h‚ÇÇ z Rxz;
      set_option push_neg.use_distrib true in push_neg at this;
      rcases this
      . tauto;
      . tauto;
    simp;
  haveI : Modal.GLPoint2 ‚ä¢! ‚óá((.atom 0) ‚ãè ‚ñ°(.atom 0)) ‚ûù ‚óá((.atom 0) ‚ãè ‚ñ°(.atom 0) ‚ãè ‚ñ°^[2](.atom 0) ‚ãè ‚ñ°(‚àº((.atom 0) ‚ãè ‚ñ°(.atom 0)))) := C!_trans this $ by
    have : Modal.GLPoint2 ‚ä¢! ‚ñ°(.atom 0) ‚ûù ‚ñ°^[2](.atom 0) := by simp;
    apply diaK'!;
    cl_prover [this];
  haveI : Modal.GLPoint2 ‚ä¢! ‚óá((.atom 0) ‚ãè ‚ñ°(.atom 0)) ‚ûù ‚óá(‚ñ°‚ä• ‚ãè (.atom 0)) := C!_trans this $ by
      -- TODO: `K_prover`
    apply diaK'!;
    apply normal_provable_of_K_provable;
    apply Complete.complete (ùìú := Kripke.FrameClass.K);
    intro F _ V x hx;
    replace ‚ü®hx‚ÇÅ, hx‚ÇÇ‚ü© := Satisfies.and_def.mp hx;
    replace ‚ü®hx‚ÇÇ, hx‚ÇÉ‚ü© := Satisfies.and_def.mp hx‚ÇÇ;
    replace ‚ü®hx‚ÇÉ, hx‚ÇÑ‚ü© := Satisfies.and_def.mp hx‚ÇÉ;
    apply Satisfies.and_def.mpr;
    constructor;
    . intro y Rxy;
      replace hx‚ÇÇ := hx‚ÇÇ _ Rxy;
      replace hx‚ÇÑ := hx‚ÇÑ _ Rxy;
      apply hx‚ÇÑ;
      apply Satisfies.and_def.mpr;
      constructor;
      . assumption;
      . intro z Ryz;
        apply Satisfies.multibox_def.mp hx‚ÇÉ;
        use y;
        tauto;
    . assumption;
  haveI : Modal.GLPoint2 ‚ä¢! ‚óá((.atom 0) ‚ãè ‚ñ°(.atom 0)) ‚ûù ‚ñ°(‚óá‚ä• ‚ãé (.atom 0)) := C!_trans this $ by simp;
  haveI : Modal.GLPoint2 ‚ä¢! ‚óá((.atom 0) ‚ãè ‚ñ°(.atom 0)) ‚ûù ‚ñ°(.atom 0) := C!_trans this $ by
    apply axiomK'!;
    apply nec!;
    haveI : Modal.GLPoint2 ‚ä¢! ‚àº‚óá‚ä• := by
      -- TODO: `K_prover`
      apply normal_provable_of_K_provable;
      apply Complete.complete (ùìú := Kripke.FrameClass.K);
      intro F _ V x;
      apply Satisfies.not_dia_def.mpr;
      tauto;
    cl_prover [this];
  exact this;

instance : Entailment.GLPoint3 Modal.GLPoint2 where
  WeakPoint3 œÜ œà := by
    constructor;
    apply Logic.iff_provable.mp;
    simpa using Logic.subst! (s := Œª a => match a with | 0 => œÜ | 1 => œà | _ => a) GLPoint2.provable_axiomWeakPoint3;

instance : Modal.GLPoint3 ‚™Ø Modal.GLPoint2 := by
  suffices Modal.GLPoint3 ‚™Ø Modal.GLPoint2 by infer_instance;
  apply weakerThan_iff.mpr;
  intro œÜ hœÜ;
  induction hœÜ using Hilbert.Normal.rec! with
  | axm s h => rcases h with (rfl | rfl | rfl) <;> simp;
  | mdp ihœÜœà ihœÜ => cl_prover [ihœÜœà, ihœÜ]
  | nec ih => apply nec! ih;
  | _ => cl_prover;

lemma eq_GLPoint3OplusBoxBot_2_GLPoint2 : (Modal.GLPoint3OplusBoxBot 2) = Modal.GLPoint2 := by
  ext œÜ;
  constructor;
  . simp only [‚Üêiff_provable];
    intro h;
    induction h using sumNormal.rec! with
    | mem‚ÇÅ h => apply Entailment.WeakerThan.pbl h;
    | @mem‚ÇÇ œÜ h =>
      rw [(show œÜ = ‚ñ°^[2]‚ä• by replace h := Logic.iff_provable.mp h; simp_all;)];
      exact GLPoint2.provable_boxboxbot;
    | mdp ihœÜœà ihœÜ => cl_prover [ihœÜœà, ihœÜ];
    | subst ih => apply Logic.subst! _ ih;
    | nec ih => apply nec! ih;
  . suffices Modal.GLPoint2 ‚ä¢! œÜ ‚Üí Modal.GLPoint3OplusBoxBot 2 ‚ä¢! œÜ by simpa [iff_provable];
    intro h;
    induction h using Hilbert.Normal.rec! with
    | axm s h =>
      rcases h with (rfl | rfl | rfl);
      . simp;
      . apply sumNormal.mem‚ÇÅ!; simp;
      . apply subst! s GLPoint3OplusBoxBot.provable_weakPoint2_in_2;
    | mdp ihœÜœà ihœÜ => cl_prover [ihœÜœà, ihœÜ]
    | nec ih => apply nec! ih;
    | _ => cl_prover;

instance : (Modal.GLPoint3OplusBoxBot 2) ‚âä Modal.GLPoint2 := by rw [eq_GLPoint3OplusBoxBot_2_GLPoint2];



end

end LO.Modal
