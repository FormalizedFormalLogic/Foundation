import Foundation.ProvabilityLogic.Basic
import Foundation.Modal.Kripke.Hilbert.GL.Tree
import Foundation.Modal.Kripke.ExtendRoot
import Foundation.Incompleteness.Arith.WitnessComparizon
import Foundation.Incompleteness.Arith.FixedPoint
import Foundation.Incompleteness.Arith.ConsistencyPredicate

open Classical

noncomputable section

namespace LO.FirstOrder.Arith

namespace SolovaySentence

open LO.Arith

section model

variable {V : Type*} [ORingStruc V] [V ‚äß‚Çò* ùêàùö∫‚ÇÅ]

variable (T : Theory ‚Ñí‚Çí·µ£) [T.Delta1Definable]

/-- Provability predicate for arithmetic stronger than $\mathbf{R_0}$. -/
def NegativeSuccessor (œÜ œà : V) : Prop := T.ProvabilityComparison‚Çê (‚åú‚Ñí‚Çí·µ£‚åù.neg œÜ) (‚åú‚Ñí‚Çí·µ£‚åù.neg œà)

lemma NegativeSuccessor.quote_iff_provabilityComparison {œÜ œà : Sentence ‚Ñí‚Çí·µ£} :
    NegativeSuccessor (V := V) T ‚åúœÜ‚åù ‚åúœà‚åù ‚Üî T.ProvabilityComparison‚Çê (V := V) ‚åú‚àºœÜ‚åù ‚åú‚àºœà‚åù := by
  simp [NegativeSuccessor, quote_sentence_eq_quote_emb (‚àºœÜ), quote_sentence_eq_quote_emb (‚àºœà)]

section

def negativeSuccessorDef : ùö∫‚ÇÅ.Semisentence 2 := .mkSigma
  ‚ÄúœÜ œà. ‚àÉ nœÜ, ‚àÉ nœà, !(‚Ñí‚Çí·µ£).lDef.negDef nœÜ œÜ ‚àß !(‚Ñí‚Çí·µ£).lDef.negDef nœà œà ‚àß !T.provabilityComparison‚ÇêDef nœÜ nœà‚Äù (by simp)

lemma negativeSuccessor_defined : ùö∫‚ÇÅ-Relation (NegativeSuccessor T : V ‚Üí V ‚Üí Prop) via (negativeSuccessorDef T) := by
  intro v
  simp [negativeSuccessorDef, NegativeSuccessor, ((‚Ñí‚Çí·µ£).codeIn V).neg_defined.df.iff]

@[simp] lemma eval_negativeSuccessorDef (v) :
    Semiformula.Evalbm V v (negativeSuccessorDef T).val ‚Üî NegativeSuccessor T (v 0) (v 1) := (negativeSuccessor_defined T).df.iff v

instance negativeSuccessor_definable : ùö∫‚ÇÅ-Relation (NegativeSuccessor T : V ‚Üí V ‚Üí Prop) := (negativeSuccessor_defined T).to_definable

/-- instance for definability tactic-/
instance negativeSuccessor_definable' : ùö∫-[0 + 1]-Relation (NegativeSuccessor T : V ‚Üí V ‚Üí Prop) := (negativeSuccessor_defined T).to_definable

end

end model

open Modal ProvabilityLogic Kripke

variable (T : Theory ‚Ñí‚Çí·µ£) [T.Delta1Definable]

variable {M : Kripke.Model} {r : M.World} [M.IsFiniteTree r] [Fintype M.World]

local notation "ùêñ" => M.World

abbrev WChain (i j : ùêñ) := {l : List ùêñ // l.ChainI (¬∑ ‚âª ¬∑) i j}

instance (i j : ùêñ) : Finite (WChain i j) :=
  List.ChainI.finite_of_irreflexive_of_transitive
    (by exact IsIrrefl.irrefl (r := (¬∑ ‚â∫ ¬∑)))
    (by intro x y z hxy hyz
        exact IsTrans.trans (r := (¬∑ ‚â∫ ¬∑)) z y x hyz hxy)
    i j

def twoPointAux (t : ùêñ ‚Üí Semiterm ‚Ñí‚Çí·µ£ Empty N) (i j : ùêñ) : Semisentence ‚Ñí‚Çí·µ£ N :=
  ‚©ï k ‚àà { k : ùêñ | i ‚â∫ k }, (negativeSuccessorDef T)/[t j, t k]

def Œ∏ChainAux (t : ùêñ ‚Üí Semiterm ‚Ñí‚Çí·µ£ Empty N) {i j : ùêñ} : WChain i j ‚Üí Semisentence ‚Ñí‚Çí·µ£ N
  |         ‚ü®[k], h‚ü© => ‚ä§
  | ‚ü®k :: l :: Œµ, h‚ü© =>
    have e : i = k := by rcases h; rfl
    have : (l :: Œµ).ChainI (¬∑ ‚âª ¬∑) l j := by
      rcases h
      case cons m lt h =>
        rcases h
        case singleton => simp
        case cons n ln h =>
          exact h.cons ln
    Œ∏ChainAux t ‚ü®l :: Œµ, this‚ü© ‚ãè twoPointAux T t l k

def Œ∏Aux (t : ùêñ ‚Üí Semiterm ‚Ñí‚Çí·µ£ Empty N) (i : ùêñ) : Semisentence ‚Ñí‚Çí·µ£ N :=
  haveI := Fintype.ofFinite (WChain r i)
  ‚©ñ Œµ : WChain r i, Œ∏ChainAux T t Œµ

lemma rew_twoPointAux (w : Fin N ‚Üí Semiterm ‚Ñí‚Çí·µ£ Empty N') (t : ùêñ ‚Üí Semiterm ‚Ñí‚Çí·µ£ Empty N) :
    Rew.substs w ‚ñπ twoPointAux T t i j = twoPointAux T (fun i ‚Ü¶ Rew.substs w (t i)) i j := by
  simp [twoPointAux, Finset.map_conj', Function.comp_def,
    ‚ÜêTransitiveRewriting.comp_app, Rew.substs_comp_substs]

lemma rew_Œ∏ChainAux (w : Fin N ‚Üí Semiterm ‚Ñí‚Çí·µ£ Empty N') (t : ùêñ ‚Üí Semiterm ‚Ñí‚Çí·µ£ Empty N) (Œµ : WChain i j) :
    Rew.substs w ‚ñπ Œ∏ChainAux T t Œµ = Œ∏ChainAux T (fun i ‚Ü¶ Rew.substs w (t i)) Œµ := by
  match Œµ with
  |         ‚ü®[k], h‚ü© => simp [Œ∏ChainAux]
  | ‚ü®k :: l :: Œµ, h‚ü© =>
    have : (l :: Œµ).ChainI (¬∑ ‚âª ¬∑) l j := by
      rcases h
      case cons m lt h =>
        rcases h
        case singleton => simp
        case cons n ln h =>
          exact h.cons ln
    simp [Œ∏ChainAux, rew_Œ∏ChainAux w _ ‚ü®l :: Œµ, this‚ü©, rew_twoPointAux]

lemma rew_Œ∏Aux (w : Fin N ‚Üí Semiterm ‚Ñí‚Çí·µ£ Empty N') (t : ùêñ ‚Üí Semiterm ‚Ñí‚Çí·µ£ Empty N) (i : ùêñ) :
    Rew.substs w ‚ñπ Œ∏Aux T t i = Œ∏Aux T (fun i ‚Ü¶ Rew.substs w (t i)) i := by
  simp [Finset.map_disj', Œ∏Aux]
  sorry

def solovay (i : ùêñ) : Sentence ‚Ñí‚Çí·µ£ := multifixpoint
  (fun j ‚Ü¶
    let jj := (Fintype.equivFin ùêñ).symm j
    Œ∏Aux T (fun i ‚Ü¶ #(Fintype.equivFin ùêñ i)) jj ‚ãè ‚©ï k ‚àà { k : ùêñ | jj ‚â∫ k }, T.consistency‚Çê/[#(Fintype.equivFin ùêñ k)])
  (Fintype.equivFin ùêñ i)

def Œ∏Chain {i j : ùêñ} (Œµ : WChain i j) : Sentence ‚Ñí‚Çí·µ£ := Œ∏ChainAux T (fun i ‚Ü¶ ‚åúsolovay T i‚åù) Œµ

def Œ∏ (i : ùêñ) : Sentence ‚Ñí‚Çí·µ£ := Œ∏Aux T (fun i ‚Ü¶ ‚åúsolovay T i‚åù) i

lemma solovay_diag (i : ùêñ) :
    ùêàùö∫‚ÇÅ ‚ä¢!. solovay T i ‚≠§ Œ∏ T i ‚ãè ‚©ï k ‚àà { k : ùêñ | i ‚â∫ k }, T.consistency‚Çê/[‚åúsolovay T k‚åù] := by
  have : ùêàùö∫‚ÇÅ ‚ä¢!. solovay T i ‚≠§
      (Rew.substs fun j ‚Ü¶ ‚åúsolovay T ((Fintype.equivFin ùêñ).symm j)‚åù) ‚ñπ
        (Œ∏Aux T (fun i ‚Ü¶ #(Fintype.equivFin ùêñ i)) i ‚ãè ‚©ï k ‚àà { k : ùêñ | i ‚â∫ k }, T.consistency‚Çê/[#(Fintype.equivFin ùêñ k)]) := by
    simpa [solovay] using multidiagonal (T := ùêàùö∫‚ÇÅ) (i := Fintype.equivFin ùêñ i)
      (fun j ‚Ü¶
        let jj := (Fintype.equivFin ùêñ).symm j
        Œ∏Aux T (fun i ‚Ü¶ #(Fintype.equivFin ùêñ i)) jj ‚ãè ‚©ï k ‚àà { k : ùêñ | jj ‚â∫ k }, T.consistency‚Çê/[#(Fintype.equivFin ùêñ k)])
  simpa [Œ∏, Finset.hom_conj', Function.comp_def, rew_Œ∏Aux, ‚ÜêTransitiveRewriting.comp_app, Rew.substs_comp_substs] using this

end SolovaySentence

end LO.FirstOrder.Arith

namespace LO

namespace Entailment

open Entailment
open FiniteContext

variable {F : Type*} [LogicalConnective F] [DecidableEq F]
         {S : Type*} [Entailment F S]
         {ùì¢ : S} [Entailment.Classical ùì¢]
         {œÜ œà Œæ : F}
         {Œì Œî : List F}
         {Œπ} [Fintype Œπ] {Œ¶ : Œπ ‚Üí F}

lemma not_imply_prem''! (hpq : ùì¢ ‚ä¢! œÜ ‚ûù œà) (hpnr : ùì¢ ‚ä¢! œÜ ‚ûù ‚àºŒæ) : ùì¢ ‚ä¢! œÜ ‚ûù ‚àº(œà ‚ûù Œæ) :=
  deduct'! $ (contra‚ÇÄ'! $ not_or_of_imply!) ‚®Ä (demorgan‚ÇÇ'! $ and‚ÇÉ'! (dni'! $ of'! hpq ‚®Ä (by_axm!)) (of'! hpnr ‚®Ä (by_axm!)))

end Entailment


namespace Modal.Kripke

def ImmediateSuccessors {F : Kripke.Frame} (x : F.World) := { y // x ‚â∫ y }
postfix:100 "‚Üë·µ¢" => ImmediateSuccessors

end Modal.Kripke



namespace ProvabilityLogic

open Classical
open Entailment Entailment.FiniteContext
open FirstOrder FirstOrder.DerivabilityCondition
open Modal
open Modal.Kripke
open Modal.Formula.Kripke

variable {L} [DecidableEq (Sentence L)] [Semiterm.Operator.GoedelNumber L (Sentence L)]
         {T‚ÇÄ T : Theory L} [T‚ÇÄ ‚™Ø T] (ùîÖ : ProvabilityPredicate T‚ÇÄ T) [ùîÖ.HBL]
         {A B : Modal.Formula _}

-- TODO: cleanup
noncomputable instance {F‚ÇÅ : Kripke.Frame} {r‚ÇÅ : F‚ÇÅ.World} [F‚ÇÅ.IsFiniteTree r‚ÇÅ] : Fintype (F‚ÇÅ.extendRoot r‚ÇÅ).World := @Fintype.ofFinite _ $ Frame.extendRoot.instIsFiniteTree |>.toIsFinite.world_finite
noncomputable instance {M‚ÇÅ : Kripke.Model} {r‚ÇÅ : M‚ÇÅ.World} [M‚ÇÅ.IsFiniteTree r‚ÇÅ] : Fintype (M‚ÇÅ.extendRoot r‚ÇÅ).World := @Fintype.ofFinite _ $ Frame.extendRoot.instIsFiniteTree |>.toIsFinite.world_finite

structure SolovaySentences
  (F‚ÇÅ : Kripke.Frame) (r‚ÇÅ : F‚ÇÅ.World) [F‚ÇÅ.IsFiniteTree r‚ÇÅ]
  where
  œÉ : (F‚ÇÅ.extendRoot r‚ÇÅ).World ‚Üí Sentence L
  protected SC1 : ‚àÄ i j, i ‚â† j ‚Üí T‚ÇÄ ‚ä¢!. œÉ i ‚ûù ‚àºœÉ j
  protected SC2 : ‚àÄ i j, i ‚â∫ j ‚Üí T‚ÇÄ ‚ä¢!. œÉ i ‚ûù ‚àºùîÖ (‚àº(œÉ j))
  protected SC3 : ‚àÄ i, Frame.extendRoot.root ‚â∫ i ‚Üí T‚ÇÄ ‚ä¢!. œÉ i ‚ûù ùîÖ (‚©ñ j ‚àà { j : (F‚ÇÅ.extendRoot r‚ÇÅ).World | i ‚â∫ j }, œÉ j)
  protected SC4 : T ‚ä¨. ‚àº(œÉ r‚ÇÅ)

variable {ùîÖ}

namespace SolovaySentences

instance {F‚ÇÅ : Kripke.Frame} {r‚ÇÅ : F‚ÇÅ.World} [F‚ÇÅ.IsFiniteTree r‚ÇÅ] : CoeFun (SolovaySentences ùîÖ F‚ÇÅ r‚ÇÅ) (Œª _ => (F‚ÇÅ.extendRoot r‚ÇÅ) ‚Üí Sentence L) := ‚ü®Œª œÉ => œÉ.œÉ‚ü©

variable {M‚ÇÅ : Model} {r‚ÇÅ : M‚ÇÅ.World} [M‚ÇÅ.IsFiniteTree r‚ÇÅ] {œÉ : SolovaySentences ùîÖ M‚ÇÅ.toFrame r‚ÇÅ}

noncomputable def realization (œÉ : SolovaySentences ùîÖ M‚ÇÅ.toFrame r‚ÇÅ) : Realization L := Œª a => ‚©ñ i ‚àà { i : (M‚ÇÅ.extendRoot r‚ÇÅ).World | i ‚äß (.atom a) }, œÉ i

theorem mainlemma {i : M‚ÇÅ.World} :
  (i ‚äß A ‚Üí T‚ÇÄ ‚ä¢!. (œÉ i) ‚ûù (œÉ.realization.interpret ùîÖ A)) ‚àß
  (¬¨i ‚äß A ‚Üí T‚ÇÄ ‚ä¢!. (œÉ i) ‚ûù ‚àº(œÉ.realization.interpret ùîÖ A))
  := by
  induction A using Formula.rec' generalizing i with
  | hfalsum => simp [Realization.interpret, Semantics.Realize, Satisfies];
  | hatom a =>
    constructor;
    . intro h;
      apply imply_fdisj;
      simpa using h;
    . intro h;
      apply contra‚ÇÅ'!;
      apply fdisj_imply!;
      intro i hi;
      apply œÉ.SC1;
      by_contra hC; subst hC;
      apply h;
      simpa using hi;
  | himp A B ihA ihB =>
    simp only [Realization.interpret, Semantics.Imp.realize_imp, Classical.not_imp, and_imp];
    constructor;
    . intro h;
      rcases Satisfies.imp_def‚ÇÇ.mp h with (hA | hB);
      . exact imp_trans''! (ihA.2 hA) efq_imply_not‚ÇÅ!;
      . exact imp_trans''! (ihB.1 hB) imply‚ÇÅ!;
    . intro hA hB;
      exact not_imply_prem''! (ihA.1 hA) (ihB.2 hB);
  | hbox A ihA =>
    simp only [Realization.interpret];
    constructor;
    . intro h;
      apply imp_trans''! $ œÉ.SC3 i $ Model.extendRoot.rooted_original;
      apply ùîÖ.prov_distribute_imply';
      apply fdisj_imply!;
      rintro j Rij;
      match j with
      | Sum.inl j => simp [Frame.Rel', Frame.extendRoot] at Rij
      | Sum.inr j => exact ihA.1 $ h j $ by simpa using Rij;
    . intro h;
      have := Satisfies.box_def.not.mp h;
      push_neg at this;
      obtain ‚ü®j, Rij, hA‚ü© := this;
      have := contra‚ÇÅ'! $ ihA.2 hA;
      have : T‚ÇÄ ‚ä¢!. ‚àºùîÖ (‚àºœÉ.œÉ j) ‚ûù ‚àºùîÖ (œÉ.realization.interpret ùîÖ A) := contra‚ÇÄ'! $ ùîÖ.prov_distribute_imply' $ contra‚ÇÅ'! $ ihA.2 hA;
      exact imp_trans''! (œÉ.SC2 i j Rij) this;

end SolovaySentences

theorem arithmetical_completeness_GL : (‚àÄ {f : Realization L}, T ‚ä¢!. (f.interpret ùîÖ A)) ‚Üí A ‚àà Logic.GL := by
  contrapose;
  intro hA;
  push_neg;
  obtain ‚ü®M‚ÇÅ, r‚ÇÅ, _, hA‚ÇÅ‚ü© := Hilbert.GL.Kripke.iff_unprovable_exists_unsatisfies_FiniteTransitiveTree.mp hA;
  let œÉ : SolovaySentences ùîÖ M‚ÇÅ.toFrame r‚ÇÅ := by sorry; -- TODO: Sect 2.1
  use œÉ.realization;

  have : T‚ÇÄ ‚ä¢!. œÉ r‚ÇÅ ‚ûù œÉ.realization.interpret ùîÖ (‚àºA) := œÉ.mainlemma (A := ‚àºA) (i := r‚ÇÅ) |>.1 $ hA‚ÇÅ
  replace : T‚ÇÄ ‚ä¢!. œÉ.realization.interpret ùîÖ A ‚ûù ‚àº(œÉ r‚ÇÅ) := by
    apply contra‚ÇÅ'!;
    apply imp_trans''! this;
    apply and‚ÇÇ'! neg_equiv!;
  replace : T ‚ä¢!. œÉ.realization.interpret ùîÖ A ‚ûù ‚àº(œÉ r‚ÇÅ) := WeakerThan.pbl this;

  by_contra hC;
  have : T ‚ä¢!. ‚àº(œÉ r‚ÇÅ) := this ‚®Ä hC;
  exact œÉ.SC4 this;

end ProvabilityLogic

end LO
