import Foundation.FirstOrder.ISigma1.HFS

namespace LO.ISigma1.Metamath

open FirstOrder Arithmetic PeanoMinus IOpen ISigma0

variable {L : Language} [L.Encodable]

instance (k) : Semiterm.Operator.GoedelNumber ‚Ñí‚Çí·µ£ (L.Func k) := ‚ü®fun f ‚Ü¶ Semiterm.Operator.numeral ‚Ñí‚Çí·µ£ (Encodable.encode f)‚ü©

instance (k) : Semiterm.Operator.GoedelNumber ‚Ñí‚Çí·µ£ (L.Rel k) := ‚ü®fun r ‚Ü¶ Semiterm.Operator.numeral ‚Ñí‚Çí·µ£ (Encodable.encode r)‚ü©

variable (L)

protected class _root_.LO.FirstOrder.Language.LORDefinable where
  func : ùö∫‚ÇÄ.Semisentence 2
  rel : ùö∫‚ÇÄ.Semisentence 2
  func_iff {k c : ‚Ñï} :
    c ‚àà Set.range (Encodable.encode : L.Func k ‚Üí ‚Ñï) ‚Üî ‚Ñï ‚äß/![k, c] func.val
  rel_iff {k c : ‚Ñï} :
    c ‚àà Set.range (Encodable.encode : L.Rel k ‚Üí ‚Ñï) ‚Üî ‚Ñï ‚äß/![k, c] rel.val

alias _root_.LO.FirstOrder.Language.funcDef := Language.LORDefinable.func
alias _root_.LO.FirstOrder.Language.relDef := Language.LORDefinable.rel
alias _root_.LO.FirstOrder.Language.iff_funcDef := Language.LORDefinable.func_iff
alias _root_.LO.FirstOrder.Language.iff_relDef := Language.LORDefinable.rel_iff

variable {V : Type*} [ORingStruc V] [L.LORDefinable]

def _root_.LO.FirstOrder.Language.IsFunc (arity f : V) : Prop := V ‚äß/![arity, f] L.funcDef.val

def _root_.LO.FirstOrder.Language.IsRel (arity f : V) : Prop := V ‚äß/![arity, f] L.relDef.val

variable {L}

@[simp] lemma eval_func (v) :
    Semiformula.Evalbm V v L.funcDef.val ‚Üî L.IsFunc (v 0) (v 1) := by simp [Language.IsFunc, ‚Üê Matrix.fun_eq_vec_two]

@[simp] lemma eval_rel_iff (v) :
    Semiformula.Evalbm V v L.relDef.val ‚Üî L.IsRel (v 0) (v 1) := by simp [Language.IsRel, ‚Üê Matrix.fun_eq_vec_two]

lemma _root_.LO.FirstOrder.Language.IsFunc.defined : ùö∫‚ÇÄ-Relation (L.IsFunc (V := V)) via L.funcDef := fun v ‚Ü¶ by simp

lemma _root_.LO.FirstOrder.Language.IsRel.defined : ùö∫‚ÇÄ-Relation (L.IsRel (V := V)) via L.relDef := fun v ‚Ü¶ by simp

instance _root_.LO.FirstOrder.Language.IsFunc.definable : ùö∫‚ÇÄ-Relation (L.IsFunc (V := V)) := Language.IsFunc.defined.to_definable

instance _root_.LO.FirstOrder.Language.IsRel.definable : ùö∫‚ÇÄ-Relation (L.IsRel (V := V)) := Language.IsRel.defined.to_definable

@[simp, definability] instance _root_.LO.FirstOrder.Language.IsFunc.definable' (‚Ñå) : ‚Ñå-Relation (L.IsFunc (V := V)) :=
  HierarchySymbol.Boldface.of_zero Language.IsFunc.definable

@[simp, definability] instance _root_.LO.FirstOrder.Language.IsRel.definable' (‚Ñå) : ‚Ñå-Relation (L.IsRel (V := V)) :=
  HierarchySymbol.Boldface.of_zero Language.IsRel.definable

section

variable [V ‚äß‚Çò* ùêèùêÄ‚Åª]

instance : GoedelQuote (L.Func k) V := ‚ü®fun f ‚Ü¶ ‚Üë(Encodable.encode f)‚ü©

instance : GoedelQuote (L.Rel k) V := ‚ü®fun R ‚Ü¶ ‚Üë(Encodable.encode R)‚ü©

omit [L.LORDefinable] in
lemma quote_func_def (f : L.Func k) : (‚åúf‚åù : V) = ‚Üë(Encodable.encode f) := rfl

omit [L.LORDefinable] in
lemma quote_rel_def (R : L.Rel k) : (‚åúR‚åù : V) = ‚Üë(Encodable.encode R) := rfl

lemma isFunc_quote_quote {k x : ‚Ñï} : L.IsFunc (V := V) k x ‚Üî ‚àÉ f : L.Func k, Encodable.encode f = x :=
  have : V ‚äß/![k, x] L.funcDef.val ‚Üî ‚Ñï ‚äß/![k, x] L.funcDef.val := by
    simpa [Matrix.comp_vecCons', Matrix.constant_eq_singleton]
      using models_iff_of_Sigma0 (V := V) (œÉ := L.funcDef.val) (by simp) (e := ![k, x])
  Iff.trans this <| Iff.trans L.iff_funcDef.symm <| by simp

lemma isRel_quote_quote {k x : ‚Ñï} : L.IsRel (V := V) k x ‚Üî ‚àÉ R : L.Rel k, Encodable.encode R = x :=
  have : V ‚äß/![k, x] L.relDef.val ‚Üî ‚Ñï ‚äß/![k, x] L.relDef.val := by
    simpa [Matrix.comp_vecCons', Matrix.constant_eq_singleton]
      using models_iff_of_Sigma0 (V := V) (œÉ := L.relDef.val) (by simp) (e := ![k, x])
  Iff.trans this <| Iff.trans L.iff_relDef.symm <| by simp

@[simp] lemma codeIn_func_quote {k : ‚Ñï} (f : L.Func k) : L.IsFunc (V := V) k ‚åúf‚åù :=
  (isFunc_quote_quote (V := V)).mpr ‚ü®f, rfl‚ü©

@[simp] lemma codeIn_rel_quote {k : ‚Ñï} (r : L.Rel k) : L.IsRel (V := V) k ‚åúr‚åù :=
  (isRel_quote_quote (V := V)).mpr ‚ü®r, rfl‚ü©

omit [L.LORDefinable]

@[simp] lemma quote_func_inj (f‚ÇÅ f‚ÇÇ : L.Func k) : (‚åúf‚ÇÅ‚åù : V) = (‚åúf‚ÇÇ‚åù : V) ‚Üî f‚ÇÅ = f‚ÇÇ := by
  simp [quote_func_def]

@[simp] lemma quote_rel_inj (R‚ÇÅ R‚ÇÇ : L.Rel k) : (‚åúR‚ÇÅ‚åù : V) = (‚åúR‚ÇÇ‚åù : V) ‚Üî R‚ÇÅ = R‚ÇÇ := by
  simp [quote_rel_def]

@[simp] lemma coe_quote_func_nat (f : L.Func k) : ((‚åúf‚åù : ‚Ñï) : V) = (‚åúf‚åù : V) := by
  simp [quote_func_def]

@[simp] lemma coe_quote_rel_nat (R : L.Rel k) : ((‚åúR‚åù : ‚Ñï) : V) = (‚åúR‚åù : V) := by
  simp [quote_rel_def]

end

lemma _root_.LO.FirstOrder.Language.ORing.of_mem_range_encode_func {k f : ‚Ñï} :
    f ‚àà Set.range (Encodable.encode : FirstOrder.Language.Func ‚Ñí‚Çí·µ£ k ‚Üí ‚Ñï) ‚Üî
    (k = 0 ‚àß f = 0) ‚à® (k = 0 ‚àß f = 1) ‚à® (k = 2 ‚àß f = 0) ‚à® (k = 2 ‚àß f = 1) := by
  constructor
  ¬∑ rintro ‚ü®f, rfl‚ü©
    match k, f with
    | 0, Language.ORing.Func.zero => simp; rfl
    | 0, Language.ORing.Func.one => simp; rfl
    | 2, Language.ORing.Func.add => simp; rfl
    | 2, Language.ORing.Func.mul => simp; rfl
  ¬∑ rintro (‚ü®rfl, rfl‚ü© | ‚ü®rfl, rfl‚ü© | ‚ü®rfl, rfl‚ü© | ‚ü®rfl, rfl‚ü©)
    ¬∑ exact ‚ü®Language.ORing.Func.zero, rfl‚ü©
    ¬∑ exact ‚ü®Language.ORing.Func.one, rfl‚ü©
    ¬∑ exact ‚ü®Language.ORing.Func.add, rfl‚ü©
    ¬∑ exact ‚ü®Language.ORing.Func.mul, rfl‚ü©

/-- TODO: move to Basic/Syntax/Metamath.Language.lean-/
lemma _root_.LO.FirstOrder.Language.ORing.of_mem_range_encode_rel {k r : ‚Ñï} :
    r ‚àà Set.range (Encodable.encode : FirstOrder.Language.Rel ‚Ñí‚Çí·µ£ k ‚Üí ‚Ñï) ‚Üî
    (k = 2 ‚àß r = 0) ‚à® (k = 2 ‚àß r = 1) := by
  constructor
  ¬∑ rintro ‚ü®r, rfl‚ü©
    match k, r with
    | 2, Language.ORing.Rel.eq => simp; rfl
    | 2, Language.ORing.Rel.lt => simp; rfl
  ¬∑ rintro (‚ü®rfl, rfl‚ü© | ‚ü®rfl, rfl‚ü©)
    ¬∑ exact ‚ü®Language.ORing.Rel.eq, rfl‚ü©
    ¬∑ exact ‚ü®Language.ORing.Rel.lt, rfl‚ü©

instance : (‚Ñí‚Çí·µ£).LORDefinable where
  func := .mkSigma ‚Äúk f. (k = 0 ‚àß f = 0) ‚à® (k = 0 ‚àß f = 1) ‚à® (k = 2 ‚àß f = 0) ‚à® (k = 2 ‚àß f = 1)‚Äù (by simp)
  rel  := .mkSigma ‚Äúk r. (k = 2 ‚àß r = 0) ‚à® (k = 2 ‚àß r = 1)‚Äù (by simp)
  func_iff {k c} := by
    simpa [models_iff] using Language.ORing.of_mem_range_encode_func
  rel_iff {k c} := by
    simpa [models_iff] using Language.ORing.of_mem_range_encode_rel

namespace InternalArithmetic

variable {V : Type*} [ORingStruc V] [V ‚äß‚Çò* ùêàùö∫‚ÇÅ]

def zeroIndex : ‚Ñï := Encodable.encode (Language.Zero.zero : (‚Ñí‚Çí·µ£ : FirstOrder.Language).Func 0)

def oneIndex : ‚Ñï := Encodable.encode (Language.One.one : (‚Ñí‚Çí·µ£ : FirstOrder.Language).Func 0)

def addIndex : ‚Ñï := Encodable.encode (Language.Add.add : (‚Ñí‚Çí·µ£ : FirstOrder.Language).Func 2)

def mulIndex : ‚Ñï := Encodable.encode (Language.Mul.mul : (‚Ñí‚Çí·µ£ : FirstOrder.Language).Func 2)

def eqIndex : ‚Ñï := Encodable.encode (Language.Eq.eq : (‚Ñí‚Çí·µ£ : FirstOrder.Language).Rel 2)

def ltIndex : ‚Ñï := Encodable.encode (Language.LT.lt : (‚Ñí‚Çí·µ£ : FirstOrder.Language).Rel 2)

@[simp] lemma LOR_func_zeroIndex : (‚Ñí‚Çí·µ£).IsFunc 0 (zeroIndex : V) := by
  simpa using codeIn_func_quote (V := V) (L := ‚Ñí‚Çí·µ£) Language.Zero.zero

@[simp] lemma LOR_func_oneIndex : (‚Ñí‚Çí·µ£).IsFunc 0 (oneIndex : V) := by
  simpa using codeIn_func_quote (V := V) (L := ‚Ñí‚Çí·µ£) Language.One.one

@[simp] lemma LOR_func_addIndex : (‚Ñí‚Çí·µ£).IsFunc 2 (addIndex : V) := by
  simpa using codeIn_func_quote (V := V) (L := ‚Ñí‚Çí·µ£) Language.Add.add

@[simp] lemma LOR_func_mulIndex : (‚Ñí‚Çí·µ£).IsFunc 2 (mulIndex : V) := by
  simpa using codeIn_func_quote (V := V) (L := ‚Ñí‚Çí·µ£) Language.Mul.mul

@[simp] lemma LOR_rel_eqIndex : (‚Ñí‚Çí·µ£).IsRel 2 (eqIndex : V) := by
  simpa using codeIn_rel_quote (V := V) (L := ‚Ñí‚Çí·µ£) Language.Eq.eq

@[simp] lemma LOR_rel_ltIndex : (‚Ñí‚Çí·µ£).IsRel 2 (ltIndex : V) := by
  simpa using codeIn_rel_quote (V := V) (L := ‚Ñí‚Çí·µ£) Language.LT.lt

lemma lDef.func_def : (‚Ñí‚Çí·µ£).funcDef = .mkSigma ‚Äúk f. (k = 0 ‚àß f = 0) ‚à® (k = 0 ‚àß f = 1) ‚à® (k = 2 ‚àß f = 0) ‚à® (k = 2 ‚àß f = 1)‚Äù (by simp) := rfl

lemma coe_zeroIndex_eq : (zeroIndex : V) = 0 := rfl

lemma coe_oneIndex_eq : (oneIndex : V) = 1 := by simp [oneIndex]; rfl

lemma coe_addIndex_eq : (addIndex : V) = 0 := rfl

lemma coe_mulIndex_eq : (mulIndex : V) = 1 := by simp [mulIndex]; rfl

end InternalArithmetic

end LO.ISigma1.Metamath
