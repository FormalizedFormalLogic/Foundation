import Foundation.FirstOrder.Arithmetic.HFS.Fixpoint

/-!

# Vec

-/

namespace LO.ISigma1

open FirstOrder Arithmetic PeanoMinus IOpen ISigma0

variable {V : Type*} [ORingStructure V] [V ‚äß‚Çò* ùóúùö∫‚ÇÅ]

section adjoin

noncomputable instance : Adjoin V V := ‚ü®(‚ü™¬∑, ¬∑‚ü´ + 1)‚ü©

scoped infixr:67 " ‚à∑ " => adjoin

syntax "?[" term,* "]" : term

macro_rules
  | `(?[$term:term, $terms:term,*]) => `(adjoin $term ?[$terms,*])
  | `(?[$term:term]) => `(adjoin $term 0)
  | `(?[]) => `(0)

@[app_unexpander Adjoin.adjoin]
def adjoinUnexpander : Lean.PrettyPrinter.Unexpander
  | `($_ $term ?[$terms,*]) => `(?[$term, $terms,*])
  | `($_ $term 0) => `(?[$term])
  | _ => throw ()

lemma adjoin_def (x v : V) : x ‚à∑ v = ‚ü™x, v‚ü´ + 1 := rfl

@[simp] lemma fstIdx_adjoin (x v : V) : fstIdx (x ‚à∑ v) = x := by simp [adjoin_def, fstIdx]

@[simp] lemma sndIdx_adjoin (x v : V) : sndIdx (x ‚à∑ v) = v := by simp [adjoin_def, sndIdx]

lemma succ_eq_adjoin (x : V) : x + 1 = œÄ‚ÇÅ x ‚à∑ œÄ‚ÇÇ x := by simp [adjoin_def]

@[simp] lemma lt_adjoin (x v : V) : x < x ‚à∑ v := by simp [adjoin_def, lt_succ_iff_le]

@[simp] lemma lt_adjoin' (x v : V) : v < x ‚à∑ v := by simp [adjoin_def, lt_succ_iff_le]

@[simp] lemma zero_lt_adjoin (x v : V) : 0 < x ‚à∑ v := by simp [adjoin_def]

@[simp] lemma adjoin_ne_zero (x v : V) : x ‚à∑ v ‚â† 0 := by simp [adjoin_def]

@[simp] lemma zero_ne_adjoin (x v : V) : 0 ‚â† x ‚à∑ v := by symm; simp [adjoin_def]

lemma nil_or_adjoin (z : V) : z = 0 ‚à® ‚àÉ x v, z = x ‚à∑ v := by
  rcases zero_or_succ z with (rfl | ‚ü®z, rfl‚ü©)
  ¬∑ left; rfl
  ¬∑ right; exact ‚ü®œÄ‚ÇÅ z, œÄ‚ÇÇ z, by simp [succ_eq_adjoin]‚ü©

@[simp] lemma adjoin_inj (x‚ÇÅ x‚ÇÇ v‚ÇÅ v‚ÇÇ : V) :
    x‚ÇÅ ‚à∑ v‚ÇÅ = x‚ÇÇ ‚à∑ v‚ÇÇ ‚Üî x‚ÇÅ = x‚ÇÇ ‚àß v‚ÇÅ = v‚ÇÇ := by simp [adjoin_def]

lemma adjoin_le_adjoin {x‚ÇÅ x‚ÇÇ v‚ÇÅ v‚ÇÇ : V} (hx : x‚ÇÅ ‚â§ x‚ÇÇ) (hv : v‚ÇÅ ‚â§ v‚ÇÇ) :
    x‚ÇÅ ‚à∑ v‚ÇÅ ‚â§ x‚ÇÇ ‚à∑ v‚ÇÇ := by simpa [adjoin_def] using pair_le_pair hx hv

section

def _root_.LO.FirstOrder.Arithmetic.adjoinDef : ùö∫‚ÇÄ.Semisentence 3 :=
  .mkSigma ‚Äúw x v. ‚àÉ xv < w, !pairDef xv x v ‚àß w = xv + 1‚Äù

instance adjoin_defined : ùö∫‚ÇÄ-Function‚ÇÇ (adjoin : V ‚Üí V ‚Üí V) via adjoinDef := .mk fun v ‚Ü¶ by simp_all [adjoinDef, adjoin_def]

instance adjoin_definable : ùö∫‚ÇÄ-Function‚ÇÇ (adjoin : V ‚Üí V ‚Üí V) := adjoin_defined.to_definable

instance adjoin_definable' (‚Ñå) : ‚Ñå-Function‚ÇÇ (adjoin : V ‚Üí V ‚Üí V) := adjoin_definable.of_zero

def _root_.LO.FirstOrder.Arithmetic.mkVec‚ÇÅDef : ùö∫‚ÇÄ.Semisentence 2 := .mkSigma
  ‚Äús x. !adjoinDef s x 0‚Äù

instance mkVec‚ÇÅ_defined : ùö∫‚ÇÄ-Function‚ÇÅ (fun x : V ‚Ü¶ ?[x]) via mkVec‚ÇÅDef := .mk fun v ‚Ü¶ by simp [mkVec‚ÇÅDef]

instance mkVec‚ÇÅ_definable : ùö∫‚ÇÄ-Function‚ÇÅ (fun x : V ‚Ü¶ ?[x]) := mkVec‚ÇÅ_defined.to_definable

instance mkVec‚ÇÅ_definable' (‚Ñå) : ‚Ñå-Function‚ÇÅ (fun x : V ‚Ü¶ ?[x]) := mkVec‚ÇÅ_definable.of_zero

def _root_.LO.FirstOrder.Arithmetic.mkVec‚ÇÇDef : ùö∫‚ÇÅ.Semisentence 3 := .mkSigma
  ‚Äús x y. ‚àÉ sy, !mkVec‚ÇÅDef sy y ‚àß !adjoinDef s x sy‚Äù

instance mkVec‚ÇÇ_defined : ùö∫‚ÇÅ-Function‚ÇÇ (fun x y : V ‚Ü¶ ?[x, y]) via mkVec‚ÇÇDef := .mk fun v ‚Ü¶ by simp [mkVec‚ÇÇDef]

instance mkVec‚ÇÇ_definable : ùö∫‚ÇÅ-Function‚ÇÇ (fun x y : V ‚Ü¶ ?[x, y]) := mkVec‚ÇÇ_defined.to_definable

instance mkVec‚ÇÇ_definable' (Œì m) : Œì-[m + 1]-Function‚ÇÇ (fun x y : V ‚Ü¶ ?[x, y]) := mkVec‚ÇÇ_definable.of_sigmaOne

end

end adjoin

/-!

### N-th element of List

-/

namespace Nth

def Phi (C : Set V) (pr : V) : Prop :=
  (‚àÉ v, pr = ‚ü™v, 0, fstIdx v‚ü´) ‚à® (‚àÉ v i x, pr = ‚ü™v, i + 1, x‚ü´ ‚àß ‚ü™sndIdx v, i, x‚ü´ ‚àà C)

private lemma phi_iff (C pr : V) :
    Phi {x | x ‚àà C} pr ‚Üî
    (‚àÉ v ‚â§ pr, ‚àÉ fst ‚â§ v, fst = fstIdx v ‚àß pr = ‚ü™v, 0, fst‚ü´) ‚à®
    (‚àÉ v ‚â§ pr, ‚àÉ i ‚â§ pr, ‚àÉ x ‚â§ pr, pr = ‚ü™v, i + 1, x‚ü´ ‚àß ‚àÉ snd ‚â§ v, snd = sndIdx v ‚àß ‚àÉ six < C, six = ‚ü™snd, i, x‚ü´ ‚àß six ‚àà C) := by
  constructor
  ¬∑ rintro (‚ü®v, rfl‚ü© | ‚ü®v, i, x, rfl, hC‚ü©)
    ¬∑ left; exact ‚ü®v, by simp, _, by simp, rfl, rfl‚ü©
    ¬∑ right; exact ‚ü®v, by simp,
        i, le_trans (le_trans (by simp) (le_pair_left _ _)) (le_pair_right _ _),
        x, le_trans (by simp) (le_pair_right _ _), rfl, _, by simp, rfl, _, lt_of_mem hC, rfl, hC‚ü©
  ¬∑ rintro (‚ü®v, _, _, _, rfl, rfl‚ü© | ‚ü®v, _, i, _, x, _, rfl, _, _, rfl, _, _, rfl, hC‚ü©)
    ¬∑ left; exact ‚ü®v, rfl‚ü©
    ¬∑ right; exact ‚ü®v, i, x, rfl, hC‚ü©

def blueprint : Fixpoint.Blueprint 0 where
  core := .ofZero
    (.mkSigma ‚Äúpr C.
    (‚àÉ v <‚Å∫ pr, ‚àÉ fst <‚Å∫ v, !fstIdxDef fst v ‚àß !pair‚ÇÉDef pr v 0 fst) ‚à®
    (‚àÉ v <‚Å∫ pr, ‚àÉ i <‚Å∫ pr, ‚àÉ x <‚Å∫ pr, !pair‚ÇÉDef pr v (i + 1) x ‚àß
      ‚àÉ snd <‚Å∫ v, !sndIdxDef snd v ‚àß ‚àÉ six < C, !pair‚ÇÉDef six snd i x ‚àß six ‚àà C)‚Äù
    (by simp))
    _

def adjointruction : Fixpoint.Construction V blueprint where
  Œ¶ := fun _ ‚Ü¶ Phi
  defined := .of_zero <| .mk fun v ‚Ü¶ by simp [phi_iff]
  monotone := by
    rintro C C' hC _ x (h | ‚ü®v, i, x, rfl, h‚ü©)
    ¬∑ left; exact h
    ¬∑ right; exact ‚ü®v, i, x, rfl, hC h‚ü©

instance : adjointruction.Finite V where
  finite := by
    rintro C v x (h | ‚ü®v, i, x, rfl, h‚ü©)
    ¬∑ exact ‚ü®0, Or.inl h‚ü©
    ¬∑ exact ‚ü®‚ü™sndIdx v, i, x‚ü´ + 1, Or.inr ‚ü®v, i, x, rfl, h, by simp‚ü©‚ü©

def Graph : V ‚Üí Prop := adjointruction.Fixpoint ![]

section

def graphDef : ùö∫‚ÇÅ.Semisentence 1 := blueprint.fixpointDef

instance graph_defined : ùö∫‚ÇÅ-Predicate (Graph : V ‚Üí Prop) via graphDef := adjointruction.fixpoint_defined

instance graph_definable : ùö∫‚ÇÅ-Predicate (Graph : V ‚Üí Prop) := graph_defined.to_definable

instance graph_definable' : ùö∫-[0 + 1]-Predicate (Graph : V ‚Üí Prop) := graph_definable

end

/-- TODO: move-/
@[simp] lemma zero_ne_add_one (x : V) : 0 ‚â† x + 1 := ne_of_lt (by simp)

lemma graph_case {pr : V} :
    Graph pr ‚Üî
    (‚àÉ v, pr = ‚ü™v, 0, fstIdx v‚ü´) ‚à® (‚àÉ v i x, pr = ‚ü™v, i + 1, x‚ü´ ‚àß Graph ‚ü™sndIdx v, i, x‚ü´) :=
  adjointruction.case

lemma graph_zero {v x : V} :
    Graph ‚ü™v, 0, x‚ü´ ‚Üî x = fstIdx v := by
  constructor
  ¬∑ intro h
    rcases graph_case.mp h with (‚ü®w, h‚ü© | ‚ü®w, i, x, h, _‚ü©)
    ¬∑ rcases show v = w ‚àß x = fstIdx w by simpa using h with ‚ü®rfl, rfl, rfl‚ü©; rfl
    ¬∑ simp at h
  ¬∑ rintro rfl; exact graph_case.mpr <| Or.inl ‚ü®v, rfl‚ü©

lemma graph_succ {v i x : V} :
    Graph ‚ü™v, i + 1, x‚ü´ ‚Üî Graph ‚ü™sndIdx v, i, x‚ü´ := by
  constructor
  ¬∑ intro h
    rcases graph_case.mp h with (‚ü®w, h‚ü© | ‚ü®w, j, y, h, hw‚ü©)
    ¬∑ simp at h
    ¬∑ rcases show v = w ‚àß i = j ‚àß x = y by simpa using h with ‚ü®rfl, rfl, rfl‚ü©; exact hw
  ¬∑ intro h; exact graph_case.mpr <| Or.inr ‚ü®v, i, x, rfl, h‚ü©

lemma graph_exists (v i : V) : ‚àÉ x, Graph ‚ü™v, i, x‚ü´ := by
  suffices ‚àÄ i' ‚â§ i, ‚àÄ v' ‚â§ v, ‚àÉ x, Graph ‚ü™v', i', x‚ü´ from this i (by simp) v (by simp)
  intro i' hi'
  induction i' using ISigma1.sigma1_succ_induction
  ¬∑ definability
  case zero =>
    intro v' _
    exact ‚ü®fstIdx v', graph_case.mpr <| Or.inl ‚ü®v', rfl‚ü©‚ü©
  case succ i' ih =>
    intro v' hv'
    rcases ih (le_trans le_self_add hi') (sndIdx v') (le_trans (by simp) hv') with ‚ü®x, hx‚ü©
    exact ‚ü®x, graph_case.mpr <| Or.inr ‚ü®v', i', x, rfl, hx‚ü©‚ü©

lemma graph_unique {v i x‚ÇÅ x‚ÇÇ : V} : Graph ‚ü™v, i, x‚ÇÅ‚ü´ ‚Üí Graph ‚ü™v, i, x‚ÇÇ‚ü´ ‚Üí x‚ÇÅ = x‚ÇÇ := by
  induction i using ISigma1.pi1_succ_induction generalizing v x‚ÇÅ x‚ÇÇ
  ¬∑ definability
  case zero =>
    simp only [graph_zero]
    rintro rfl rfl; rfl
  case succ i ih =>
    simp only [graph_succ]
    exact ih

lemma graph_existsUnique (v i : V) : ‚àÉ! x, Graph ‚ü™v, i, x‚ü´ := by
  rcases graph_exists v i with ‚ü®x, hx‚ü©
  exact ExistsUnique.intro x hx (fun y hy ‚Ü¶ graph_unique hy hx)

end Nth

section nth

open Nth

noncomputable def nth (v i : V) : V := Classical.choose! (graph_existsUnique v i)

scoped notation:max v:max ".[" i "]" => nth v i

lemma nth_graph (v i : V) : Graph ‚ü™v, i, v.[i]‚ü´ :=
  Classical.choose!_spec (graph_existsUnique v i)

lemma nth_eq_of_graph {v i x : V} (h : Graph ‚ü™v, i, x‚ü´) : nth v i = x := graph_unique (nth_graph v i) h

lemma nth_zero (v : V) : v.[0] = fstIdx v := nth_eq_of_graph (graph_zero.mpr rfl)

lemma nth_succ (v i : V) : v.[i + 1] = (sndIdx v).[i] := nth_eq_of_graph (graph_succ.mpr <| nth_graph _ _)

@[simp] lemma nth_adjoin_zero (x v : V) : (x ‚à∑ v).[0] = x := by
  simp [nth_zero]

@[simp] lemma nth_adjoin_succ (x v i : V) : (x ‚à∑ v).[i + 1] = v.[i] := by
  simp [nth_succ]

@[simp] lemma nth_adjoin_one (x v : V) : (x ‚à∑ v).[1] = v.[0] := by
  simpa using nth_adjoin_succ x v 0

@[simp] lemma nth_adjoin_two (x v : V) : (x ‚à∑ v).[2] = v.[1] := by
  simpa [-nth_adjoin_succ, one_add_one_eq_two] using nth_adjoin_succ x v 1

lemma adjoin_cases (x : V) : x = 0 ‚à® ‚àÉ y v, x = y ‚à∑ v := by
  rcases zero_or_succ x with (rfl | ‚ü®z, rfl‚ü©)
  ¬∑ simp
  ¬∑ right; exact ‚ü®œÄ‚ÇÅ z, œÄ‚ÇÇ z, by simp [adjoin]‚ü©

lemma adjoin_induction (Œì) {P : V ‚Üí Prop} (hP : Œì-[1]-Predicate P)
    (nil : P 0) (adjoin : ‚àÄ x v, P v ‚Üí P (x ‚à∑ v)) : ‚àÄ v, P v :=
  ISigma1.order_induction Œì hP (by
    intro v ih
    rcases nil_or_adjoin v with (rfl | ‚ü®x, v, rfl‚ü©)
    ¬∑ exact nil
    ¬∑ exact adjoin _ _ (ih v (by simp)))

@[elab_as_elim]
lemma adjoin_ISigma1.sigma1_succ_induction {P : V ‚Üí Prop} (hP : ùö∫‚ÇÅ-Predicate P)
    (nil : P 0) (adjoin : ‚àÄ x v, P v ‚Üí P (x ‚à∑ v)) : ‚àÄ v, P v :=
  adjoin_induction ùö∫ hP nil adjoin

@[elab_as_elim]
lemma adjoin_ISigma1.pi1_succ_induction {P : V ‚Üí Prop} (hP : ùö∑‚ÇÅ-Predicate P)
    (nil : P 0) (adjoin : ‚àÄ x v, P v ‚Üí P (x ‚à∑ v)) : ‚àÄ v, P v :=
  adjoin_induction ùö∑ hP nil adjoin

section

def _root_.LO.FirstOrder.Arithmetic.nthDef : ùö∫‚ÇÅ.Semisentence 3 :=
  .mkSigma ‚Äúy v i. ‚àÉ pr, !pair‚ÇÉDef pr v i y ‚àß !graphDef pr‚Äù

set_option linter.flexible false in
instance nth_defined : ùö∫‚ÇÅ-Function‚ÇÇ (nth : V ‚Üí V ‚Üí V) via nthDef := .mk fun v ‚Ü¶ by
  simp [nthDef]
  constructor
  ¬∑ intro h; simp [nth_eq_of_graph h]
  ¬∑ intro h; rw [h]; exact nth_graph _ _

instance nth_definable : ùö∫‚ÇÅ-Function‚ÇÇ (nth : V ‚Üí V ‚Üí V) := nth_defined.to_definable

instance nth_definable' (Œì m) : Œì-[m + 1]-Function‚ÇÇ (nth : V ‚Üí V ‚Üí V) := nth_definable.of_sigmaOne

end

lemma adjoin_absolute (a v : ‚Ñï) : ((a ‚à∑ v : ‚Ñï) : V) = (a : V) ‚à∑ (v : V) := by
  simpa using DefinedFunction.shigmaZero_absolute_func V adjoin_defined adjoin_defined ![a, v]

/-- TODO: move-/
lemma pi‚ÇÅ_zero : œÄ‚ÇÅ (0 : V) = 0 := nonpos_iff_eq_zero.mp (pi‚ÇÅ_le_self 0)

lemma pi‚ÇÇ_zero : œÄ‚ÇÇ (0 : V) = 0 := nonpos_iff_eq_zero.mp (pi‚ÇÇ_le_self 0)

@[simp] lemma nth_zero_idx (i : V) : (0).[i] = 0 := by
  induction i using ISigma1.sigma1_succ_induction
  ¬∑ definability
  case zero => simp [nth_zero, fstIdx, pi‚ÇÅ_zero]
  case succ i ih => simp [nth_succ, sndIdx, pi‚ÇÇ_zero, ih]

lemma nth_lt_of_pos {v} (hv : 0 < v) (i : V) : v.[i] < v := by
  induction i using ISigma1.pi1_succ_induction generalizing v
  ¬∑ definability
  case zero =>
    rcases zero_or_succ v with (rfl | ‚ü®v, rfl‚ü©)
    ¬∑ simp at hv
    ¬∑ simp [succ_eq_adjoin]
  case succ i ih =>
    rcases zero_or_succ v with (rfl | ‚ü®v, rfl‚ü©)
    ¬∑ simp at hv
    ¬∑ simp only [succ_eq_adjoin v, nth_adjoin_succ]
      rcases eq_zero_or_pos (œÄ‚ÇÇ v) with (h | h)
      ¬∑ simp [h]
      ¬∑ exact lt_trans (ih h) (by simp)

@[simp] lemma nth_le (v i : V) : v.[i] ‚â§ v := by
  rcases eq_zero_or_pos v with (h | h)
  ¬∑ simp [h]
  ¬∑ exact le_of_lt <| nth_lt_of_pos h i

end nth


/-!

### Inductivly Construction of Function on List

-/

namespace VecRec

structure Blueprint (arity : ‚Ñï) where
  nil : ùö∫‚ÇÅ.Semisentence (arity + 1)
  adjoin : ùö∫‚ÇÅ.Semisentence (arity + 4)

namespace Blueprint

variable {arity : ‚Ñï} (Œ≤ : Blueprint arity)

def blueprint : Fixpoint.Blueprint arity where
  core := .mkDelta
    (.mkSigma ‚Äúpr C.
        (‚àÉ nil, !Œ≤.nil nil ‚ãØ ‚àß !pairDef pr 0 nil) ‚à®
        (‚àÉ x < pr, ‚àÉ xs < pr, ‚àÉ ih < C,
          ‚àÉ xxs, !adjoinDef xxs x xs ‚àß
          ‚àÉ adjoin, !Œ≤.adjoin adjoin x xs ih ‚ãØ ‚àß
          !pairDef pr xxs adjoin ‚àß :‚ü™xs, ih‚ü´:‚àà C)‚Äù
      (by simp))
    (.mkPi ‚Äúpr C.
        (‚àÄ nil, !Œ≤.nil nil ‚ãØ ‚Üí !pairDef pr 0 nil) ‚à®
        (‚àÉ x < pr, ‚àÉ xs < pr, ‚àÉ ih < C,
          ‚àÄ xxs, !adjoinDef xxs x xs ‚Üí
          ‚àÄ adjoin, !Œ≤.adjoin adjoin x xs ih ‚ãØ ‚Üí
          !pairDef pr xxs adjoin ‚àß :‚ü™xs, ih‚ü´:‚àà C)‚Äù
      (by simp))

def graphDef : ùö∫‚ÇÅ.Semisentence (arity + 1) := Œ≤.blueprint.fixpointDef

def resultDef : ùö∫‚ÇÅ.Semisentence (arity + 2) :=
  .mkSigma ‚Äúy xs. ‚àÉ pr, !pairDef pr xs y ‚àß !Œ≤.graphDef pr ‚ãØ‚Äù

end Blueprint

variable (V)

structure Construction {arity : ‚Ñï} (Œ≤ : Blueprint arity) where
  nil (param : Fin arity ‚Üí V) : V
  adjoin (param : Fin arity ‚Üí V) (x xs ih) : V
  nil_defined : ùö∫‚ÇÅ.DefinedFunction nil Œ≤.nil
  adjoin_defined : ùö∫‚ÇÅ.DefinedFunction (fun v ‚Ü¶ adjoin (v ¬∑.succ.succ.succ) (v 0) (v 1) (v 2)) Œ≤.adjoin

variable {V}

namespace Construction

variable {arity : ‚Ñï} {Œ≤ : Blueprint arity} (c : Construction V Œ≤)

def Phi (param : Fin arity ‚Üí V) (C : Set V) (pr : V) : Prop :=
  pr = ‚ü™0, c.nil param‚ü´ ‚à® (‚àÉ x xs ih, pr = ‚ü™x ‚à∑ xs, c.adjoin param x xs ih‚ü´ ‚àß ‚ü™xs, ih‚ü´ ‚àà C)

private lemma phi_iff (param : Fin arity ‚Üí V) (C pr : V) :
    c.Phi param {x | x ‚àà C} pr ‚Üî
    pr = ‚ü™0, c.nil param‚ü´ ‚à® (‚àÉ x < pr, ‚àÉ xs < pr, ‚àÉ ih < C, pr = ‚ü™x ‚à∑ xs, c.adjoin param x xs ih‚ü´ ‚àß ‚ü™xs, ih‚ü´ ‚àà C) := by
  constructor
  ¬∑ rintro (h | ‚ü®x, xs, ih, rfl, hC‚ü©)
    ¬∑ left; exact h
    ¬∑ right
      exact ‚ü®x, lt_of_lt_of_le (by simp) (le_pair_left _ _),
        xs, lt_of_lt_of_le (by simp) (le_pair_left _ _), ih, lt_of_mem_rng hC, rfl , hC‚ü©
  ¬∑ rintro (h | ‚ü®x, _, xs, _, ih, _, rfl, hC‚ü©)
    ¬∑ left; exact h
    ¬∑ right; exact ‚ü®x, xs, ih, rfl, hC‚ü©

def adjointruction : Fixpoint.Construction V Œ≤.blueprint where
  Œ¶ := c.Phi
  defined := .mk ‚ü®by
    intro v; simp [Blueprint.blueprint, c.nil_defined.iff, c.adjoin_defined.iff], by
    intro v
    symm
    simpa [Blueprint.blueprint, c.nil_defined.iff, c.adjoin_defined.iff] using c.phi_iff _ _ _‚ü©
  monotone := by
    rintro C C' hC _ x (h | ‚ü®v, i, hv, rfl, h‚ü©)
    ¬∑ left; exact h
    ¬∑ right; exact ‚ü®v, i, hv, rfl, hC h‚ü©

instance : c.adjointruction.Finite V where
  finite := by
    rintro C v x (h | ‚ü®x, xs, ih, rfl, h‚ü©)
    ¬∑ exact ‚ü®0, Or.inl h‚ü©
    ¬∑ exact ‚ü®‚ü™xs, ih‚ü´ + 1, Or.inr ‚ü®x, xs, ih, rfl, h, by simp‚ü©‚ü©

variable (param : Fin arity ‚Üí V)

def Graph : V ‚Üí Prop := c.adjointruction.Fixpoint param

section

lemma graph_defined : ùö∫‚ÇÅ.Defined (fun v ‚Ü¶ c.Graph (v ¬∑.succ) (v 0)) Œ≤.graphDef :=
  c.adjointruction.fixpoint_defined

instance graph_definable : ùö∫‚ÇÅ.Definable (fun v ‚Ü¶ c.Graph (v ¬∑.succ) (v 0)) := c.graph_defined.to_definable

instance graph_definable' (param) : ùö∫‚ÇÅ-Predicate (c.Graph param) := by
  simpa using HierarchySymbol.Definable.retractiont (n := 1) c.graph_definable (#0 :> fun i ‚Ü¶ &(param i))

instance graph_definable'' (param) : ùö∫-[0 + 1]-Predicate (c.Graph param) := c.graph_definable' param

end

variable {param}

lemma graph_case {pr : V} :
    c.Graph param pr ‚Üî pr = ‚ü™0, c.nil param‚ü´ ‚à® (‚àÉ x xs ih, pr = ‚ü™x ‚à∑ xs, c.adjoin param x xs ih‚ü´ ‚àß c.Graph param ‚ü™xs, ih‚ü´) :=
  c.adjointruction.case

lemma graph_nil {l : V} :
    c.Graph param ‚ü™0, l‚ü´ ‚Üî l = c.nil param := by
  constructor
  ¬∑ intro h
    rcases c.graph_case.mp h with (h | ‚ü®x, xs, ih, h, _‚ü©)
    ¬∑ rcases show l = c.nil param by simpa using h with ‚ü®rfl, rfl‚ü©; rfl
    ¬∑ simp at h
  ¬∑ rintro rfl; exact c.graph_case.mpr <| Or.inl rfl

lemma graph_adjoin {x xs y : V} :
    c.Graph param ‚ü™x ‚à∑ xs, y‚ü´ ‚Üî ‚àÉ y', y = c.adjoin param x xs y' ‚àß c.Graph param ‚ü™xs, y'‚ü´ := by
  constructor
  ¬∑ intro h
    rcases c.graph_case.mp h with (h | ‚ü®z, zs, v, h, hg‚ü©)
    ¬∑ simp at h
    ¬∑ rcases show (x = z ‚àß xs = zs) ‚àß y = c.adjoin param z zs v by simpa using h with ‚ü®‚ü®rfl, rfl‚ü©, rfl‚ü©
      exact ‚ü®v, rfl, hg‚ü©
  ¬∑ rintro ‚ü®y, rfl, h‚ü©; exact c.graph_case.mpr <| Or.inr ‚ü®x, xs, y, rfl, h‚ü©

variable (param)

lemma graph_exists (xs : V) : ‚àÉ y, c.Graph param ‚ü™xs, y‚ü´ := by
  induction xs using adjoin_ISigma1.sigma1_succ_induction
  ¬∑ definability
  case nil =>
    exact ‚ü®c.nil param, c.graph_nil.mpr rfl‚ü©
  case adjoin x xs ih =>
    ¬∑ rcases ih with ‚ü®y, hy‚ü©
      exact ‚ü®c.adjoin param x xs y, c.graph_adjoin.mpr ‚ü®y, rfl, hy‚ü©‚ü©

variable {param}

lemma graph_unique {xs y‚ÇÅ y‚ÇÇ : V} : c.Graph param ‚ü™xs, y‚ÇÅ‚ü´ ‚Üí c.Graph param ‚ü™xs, y‚ÇÇ‚ü´ ‚Üí y‚ÇÅ = y‚ÇÇ := by
  induction xs using adjoin_ISigma1.pi1_succ_induction generalizing y‚ÇÅ y‚ÇÇ
  ¬∑ definability
  case nil =>
    simp only [graph_nil]; rintro rfl rfl; rfl
  case adjoin x v ih =>
    simp only [graph_adjoin, forall_exists_index, and_imp]
    rintro l‚ÇÅ rfl h‚ÇÅ l‚ÇÇ rfl h‚ÇÇ
    rcases ih h‚ÇÅ h‚ÇÇ; rfl

variable (param)

lemma graph_existsUnique (xs : V) : ‚àÉ! y, c.Graph param ‚ü™xs, y‚ü´ := by
  rcases c.graph_exists param xs with ‚ü®y, hy‚ü©
  exact ExistsUnique.intro y hy (fun y' hy' ‚Ü¶ c.graph_unique hy' hy)

noncomputable def result (xs : V) : V := Classical.choose! (c.graph_existsUnique param xs)

lemma result_graph (xs : V) : c.Graph param ‚ü™xs, c.result param xs‚ü´ :=
  Classical.choose!_spec (c.graph_existsUnique param xs)

lemma result_eq_of_graph {xs y : V} (h : c.Graph param ‚ü™xs, y‚ü´) : c.result param xs = y :=
  c.graph_unique (c.result_graph param xs) h

@[simp] lemma result_nil : c.result param (0 : V) = c.nil param := c.result_eq_of_graph param (c.graph_nil.mpr rfl)

@[simp] lemma result_adjoin (x xs : V) :
    c.result param (x ‚à∑ xs) = c.adjoin param x xs (c.result param xs) :=
  c.result_eq_of_graph param (c.graph_adjoin.mpr ‚ü®_, rfl, c.result_graph param xs‚ü©)

section

set_option linter.flexible false in
lemma result_defined : ùö∫‚ÇÅ.DefinedFunction (fun v ‚Ü¶ c.result (v ¬∑.succ) (v 0)) Œ≤.resultDef := .mk fun v ‚Ü¶ by
  simp [Blueprint.resultDef, c.graph_defined.iff]
  constructor
  ¬∑ intro h; symm; simpa using c.result_eq_of_graph _ h
  ¬∑ intro h; rw [h]; exact c.result_graph _ _

@[simp] lemma eval_resultDef (v) :
    Semiformula.Evalbm V v Œ≤.resultDef.val ‚Üî v 0 = c.result (v ¬∑.succ.succ) (v 1) := c.result_defined.iff

instance result_definable : ùö∫‚ÇÅ.DefinableFunction (fun v ‚Ü¶ c.result (v ¬∑.succ) (v 0)) :=
  c.result_defined.to_definable

instance result_definable' (Œì m) :
    Œì-[m + 1].DefinableFunction (fun v ‚Ü¶ c.result (v ¬∑.succ) (v 0)) := c.result_definable.of_sigmaOne

end

end Construction

end VecRec

/-!

### Length of List

-/

namespace Len

def blueprint : VecRec.Blueprint 0 where
  nil := .mkSigma ‚Äúy. y = 0‚Äù
  adjoin := .mkSigma ‚Äúy x xs ih. y = ih + 1‚Äù

def adjointruction : VecRec.Construction V blueprint where
  nil _ := 0
  adjoin _ _ _ ih := ih + 1
  nil_defined := .mk fun v ‚Ü¶ by simp [blueprint]
  adjoin_defined := .mk fun v ‚Ü¶ by simp [blueprint]

end Len

section len

open Len

noncomputable def len (v : V) : V := adjointruction.result ![] v

@[simp] lemma len_nil : len (0 : V) = 0 := by simp [len, adjointruction]

@[simp] lemma len_adjoin (x v : V) : len (x ‚à∑ v) = len v + 1 := by simp [len, adjointruction]

section

def _root_.LO.FirstOrder.Arithmetic.lenDef : ùö∫‚ÇÅ.Semisentence 2 := blueprint.resultDef

instance len_defined : ùö∫‚ÇÅ-Function‚ÇÅ (len : V ‚Üí V) via lenDef := adjointruction.result_defined

instance len_definable : ùö∫‚ÇÅ-Function‚ÇÅ (len : V ‚Üí V) := len_defined.to_definable

instance len_definable' (Œì m) : Œì-[m + 1]-Function‚ÇÅ (len : V ‚Üí V) := len_definable.of_sigmaOne

end

@[simp] lemma len_zero_iff_eq_nil {v : V} : len v = 0 ‚Üî v = 0 := by
  rcases nil_or_adjoin v with (rfl | ‚ü®x, v, rfl‚ü©) <;> simp

lemma nth_lt_len {v i : V} (hl : len v ‚â§ i) : v.[i] = 0 := by
  induction v using adjoin_ISigma1.pi1_succ_induction generalizing i
  ¬∑ definability
  case nil => simp
  case adjoin x v ih =>
    rcases zero_or_succ i with (rfl | ‚ü®i, rfl‚ü©)
    ¬∑ simp at hl
    simpa using ih (by simpa using hl)

@[simp] lemma len_le (v : V) : len v ‚â§ v := by
  induction v using adjoin_ISigma1.pi1_succ_induction
  ¬∑ definability
  case nil => simp
  case adjoin x v ih =>
    simp only [len_adjoin]
    simp only [adjoin, add_le_add_iff_right]
    exact le_trans ih (le_pair_right x v)

end len

lemma nth_ext {v‚ÇÅ v‚ÇÇ : V} (hl : len v‚ÇÅ = len v‚ÇÇ) (H : ‚àÄ i < len v‚ÇÅ, v‚ÇÅ.[i] = v‚ÇÇ.[i]) : v‚ÇÅ = v‚ÇÇ := by
  induction v‚ÇÅ using adjoin_ISigma1.pi1_succ_induction generalizing v‚ÇÇ
  ¬∑ definability
  case nil =>
    exact Eq.symm <| len_zero_iff_eq_nil.mp (by simp [‚Üêhl])
  case adjoin x‚ÇÅ v‚ÇÅ ih =>
    rcases nil_or_adjoin v‚ÇÇ with (rfl | ‚ü®x‚ÇÇ, v‚ÇÇ, rfl‚ü©)
    ¬∑ simp at hl
    have hx : x‚ÇÅ = x‚ÇÇ := by simpa using H 0 (by simp)
    have hv : v‚ÇÅ = v‚ÇÇ := ih (by simpa using hl) (by intro i hi; simpa using H (i + 1) (by simpa using hi))
    simp [hx, hv]

lemma nth_ext' (l : V) {v‚ÇÅ v‚ÇÇ : V} (hl‚ÇÅ : len v‚ÇÅ = l) (hl‚ÇÇ : len v‚ÇÇ = l) (H : ‚àÄ i < l, v‚ÇÅ.[i] = v‚ÇÇ.[i]) : v‚ÇÅ = v‚ÇÇ := by
  rcases hl‚ÇÇ; exact nth_ext hl‚ÇÅ (by simpa [hl‚ÇÅ] using H)

lemma le_of_nth_le_nth {v‚ÇÅ v‚ÇÇ : V} (hl : len v‚ÇÅ = len v‚ÇÇ) (H : ‚àÄ i < len v‚ÇÅ, v‚ÇÅ.[i] ‚â§ v‚ÇÇ.[i]) : v‚ÇÅ ‚â§ v‚ÇÇ := by
  induction v‚ÇÅ using adjoin_ISigma1.pi1_succ_induction generalizing v‚ÇÇ
  ¬∑ definability
  case nil => simp
  case adjoin x‚ÇÅ v‚ÇÅ ih =>
    rcases nil_or_adjoin v‚ÇÇ with (rfl | ‚ü®x‚ÇÇ, v‚ÇÇ, rfl‚ü©)
    ¬∑ simp at hl
    have hx : x‚ÇÅ ‚â§ x‚ÇÇ := by simpa using H 0 (by simp)
    have hv : v‚ÇÅ ‚â§ v‚ÇÇ := ih (by simpa using hl) (by intro i hi; simpa using H (i + 1) (by simpa using hi))
    exact adjoin_le_adjoin hx hv

lemma nth_lt_self {v i : V} (hi : i < len v) : v.[i] < v := by
  induction v using adjoin_ISigma1.pi1_succ_induction generalizing i
  ¬∑ definability
  case nil => simp at hi
  case adjoin x v ih =>
    rcases zero_or_succ i with (rfl | ‚ü®i, rfl‚ü©)
    ¬∑ simp
    ¬∑ simpa using lt_trans (ih (by simpa using hi)) (by simp)

theorem sigmaOne_skolem_vec {R : V ‚Üí V ‚Üí Prop} (hP : ùö∫‚ÇÅ-Relation R) {l}
    (H : ‚àÄ x < l, ‚àÉ y, R x y) : ‚àÉ v, len v = l ‚àß ‚àÄ i < l, R i v.[i] := by
  have : ‚àÄ k ‚â§ l, ‚àÉ v, len v = k ‚àß ‚àÄ i < k, R (l - k + i) v.[i] := by
    intro k hk
    induction k using ISigma1.sigma1_succ_induction
    ¬∑ definability
    case zero => exact ‚ü®0, by simp‚ü©
    case succ k ih =>
      rcases ih (le_trans (by simp) hk) with ‚ü®v, hvk, hv‚ü©
      have : ‚àÉ y, R (l - (k + 1)) y := H (l - (k + 1)) (by simp [tsub_lt_iff_left hk])
      rcases this with ‚ü®y, hy‚ü©
      exact ‚ü®y ‚à∑ v, by simp [hvk], fun i hi ‚Ü¶ by
        rcases zero_or_succ i with (rfl | ‚ü®i, rfl‚ü©)
        ¬∑ simpa using hy
        ¬∑ simpa [sub_succ_add_succ (succ_le_iff_lt.mp hk) i] using hv i (by simpa using hi)‚ü©
  simpa using this l (by rfl)

lemma eq_singleton_iff_len_eq_one {v : V} : len v = 1 ‚Üî ‚àÉ x, v = ?[x] := by
  constructor
  ¬∑ intro h; exact ‚ü®v.[0], nth_ext (by simp [h]) (by simp [h])‚ü©
  ¬∑ rintro ‚ü®x, rfl‚ü©; simp

lemma eq_doubleton_of_len_eq_two {v : V} : len v = 2 ‚Üî ‚àÉ x y, v = ?[x, y] := by
  constructor
  ¬∑ intro h; exact ‚ü®v.[0], v.[1],
      nth_ext (by simp [h, one_add_one_eq_two]) (by simp [lt_two_iff_le_one, le_one_iff_eq_zero_or_one, h])‚ü©
  ¬∑ rintro ‚ü®x, y, rfl‚ü©; simp [one_add_one_eq_two]


/-!

### Maximum of List

-/

namespace ListMax

def blueprint : VecRec.Blueprint 0 where
  nil := .mkSigma ‚Äúy. y = 0‚Äù
  adjoin := .mkSigma ‚Äúy x xs ih. !FirstOrder.Arithmetic.max y x ih‚Äù

noncomputable def adjointruction : VecRec.Construction V blueprint where
  nil _ := 0
  adjoin _ x _ ih := max x ih
  nil_defined := .mk fun v ‚Ü¶ by simp [blueprint]
  adjoin_defined := .mk fun v ‚Ü¶ by simp [blueprint]

end ListMax

section listMax

open ListMax

noncomputable def listMax (v : V) : V := adjointruction.result ![] v

@[simp] lemma listMax_nil : listMax (0 : V) = 0 := by simp [listMax, adjointruction]

@[simp] lemma listMax_adjoin (x v : V) : listMax (x ‚à∑ v) = max x (listMax v) := by simp [listMax, adjointruction]

section

def _root_.LO.FirstOrder.Arithmetic.listMaxDef : ùö∫‚ÇÅ.Semisentence 2 := blueprint.resultDef

instance listMax_defined : ùö∫‚ÇÅ-Function‚ÇÅ (listMax : V ‚Üí V) via listMaxDef := adjointruction.result_defined

instance listMax_definable : ùö∫‚ÇÅ-Function‚ÇÅ (listMax : V ‚Üí V) := listMax_defined.to_definable

instance listMax_definable' (Œì m) : Œì-[m + 1]-Function‚ÇÅ (listMax : V ‚Üí V) := listMax_definable.of_sigmaOne

end

lemma nth_le_listMax {i v : V} (h : i < len v) : v.[i] ‚â§ listMax v := by
  induction v using adjoin_ISigma1.pi1_succ_induction generalizing i
  ¬∑ definability
  case nil => simp
  case adjoin x v ih =>
    rcases zero_or_succ i with (rfl | ‚ü®i, rfl‚ü©)
    ¬∑ simp
    ¬∑ simp [ih (by simpa using h)]

lemma listMaxss_le {v z : V} (h : ‚àÄ i < len v, v.[i] ‚â§ z) : listMax v ‚â§ z := by
  induction v using adjoin_ISigma1.pi1_succ_induction
  ¬∑ definability
  case nil => simp
  case adjoin x v ih =>
    simp only [listMax_adjoin, max_le_iff]
    constructor
    ¬∑ simpa using h 0 (by simp)
    ¬∑ exact ih (fun i hi ‚Ü¶ by simpa using h (i + 1) (by simp [hi]))

lemma listMaxss_le_iff {v z : V} : listMax v ‚â§ z ‚Üî ‚àÄ i < len v, v.[i] ‚â§ z := by
  constructor
  ¬∑ intro h i hi; exact le_trans (nth_le_listMax hi) h
  ¬∑ exact listMaxss_le

/-
lemma nth_le_listMaxs (v : V) (hv : v ‚â† 0) : ‚àÉ i < len v, v.[i] = listMax v := by
  induction v using adjoin_ISigma1.sigma1_succ_induction
  ¬∑ definability
  case nil => simp at hv
  case adjoin x v ih =>
    simp
-/

end listMax

/-!

### Take Last k-Element

-/

namespace TakeLast

def blueprint : VecRec.Blueprint 1 where
  nil := .mkSigma ‚Äúy k. y = 0‚Äù
  adjoin := .mkSigma ‚Äúy x xs ih k.
    ‚àÉ l, !lenDef l xs ‚àß
    (l < k ‚Üí !adjoinDef y x xs) ‚àß (k ‚â§ l ‚Üí y = ih)‚Äù

noncomputable def adjointruction : VecRec.Construction V blueprint where
  nil _ := 0
  adjoin (param x xs ih) := if len xs < param 0 then x ‚à∑ xs else ih
  nil_defined := .mk fun v ‚Ü¶ by simp [blueprint]
  adjoin_defined := .mk fun v ‚Ü¶ by
    suffices
      (len (v 2) < v 4 ‚Üí v 0 = v 1 ‚à∑ v 2) ‚àß (v 4 ‚â§ len (v 2) ‚Üí v 0 = v 3) ‚Üî
      (v 0 = if len (v 2) < v 4 then v 1 ‚à∑ v 2 else v 3) by
      simpa [blueprint, Fin.isValue]
    rcases lt_or_ge (len (v 2)) (v 4) with (hv | hv)
    ¬∑ simp [hv]
    ¬∑ simp [hv, not_lt_of_ge hv]

end TakeLast

section takeLast

open TakeLast

noncomputable def takeLast (v k : V) : V := adjointruction.result ![k] v

@[simp] lemma takeLast_nil : takeLast (0 : V) k = 0 := by simp [takeLast, adjointruction]

lemma takeLast_adjoin (x v : V) :
    takeLast (x ‚à∑ v) k = if len v < k then x ‚à∑ v else takeLast v k := by simp [takeLast, adjointruction]

section

def _root_.LO.FirstOrder.Arithmetic.takeLastDef : ùö∫‚ÇÅ.Semisentence 3 := blueprint.resultDef

instance takeLast_defined : ùö∫‚ÇÅ-Function‚ÇÇ (takeLast : V ‚Üí V ‚Üí V) via takeLastDef := adjointruction.result_defined

instance takeLast_definable : ùö∫‚ÇÅ-Function‚ÇÇ (takeLast : V ‚Üí V ‚Üí V) := takeLast_defined.to_definable

instance takeLast_definable' (Œì m) : Œì-[m + 1]-Function‚ÇÇ (takeLast : V ‚Üí V ‚Üí V) := takeLast_definable.of_sigmaOne

end

lemma len_takeLast {v k : V} (h : k ‚â§ len v) : len (takeLast v k) = k := by
  induction v using adjoin_ISigma1.sigma1_succ_induction
  ¬∑ definability
  case nil => simp_all
  case adjoin x v ih =>
    have : k = len v + 1 ‚à® k ‚â§ len v := by
      rcases eq_or_lt_of_le h with (h | h)
      ¬∑ left; simpa using h
      ¬∑ right; simpa [lt_succ_iff_le] using h
    rcases this with (rfl | hkv)
    ¬∑ simp [takeLast_adjoin]
    ¬∑ simp [takeLast_adjoin, not_lt_of_ge hkv, ih hkv]

@[simp] lemma takeLast_len_self (v : V) : takeLast v (len v) = v := by
  rcases nil_or_adjoin v with (rfl | ‚ü®x, v, rfl‚ü©) <;> simp [takeLast_adjoin]

/-- TODO: move -/
@[simp] lemma add_sub_add (a b c : V) : (a + c) - (b + c) = a - b := add_tsub_add_eq_tsub_right a c b

@[simp] lemma takeLast_zero (v : V) : takeLast v 0 = 0 := by
  induction v using adjoin_ISigma1.sigma1_succ_induction
  ¬∑ definability
  case nil => simp
  case adjoin x v ih => simp [takeLast_adjoin, ih]

lemma takeLast_succ_of_lt {i v : V} (h : i < len v) : takeLast v (i + 1) = v.[len v - (i + 1)] ‚à∑ takeLast v i := by
  induction v using adjoin_ISigma1.sigma1_succ_induction generalizing i
  ¬∑ definability
  case nil => simp at h
  case adjoin x v ih =>
    rcases show i = len v ‚à® i < len v from eq_or_lt_of_le (by simpa [lt_succ_iff_le] using h) with (rfl | hi)
    ¬∑ simp [takeLast_adjoin]
    ¬∑ have : len v - i = len v - (i + 1) + 1 := by
        rw [‚ÜêPeanoMinus.sub_sub, sub_add_self_of_le (pos_iff_one_le.mp (tsub_pos_of_lt hi))]
      simpa [takeLast_adjoin, lt_succ_iff_le, not_le_of_gt hi, this, not_lt_of_gt hi] using ih hi

end takeLast

/-!

### Concatation

-/

namespace Concat

def blueprint : VecRec.Blueprint 1 where
  nil := .mkSigma ‚Äúy z. !adjoinDef y z 0‚Äù
  adjoin := .mkSigma ‚Äúy x xs ih z. !adjoinDef y x ih‚Äù

noncomputable def adjointruction : VecRec.Construction V blueprint where
  nil param := ?[param 0]
  adjoin (_ x _ ih) := x ‚à∑ ih
  nil_defined := .mk fun v ‚Ü¶ by simp [blueprint]
  adjoin_defined := .mk fun v ‚Ü¶ by simp [blueprint, Fin.isValue]

end Concat

section concat

open Concat

noncomputable def concat (v z : V) : V := adjointruction.result ![z] v

@[simp] lemma concat_nil (z : V) : concat 0 z = ?[z] := by simp [concat, adjointruction]

@[simp] lemma concat_adjoin (x v z : V) : concat (x ‚à∑ v) z = x ‚à∑ concat v z := by simp [concat, adjointruction]

section

def _root_.LO.FirstOrder.Arithmetic.concatDef : ùö∫‚ÇÅ.Semisentence 3 := blueprint.resultDef

instance concat_defined : ùö∫‚ÇÅ-Function‚ÇÇ (concat : V ‚Üí V ‚Üí V) via concatDef := adjointruction.result_defined

instance concat_definable : ùö∫‚ÇÅ-Function‚ÇÇ (concat : V ‚Üí V ‚Üí V) := concat_defined.to_definable

instance concat_definable' (Œì m) : Œì-[m + 1]-Function‚ÇÇ (concat : V ‚Üí V ‚Üí V) := concat_definable.of_sigmaOne

end

@[simp] lemma len_concat (v z : V) : len (concat v z) = len v + 1 := by
  induction v using adjoin_ISigma1.sigma1_succ_induction
  ¬∑ definability
  case nil => simp
  case adjoin x v ih => simp [ih]

lemma concat_nth_lt (v z : V) {i} (hi : i < len v) : (concat v z).[i] = v.[i] := by
  induction v using adjoin_ISigma1.sigma1_succ_induction generalizing i
  ¬∑ definability
  case nil => simp at hi
  case adjoin x v ih =>
    rcases zero_or_succ i with (rfl | ‚ü®i, rfl‚ü©)
    ¬∑ simp
    ¬∑ simp [ih (by simpa using hi)]

@[simp] lemma concat_nth_len (v z : V) : (concat v z).[len v] = z := by
  induction v using adjoin_ISigma1.sigma1_succ_induction
  ¬∑ definability
  case nil => simp
  case adjoin x v ih => simp [ih]

lemma concat_nth_len' (v z : V) {i} (hi : len v = i) : (concat v z).[i] = z := by
  rcases hi; simp

end concat

/-!

### Membership

-/

section vec_membership

def MemVec (x v : V) : Prop := ‚àÉ i < len v, x = v.[i]

scoped infix:40 " ‚àà·µ• " => MemVec

@[simp] lemma not_memVec_empty (x : V) : ¬¨x ‚àà·µ• 0 := by rintro ‚ü®i, h, _‚ü©; simp at h

lemma nth_mem_memVec {i v : V} (h : i < len v) : v.[i] ‚àà·µ• v := ‚ü®i, by simp [h]‚ü©

@[simp] lemma memVec_insert_fst {x v : V} : x ‚àà·µ• x ‚à∑ v := ‚ü®0, by simp‚ü©

@[simp] lemma memVec_adjoin_iff {x y v : V} : x ‚àà·µ• y ‚à∑ v ‚Üî x = y ‚à® x ‚àà·µ• v := by
  constructor
  ¬∑ rintro ‚ü®i, h, rfl‚ü©
    rcases zero_or_succ i with (rfl | ‚ü®i, rfl‚ü©)
    ¬∑ simp
    ¬∑ right; simpa using nth_mem_memVec (by simpa using h)
  ¬∑ rintro (rfl | hx)
    ¬∑ simp
    ¬∑ rcases hx with ‚ü®i, hi, rfl‚ü©
      exact ‚ü®i + 1, by simp [hi]‚ü©

lemma le_of_memVec {x v : V} (h : x ‚àà·µ• v) : x ‚â§ v := by
  rcases h with ‚ü®i, _, rfl‚ü©; simp

section

def _root_.LO.FirstOrder.Arithmetic.memVecDef : ùö´‚ÇÅ.Semisentence 2 := .mkDelta
  (.mkSigma ‚Äúx v. ‚àÉ l, !lenDef l v ‚àß ‚àÉ i < l, !nthDef x v i‚Äù)
  (.mkPi ‚Äúx v. ‚àÄ l, !lenDef l v ‚Üí ‚àÉ i < l, ‚àÄ vi, !nthDef vi v i ‚Üí x = vi‚Äù)

instance memVec_defined : ùö´‚ÇÅ-Relation (MemVec : V ‚Üí V ‚Üí Prop) via memVecDef :=
  ‚ü®by intro v; simp [memVecDef], by intro v; simp [memVecDef, MemVec]‚ü©

instance memVec_definable : ùö´‚ÇÅ-Relation (MemVec : V ‚Üí V ‚Üí Prop) := memVec_defined.to_definable

instance memVec_definable' (Œì m) : Œì-[m + 1]-Relation (MemVec : V ‚Üí V ‚Üí Prop) := memVec_definable.of_deltaOne

end

end vec_membership

/-!

### Subset

-/

section vec_subset

def SubsetVec (v w : V) : Prop := ‚àÄ x, x ‚àà·µ• v ‚Üí x ‚àà·µ• w

scoped infix:30 " ‚äÜ·µ• " => SubsetVec

@[simp, refl] lemma SubsetVec.refl (v : V) : v ‚äÜ·µ• v := fun _ hx ‚Ü¶ hx

@[simp] lemma subsetVec_insert_tail (x v : V) : v ‚äÜ·µ• x ‚à∑ v := by intro y hy; simp [hy]

section

def _root_.LO.FirstOrder.Arithmetic.subsetVecDef : ùö´‚ÇÅ.Semisentence 2 := .mkDelta
  (.mkSigma ‚Äúv w. ‚àÄ x <‚Å∫ v, !memVecDef.pi x v ‚Üí !memVecDef.sigma x w‚Äù)
  (.mkPi ‚Äúv w. ‚àÄ x <‚Å∫ v, !memVecDef.sigma x v ‚Üí !memVecDef.pi x w‚Äù)

set_option linter.flexible false in
instance subsetVec_defined : ùö´‚ÇÅ-Relation (SubsetVec : V ‚Üí V ‚Üí Prop) via subsetVecDef :=
  ‚ü®by intro v; simp [subsetVecDef, HierarchySymbol.Semiformula.val_sigma, memVec_defined.proper.iff'],
   by intro v
      simp [subsetVecDef, HierarchySymbol.Semiformula.val_sigma, memVec_defined.proper.iff']
      constructor
      ¬∑ intro h x hx; exact h x (le_of_memVec hx) hx
      ¬∑ intro h x _; exact h x‚ü©

instance subsetVec_definable : ùö´‚ÇÅ-Relation (SubsetVec : V ‚Üí V ‚Üí Prop) := subsetVec_defined.to_definable

instance subsetVec_definable' (Œì m) : Œì-[m + 1]-Relation (SubsetVec : V ‚Üí V ‚Üí Prop) := subsetVec_definable.of_deltaOne

end

end vec_subset

/-!

### Repeat

-/

section repaetVec

def repeatVec.blueprint : PR.Blueprint 1 where
  zero := .mkSigma ‚Äúy x. y = 0‚Äù
  succ := .mkSigma ‚Äúy ih n x. !adjoinDef y x ih‚Äù

noncomputable def repeatVec.adjointruction : PR.Construction V repeatVec.blueprint where
  zero := fun _ ‚Ü¶ 0
  succ := fun x _ ih ‚Ü¶ x 0 ‚à∑ ih
  zero_defined := .mk fun v ‚Ü¶ by simp [blueprint]
  succ_defined := .mk fun v ‚Ü¶ by simp [blueprint]

/-- `repeatVec x k = x ‚à∑ x ‚à∑ x ‚à∑ ... k times ... ‚à∑ 0`-/
noncomputable def repeatVec (x k : V) : V := repeatVec.adjointruction.result ![x] k

@[simp] lemma repeatVec_zero (x : V) : repeatVec x 0 = 0 := by simp [repeatVec, repeatVec.adjointruction]

@[simp] lemma repeatVec_succ (x k : V) : repeatVec x (k + 1) = x ‚à∑ repeatVec x k := by simp [repeatVec, repeatVec.adjointruction]

section

def _root_.LO.FirstOrder.Arithmetic.repeatVecDef : ùö∫‚ÇÅ.Semisentence 3 := repeatVec.blueprint.resultDef |>.rew (Rew.subst ![#0, #2, #1])

instance repeatVec_defined : ùö∫‚ÇÅ-Function‚ÇÇ (repeatVec : V ‚Üí V ‚Üí V) via repeatVecDef := .mk
  fun v ‚Ü¶ by simp [repeatVec.adjointruction.result_defined_iff, repeatVecDef]; rfl

instance repeatVec_definable : ùö∫‚ÇÅ-Function‚ÇÇ (repeatVec : V ‚Üí V ‚Üí V) := repeatVec_defined.to_definable

instance repeatVec_definable' (Œì) : Œì-[m + 1]-Function‚ÇÇ (repeatVec : V ‚Üí V ‚Üí V) := repeatVec_definable.of_sigmaOne

end

@[simp] lemma len_repeatVec (x k : V) : len (repeatVec x k) = k := by
  induction k using ISigma1.sigma1_succ_induction
  ¬∑ definability
  case zero => simp
  case succ k ih => simp [ih]

@[simp] lemma le_repaetVec (x k : V) : k ‚â§ repeatVec x k := by
  simpa using len_le (repeatVec x k)

lemma nth_repeatVec (x k : V) {i} (h : i < k) : (repeatVec x k).[i] = x := by
  induction k using ISigma1.sigma1_succ_induction generalizing i
  ¬∑ definability
  case zero => simp at h
  case succ k ih =>
    rcases zero_or_succ i with (rfl | ‚ü®i, rfl‚ü©)
    ¬∑ simp
    ¬∑ simpa using ih (by simpa using h)

lemma len_repeatVec_of_nth_le {v m : V} (H : ‚àÄ i < len v, v.[i] ‚â§ m) : v ‚â§ repeatVec m (len v) :=
  le_of_nth_le_nth (by simp) (fun i hi ‚Ü¶ by simp [nth_repeatVec m (len v) hi, H i hi])

end repaetVec

/-!

### Convert to Set

-/

namespace VecToSet

def blueprint : VecRec.Blueprint 0 where
  nil := .mkSigma ‚Äúy. y = 0‚Äù
  adjoin := .mkSigma ‚Äúy x xs ih. !insertDef y x ih‚Äù

noncomputable def adjointruction : VecRec.Construction V blueprint where
  nil _ := ‚àÖ
  adjoin (_ x _ ih) := insert x ih
  nil_defined := .mk fun v ‚Ü¶ by simp [blueprint, emptyset_def]
  adjoin_defined := .mk fun v ‚Ü¶ by simp [blueprint]

end VecToSet

section vecToSet

open VecToSet

noncomputable def vecToSet (v : V) : V := adjointruction.result ![] v

@[simp] lemma vecToSet_nil : vecToSet (0 : V) = ‚àÖ := by simp [vecToSet, adjointruction]

@[simp] lemma vecToSet_adjoin (x v : V) :
    vecToSet (x ‚à∑ v) = insert x (vecToSet v) := by simp [vecToSet, adjointruction]

section

def _root_.LO.FirstOrder.Arithmetic.vecToSetDef : ùö∫‚ÇÅ.Semisentence 2 := blueprint.resultDef

instance vecToSet_defined : ùö∫‚ÇÅ-Function‚ÇÅ (vecToSet : V ‚Üí V) via vecToSetDef := adjointruction.result_defined

instance vecToSet_definable : ùö∫‚ÇÅ-Function‚ÇÅ (vecToSet : V ‚Üí V) := vecToSet_defined.to_definable

instance vecToSet_definable' (Œì) : Œì-[m + 1]-Function‚ÇÅ (vecToSet : V ‚Üí V) := vecToSet_definable.of_sigmaOne

end

lemma mem_vecToSet_iff {v x : V} : x ‚àà vecToSet v ‚Üî ‚àÉ i < len v, x = v.[i] := by
  induction v using adjoin_ISigma1.sigma1_succ_induction
  ¬∑ definability
  case nil => simp
  case adjoin y v ih =>
    simp only [vecToSet_adjoin, mem_bitInsert_iff, ih, len_adjoin]
    constructor
    ¬∑ rintro (rfl | ‚ü®i, hi, rfl‚ü©)
      ¬∑ exact ‚ü®0, by simp‚ü©
      ¬∑ exact ‚ü®i + 1, by simp [hi]‚ü©
    ¬∑ rintro ‚ü®i, hi, rfl‚ü©
      rcases zero_or_succ i with (rfl | ‚ü®i, rfl‚ü©)
      ¬∑ simp
      ¬∑ right; exact ‚ü®i, by simpa using hi, by simp‚ü©

@[simp] lemma nth_mem_vecToSet {v i : V} (h : i < len v) : v.[i] ‚àà vecToSet v :=
  mem_vecToSet_iff.mpr ‚ü®i, h, rfl‚ü©

end vecToSet

end LO.ISigma1
