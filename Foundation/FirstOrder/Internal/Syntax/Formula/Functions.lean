import Foundation.FirstOrder.Internal.Syntax.Formula.Basic
import Foundation.FirstOrder.Internal.Syntax.Term.Functions

namespace LO.ISigma1.Metamath

open FirstOrder Arithmetic PeanoMinus IOpen ISigma0

variable {V : Type*} [ORingStruc V] [V ‚äß‚Çò* ùóúùö∫‚ÇÅ]

variable {L : Language} [L.Encodable] [L.LORDefinable]

/-! ### Negation function -/

section negation

namespace Negation

def blueprint : UformulaRec1.Blueprint where
  rel := .mkSigma ‚Äúy param k R v. !qqNRelDef y k R v‚Äù
  nrel := .mkSigma ‚Äúy param k R v. !qqRelDef y k R v‚Äù
  verum := .mkSigma ‚Äúy param. !qqFalsumDef y‚Äù
  falsum := .mkSigma ‚Äúy param. !qqVerumDef y‚Äù
  and := .mkSigma ‚Äúy param p‚ÇÅ p‚ÇÇ y‚ÇÅ y‚ÇÇ. !qqOrDef y y‚ÇÅ y‚ÇÇ‚Äù
  or := .mkSigma ‚Äúy param p‚ÇÅ p‚ÇÇ y‚ÇÅ y‚ÇÇ. !qqAndDef y y‚ÇÅ y‚ÇÇ‚Äù
  all := .mkSigma ‚Äúy param p‚ÇÅ y‚ÇÅ. !qqExDef y y‚ÇÅ‚Äù
  ex := .mkSigma ‚Äúy param p‚ÇÅ y‚ÇÅ. !qqAllDef y y‚ÇÅ‚Äù
  allChanges := .mkSigma ‚Äúparam' param. param' = 0‚Äù
  exChanges := .mkSigma ‚Äúparam' param. param' = 0‚Äù

noncomputable def construction : UformulaRec1.Construction V blueprint where
  rel {_} := fun k R v ‚Ü¶ ^nrel k R v
  nrel {_} := fun k R v ‚Ü¶ ^rel k R v
  verum {_} := ^‚ä•
  falsum {_} := ^‚ä§
  and {_} := fun _ _ y‚ÇÅ y‚ÇÇ ‚Ü¶ y‚ÇÅ ^‚ãé y‚ÇÇ
  or {_} := fun _ _ y‚ÇÅ y‚ÇÇ ‚Ü¶ y‚ÇÅ ^‚ãè y‚ÇÇ
  all {_} := fun _ y‚ÇÅ ‚Ü¶ ^‚àÉ y‚ÇÅ
  ex {_} := fun _ y‚ÇÅ ‚Ü¶ ^‚àÄ y‚ÇÅ
  allChanges := fun _ ‚Ü¶ 0
  exChanges := fun _ ‚Ü¶ 0
  rel_defined := by intro v; simp [blueprint]
  nrel_defined := by intro v; simp [blueprint]
  verum_defined := by intro v; simp [blueprint]
  falsum_defined := by intro v; simp [blueprint]
  and_defined := by intro v; simp [blueprint]
  or_defined := by intro v; simp [blueprint]
  all_defined := by intro v; simp [blueprint]
  ex_defined := by intro v; simp [blueprint]
  allChanges_defined := by intro v; simp [blueprint]
  exChanges_defined := by intro v; simp [blueprint]

end Negation

open Negation

variable (L)

noncomputable def neg (p : V) : V := construction.result L 0 p

def negGraph : ùö∫‚ÇÅ.Semisentence 2 := (blueprint.result L).rew (Rew.substs ![#0, ‚Äò0‚Äô, #1])

variable {L}

section

lemma neg.defined : ùö∫‚ÇÅ-Function‚ÇÅ neg (V := V) L via negGraph L  := fun v ‚Ü¶ by
  simpa [negGraph, Matrix.comp_vecCons', Matrix.constant_eq_singleton] using construction.result_defined ![v 0, 0, v 1]

instance neg.definable : ùö∫‚ÇÅ-Function‚ÇÅ neg (V := V) L := neg.defined.to_definable

instance neg.definable' : Œì-[m + 1]-Function‚ÇÅ neg (V := V) L := .of_sigmaOne neg.definable

end

@[simp] lemma neg_rel {k R v : V} (hR : L.IsRel k R) (hv : IsUTermVec L k v) :
    neg L (^rel k R v) = ^nrel k R v := by simp [neg, hR, hv, construction]

@[simp] lemma neg_nrel {k R v : V} (hR : L.IsRel k R) (hv : IsUTermVec L k v) :
    neg L (^nrel k R v) = ^rel k R v := by simp [neg, hR, hv, construction]

@[simp] lemma neg_verum :
    neg L (^‚ä§ : V) = ^‚ä• := by simp [neg, construction]

@[simp] lemma neg_falsum :
    neg L (^‚ä• : V) = ^‚ä§ := by simp [neg, construction]

@[simp] lemma neg_and {p q : V} (hp : IsUFormula L p) (hq : IsUFormula L q) :
    neg L (p ^‚ãè q) = neg L p ^‚ãé neg L q := by simp [neg, hp, hq, construction]

@[simp] lemma neg_or {p q : V} (hp : IsUFormula L p) (hq : IsUFormula L q) :
    neg L (p ^‚ãé q) = neg L p ^‚ãè neg L q := by simp [neg, hp, hq, construction]

@[simp] lemma neg_all {p : V} (hp : IsUFormula L p) :
    neg L (^‚àÄ p) = ^‚àÉ (neg L p) := by simp [neg, hp, construction]

@[simp] lemma neg_ex {p : V} (hp : IsUFormula L p) :
    neg L (^‚àÉ p) = ^‚àÄ (neg L p) := by simp [neg, hp, construction]

lemma neg_not_uformula {x : V} (h : ¬¨IsUFormula L x) :
    neg L x = 0 := construction.result_prop_not _ h

lemma IsUFormula.neg {p : V} : IsUFormula L p ‚Üí IsUFormula L (neg L p) := by
  apply IsUFormula.ISigma1.sigma1_succ_induction
  ¬∑ definability
  ¬∑ intro k r v hr hv; simp [hr, hv]
  ¬∑ intro k r v hr hv; simp [hr, hv]
  ¬∑ simp
  ¬∑ simp
  ¬∑ intro p q hp hq ihp ihq; simp [hp, hq, ihp, ihq]
  ¬∑ intro p q hp hq ihp ihq; simp [hp, hq, ihp, ihq]
  ¬∑ intro p hp ihp; simp [hp, ihp]
  ¬∑ intro p hp ihp; simp [hp, ihp]

@[simp] lemma IsUFormula.bv_neg {p : V} : IsUFormula L p ‚Üí bv L (Metamath.neg L p) = bv L p := by
  apply IsUFormula.ISigma1.sigma1_succ_induction
  ¬∑ definability
  ¬∑ intro k R v hR hv; simp [*]
  ¬∑ intro k R v hR hv; simp [*]
  ¬∑ simp
  ¬∑ simp
  ¬∑ intro p q hp hq ihp ihq; simp [hp, hq, hp.neg, hq.neg, ihp, ihq]
  ¬∑ intro p q hp hq ihp ihq; simp [hp, hq, hp.neg, hq.neg, ihp, ihq]
  ¬∑ intro p hp ihp; simp [hp, hp.neg, ihp]
  ¬∑ intro p hp ihp; simp [hp, hp.neg, ihp]

@[simp] lemma IsUFormula.neg_neg {p : V} : IsUFormula L p ‚Üí Metamath.neg L (Metamath.neg L p) = p := by
  apply IsUFormula.ISigma1.sigma1_succ_induction
  ¬∑ definability
  ¬∑ intro k r v hr hv; simp [hr, hv]
  ¬∑ intro k r v hr hv; simp [hr, hv]
  ¬∑ simp
  ¬∑ simp
  ¬∑ intro p q hp hq ihp ihq; simp [hp, hq, hp.neg, hq.neg, ihp, ihq]
  ¬∑ intro p q hp hq ihp ihq; simp [hp, hq, hp.neg, hq.neg, ihp, ihq]
  ¬∑ intro p hp ihp; simp [hp, hp.neg, ihp]
  ¬∑ intro p hp ihp; simp [hp, hp.neg, ihp]

@[simp] lemma IsUFormula.neg_iff {p : V} : IsUFormula L (Metamath.neg L p) ‚Üî IsUFormula L p := by
  constructor
  ¬∑ intro h; by_contra hp
    have Hp : IsUFormula L p := by by_contra hp; simp [neg_not_uformula hp] at h
    contradiction
  ¬∑ exact IsUFormula.neg

@[simp] lemma IsSemiformula.neg_iff {p : V} : IsSemiformula L n (neg L p) ‚Üî IsSemiformula L n p := by
  constructor
  ¬∑ intro h; by_contra hp
    have Hp : IsUFormula L p := by by_contra hp; simp [neg_not_uformula hp] at h
    have : IsSemiformula L n p := ‚ü®Hp, by simpa [Hp.bv_neg] using h.bv_le‚ü©
    contradiction
  ¬∑ intro h; exact ‚ü®by simp [h.isUFormula], by simpa [h.isUFormula] using h.bv_le‚ü©

alias ‚ü®IsSemiformula.elim_neg, IsSemiformula.neg‚ü© := IsSemiformula.neg_iff

@[simp] lemma neg_inj_iff {p q : V} (hp : IsUFormula L p) (hq : IsUFormula L q) : neg L p = neg L q ‚Üî p = q := by
  constructor
  ¬∑ intro h; simpa [hp.neg_neg, hq.neg_neg] using congrArg (neg L) h
  ¬∑ rintro rfl; rfl

end negation

variable (L)

noncomputable def imp (p q : V) : V := neg L p ^‚ãé q

notation:60 p:61 " ^‚Üí[" L "] " q:60 => Language.imp L p q

def impGraph : ùö∫‚ÇÅ.Semisentence 3 := .mkSigma ‚Äúr p q. ‚àÉ np, !(negGraph L) np p ‚àß !qqOrDef r np q‚Äù

noncomputable def iff (p q : V) : V := (imp L p q) ^‚ãè (imp L q p)

def iffGraph : ùö∫‚ÇÅ.Semisentence 3 := .mkSigma
  ‚Äúr p q. ‚àÉ pq, !(impGraph L) pq p q ‚àß ‚àÉ qp, !(impGraph L) qp q p ‚àß !qqAndDef r pq qp‚Äù

variable {L}

section imp

@[simp] lemma IsUFormula.imp {p q : V} :
    IsUFormula L (imp L p q) ‚Üî IsUFormula L p ‚àß IsUFormula L q := by
  simp [Metamath.imp]

@[simp] lemma IsSemiformula.imp {n p q : V} :
    IsSemiformula L n (imp L p q) ‚Üî IsSemiformula L n p ‚àß IsSemiformula L n q := by
  simp [Metamath.imp]

section

lemma imp.defined : ùö∫‚ÇÅ-Function‚ÇÇ imp (V := V) L via impGraph L := fun v ‚Ü¶ by
  simp [impGraph, neg.defined.df.iff]; rfl

instance imp.definable : ùö∫‚ÇÅ-Function‚ÇÇ imp (V := V) L := imp.defined.to_definable

instance imp.definable' : Œì-[m + 1]-Function‚ÇÇ imp (V := V) L := imp.definable.of_sigmaOne

end

end imp

section iff

@[simp] lemma IsUFormula.iff {p q : V} :
    IsUFormula L (iff L p q) ‚Üî IsUFormula L p ‚àß IsUFormula L q := by
  simp only [Metamath.iff, and, imp, and_iff_left_iff_imp, and_imp]
  intros; simp_all

@[simp] lemma IsSemiformula.iff {n p q : V} :
    IsSemiformula L n (iff L p q) ‚Üî IsSemiformula L n p ‚àß IsSemiformula L n q := by
  simp only [Metamath.iff, and, imp, and_iff_left_iff_imp, and_imp]
  intros; simp_all

@[simp] lemma lt_iff_left (p q : V) : p < iff L p q := lt_trans (lt_or_right _ _) (lt_K!_right _ _)

@[simp] lemma lt_iff_right (p q : V) : q < iff L p q := lt_trans (lt_or_right _ _) (lt_K!_left _ _)

section

lemma iff.defined : ùö∫‚ÇÅ-Function‚ÇÇ iff (V := V) L via iffGraph L := fun v ‚Ü¶ by
  simp [iffGraph, imp.defined.df.iff]; rfl

instance iff.definable : ùö∫‚ÇÅ-Function‚ÇÇ iff (V := V) L := iff.defined.to_definable

instance iff_definable' : Œì-[m + 1]-Function‚ÇÇ iff (V := V) L := iff.definable.of_sigmaOne

end

end iff

/-! ### Shift function -/

section shift

namespace Shift

variable (L)

def blueprint : UformulaRec1.Blueprint where
  rel := .mkSigma ‚Äúy param k R v. ‚àÉ v', !(termShiftVecGraph L) v' k v ‚àß !qqRelDef y k R v'‚Äù
  nrel := .mkSigma ‚Äúy param k R v. ‚àÉ v', !(termShiftVecGraph L) v' k v ‚àß !qqNRelDef y k R v'‚Äù
  verum := .mkSigma ‚Äúy param. !qqVerumDef y‚Äù
  falsum := .mkSigma ‚Äúy param. !qqFalsumDef y‚Äù
  and := .mkSigma ‚Äúy param p‚ÇÅ p‚ÇÇ y‚ÇÅ y‚ÇÇ. !qqAndDef y y‚ÇÅ y‚ÇÇ‚Äù
  or := .mkSigma ‚Äúy param p‚ÇÅ p‚ÇÇ y‚ÇÅ y‚ÇÇ. !qqOrDef y y‚ÇÅ y‚ÇÇ‚Äù
  all := .mkSigma ‚Äúy param p‚ÇÅ y‚ÇÅ. !qqAllDef y y‚ÇÅ‚Äù
  ex := .mkSigma ‚Äúy param p‚ÇÅ y‚ÇÅ. !qqExDef y y‚ÇÅ‚Äù
  allChanges := .mkSigma ‚Äúparam' param. param' = 0‚Äù
  exChanges := .mkSigma ‚Äúparam' param. param' = 0‚Äù

noncomputable def construction : UformulaRec1.Construction V (blueprint L) where
  rel {_} := fun k R v ‚Ü¶ ^rel k R (termShiftVec L k v)
  nrel {_} := fun k R v ‚Ü¶ ^nrel k R (termShiftVec L k v)
  verum {_} := ^‚ä§
  falsum {_} := ^‚ä•
  and {_} := fun _ _ y‚ÇÅ y‚ÇÇ ‚Ü¶ y‚ÇÅ ^‚ãè y‚ÇÇ
  or {_} := fun _ _ y‚ÇÅ y‚ÇÇ ‚Ü¶ y‚ÇÅ ^‚ãé y‚ÇÇ
  all {_} := fun _ y‚ÇÅ ‚Ü¶ ^‚àÄ y‚ÇÅ
  ex {_} := fun _ y‚ÇÅ ‚Ü¶ ^‚àÉ y‚ÇÅ
  allChanges := fun _ ‚Ü¶ 0
  exChanges := fun _ ‚Ü¶ 0
  rel_defined := by intro v; simp [blueprint, termShiftVec.defined.df.iff]
  nrel_defined := by intro v; simp [blueprint, termShiftVec.defined.df.iff]
  verum_defined := by intro v; simp [blueprint]
  falsum_defined := by intro v; simp [blueprint]
  and_defined := by intro v; simp [blueprint]
  or_defined := by intro v; simp [blueprint]
  all_defined := by intro v; simp [blueprint]
  ex_defined := by intro v; simp [blueprint]
  allChanges_defined := by intro v; simp [blueprint]
  exChanges_defined := by intro v; simp [blueprint]

end Shift

open Shift

variable (L)

noncomputable def shift (p : V) : V := (construction L).result L 0 p

def shiftGraph : ùö∫‚ÇÅ.Semisentence 2 := blueprint L |>.result L |>.rew (Rew.substs ![#0, ‚Äò0‚Äô, #1])

variable {L}

section

lemma shift.defined : ùö∫‚ÇÅ-Function‚ÇÅ[V] shift L via shiftGraph L := fun v ‚Ü¶ by
  simpa [shiftGraph, Matrix.comp_vecCons', Matrix.constant_eq_singleton] using (construction L).result_defined ![v 0, 0, v 1]

instance shift.definable : ùö∫‚ÇÅ-Function‚ÇÅ[V] shift L := shift.defined.to_definable

instance shift.definable' : Œì-[m + 1]-Function‚ÇÅ[V] shift L := shift.definable.of_sigmaOne

end

@[simp] lemma shift_rel {k R v : V} (hR : L.IsRel k R) (hv : IsUTermVec L k v) :
    shift L (^relk R v) = ^relk R (termShiftVec L k v) := by simp [shift, hR, hv, construction]

@[simp] lemma shift_nrel {k R v : V} (hR : L.IsRel k R) (hv : IsUTermVec L k v) :
    shift L (^nrelk R v) = ^nrelk R (termShiftVec L k v) := by simp [shift, hR, hv, construction]

@[simp] lemma shift_verum : shift L (^‚ä§ : V) = ^‚ä§ := by simp [shift, construction]

@[simp] lemma shift_falsum : shift L (^‚ä• : V) = ^‚ä• := by simp [shift, construction]

@[simp] lemma shift_and {p q : V} (hp : IsUFormula L p) (hq : IsUFormula L q) :
    shift L (p ^‚ãè q) = shift L p ^‚ãè shift L q := by simp [shift, hp, hq, construction]

@[simp] lemma shift_or {p q : V} (hp : IsUFormula L p) (hq : IsUFormula L q) :
    shift L (p ^‚ãé q) = shift L p ^‚ãé shift L q := by simp [shift, hp, hq, construction]

@[simp] lemma shift_all {p : V} (hp : IsUFormula L p) :
    shift L (^‚àÄ p) = ^‚àÄ (shift L p) := by simp [shift, hp, construction]

@[simp] lemma shift_ex {p : V} (hp : IsUFormula L p) :
    shift L (^‚àÉ p) = ^‚àÉ (shift L p) := by simp [shift, hp, construction]

lemma shift_not_uformula {x : V} (h : ¬¨IsUFormula L x) :
    shift L x = 0 := (construction L).result_prop_not _ h

lemma IsUFormula.shift {p : V} : IsUFormula L p ‚Üí IsUFormula L (shift L p) := by
  apply IsUFormula.ISigma1.sigma1_succ_induction
  ¬∑ definability
  ¬∑ intro k r v hr hv; simp [hr, hv]
  ¬∑ intro k r v hr hv; simp [hr, hv]
  ¬∑ simp
  ¬∑ simp
  ¬∑ intro p q hp hq ihp ihq; simp [hp, hq, ihp, ihq]
  ¬∑ intro p q hp hq ihp ihq; simp [hp, hq, ihp, ihq]
  ¬∑ intro p hp ihp; simp [hp, ihp]
  ¬∑ intro p hp ihp; simp [hp, ihp]

lemma IsUFormula.bv_shift {p : V} : IsUFormula L p ‚Üí bv L (Metamath.shift L p) = bv L p := by
  apply IsUFormula.ISigma1.sigma1_succ_induction
  ¬∑ definability
  ¬∑ intro k r v hr hv; simp [hr, hv]
  ¬∑ intro k r v hr hv; simp [hr, hv]
  ¬∑ simp
  ¬∑ simp
  ¬∑ intro p q hp hq ihp ihq; simp [hp, hq, ihp, ihq, hp.shift, hq.shift]
  ¬∑ intro p q hp hq ihp ihq; simp [hp, hq, ihp, ihq, hp.shift, hq.shift]
  ¬∑ intro p hp ihp; simp [hp, ihp, hp.shift]
  ¬∑ intro p hp ihp; simp [hp, ihp, hp.shift]

lemma IsSemiformula.shift {p : V} : IsSemiformula L n p ‚Üí IsSemiformula L n (shift L p) := by
  apply IsSemiformula.sigma1_structural_induction
  ¬∑ definability
  ¬∑ intro n k r v hr hv; simp [hr, hv, hv.isUTerm]
  ¬∑ intro n k r v hr hv; simp [hr, hv, hv.isUTerm]
  ¬∑ simp
  ¬∑ simp
  ¬∑ intro n p q hp hq ihp ihq; simp [hp.isUFormula, hq.isUFormula, ihp, ihq]
  ¬∑ intro n p q hp hq ihp ihq; simp [hp.isUFormula, hq.isUFormula, ihp, ihq]
  ¬∑ intro n p hp ihp; simp [hp.isUFormula, ihp]
  ¬∑ intro n p hp ihp; simp [hp.isUFormula, ihp]

@[simp] lemma IsUFormula.shift_iff {p : V} : IsUFormula L (Metamath.shift L p) ‚Üî IsUFormula L p := by
  constructor
  ¬∑ intro h; by_contra hp
    have Hp : IsUFormula L p := by by_contra hp; simp [shift_not_uformula hp] at h
    contradiction
  ¬∑ exact IsUFormula.shift

@[simp] lemma IsSemiformula.shift_iff {p : V} : IsSemiformula L n (Metamath.shift L p) ‚Üî IsSemiformula L n p :=
  ‚ü®fun h ‚Ü¶ by
    have : IsUFormula L p := by by_contra hp; simp [shift_not_uformula hp] at h
    exact ‚ü®this, by simpa [this.bv_shift] using h.bv_le‚ü©,
    IsSemiformula.shift‚ü©

lemma shift_neg {p : V} (hp : IsSemiformula L n p) : shift L (neg L p) = neg L (shift L p) := by
  apply IsSemiformula.sigma1_structural_induction ?_ ?_ ?_ ?_ ?_ ?_ ?_ ?_ ?_ hp
  ¬∑ definability
  ¬∑ intro n k R v hR hv; simp [hR, hv.isUTerm, hv.termShiftVec.isUTerm]
  ¬∑ intro n k R v hR hv; simp [hR, hv.isUTerm, hv.termShiftVec.isUTerm]
  ¬∑ simp
  ¬∑ simp
  ¬∑ intro n p q hp hq ihp ihq; simp [hp.isUFormula, hq.isUFormula, hp.shift.isUFormula, hq.shift.isUFormula, ihp, ihq]
  ¬∑ intro n p q hp hq ihp ihq; simp [hp.isUFormula, hq.isUFormula, hp.shift.isUFormula, hq.shift.isUFormula, ihp, ihq]
  ¬∑ intro n p hp ih; simp [hp.isUFormula, hp.shift.isUFormula, ih]
  ¬∑ intro n p hp ih; simp [hp.isUFormula, hp.shift.isUFormula, ih]

end shift

/-! ### Substitution function -/

section substs

namespace Substs

variable (L)

def blueprint : UformulaRec1.Blueprint where
  rel    := .mkSigma ‚Äúy param k R v. ‚àÉ v', !(termSubstVecGraph L) v' k param v ‚àß !qqRelDef y k R v'‚Äù
  nrel   := .mkSigma ‚Äúy param k R v. ‚àÉ v', !(termSubstVecGraph L) v' k param v ‚àß !qqNRelDef y k R v'‚Äù
  verum  := .mkSigma ‚Äúy param. !qqVerumDef y‚Äù
  falsum := .mkSigma ‚Äúy param. !qqFalsumDef y‚Äù
  and    := .mkSigma ‚Äúy param p‚ÇÅ p‚ÇÇ y‚ÇÅ y‚ÇÇ. !qqAndDef y y‚ÇÅ y‚ÇÇ‚Äù
  or     := .mkSigma ‚Äúy param p‚ÇÅ p‚ÇÇ y‚ÇÅ y‚ÇÇ. !qqOrDef y y‚ÇÅ y‚ÇÇ‚Äù
  all    := .mkSigma ‚Äúy param p‚ÇÅ y‚ÇÅ. !qqAllDef y y‚ÇÅ‚Äù
  ex     := .mkSigma ‚Äúy param p‚ÇÅ y‚ÇÅ. !qqExDef y y‚ÇÅ‚Äù
  allChanges := .mkSigma ‚Äúparam' param. !(qVecGraph L) param' param‚Äù
  exChanges  := .mkSigma ‚Äúparam' param. !(qVecGraph L) param' param‚Äù

noncomputable def construction : UformulaRec1.Construction V (blueprint L) where
  rel (param)  := fun k R v ‚Ü¶ ^rel k R (termSubstVec L k param v)
  nrel (param) := fun k R v ‚Ü¶ ^nrel k R (termSubstVec L k param v)
  verum _      := ^‚ä§
  falsum _     := ^‚ä•
  and _        := fun _ _ y‚ÇÅ y‚ÇÇ ‚Ü¶ y‚ÇÅ ^‚ãè y‚ÇÇ
  or _         := fun _ _ y‚ÇÅ y‚ÇÇ ‚Ü¶ y‚ÇÅ ^‚ãé y‚ÇÇ
  all _        := fun _ y‚ÇÅ ‚Ü¶ ^‚àÄ y‚ÇÅ
  ex _         := fun _ y‚ÇÅ ‚Ü¶ ^‚àÉ y‚ÇÅ
  allChanges (param) := qVec L param
  exChanges (param) := qVec L param
  rel_defined := by intro v; simp [blueprint, termSubstVec.defined.df.iff]
  nrel_defined := by intro v; simp [blueprint, termSubstVec.defined.df.iff]
  verum_defined := by intro v; simp [blueprint]
  falsum_defined := by intro v; simp [blueprint]
  and_defined := by intro v; simp [blueprint]
  or_defined := by intro v; simp [blueprint]
  all_defined := by intro v; simp [blueprint]
  ex_defined := by intro v; simp [blueprint]
  allChanges_defined := by intro v; simp [blueprint, qVec.defined.df.iff]
  exChanges_defined := by intro v; simp [blueprint, qVec.defined.df.iff]

end Substs

open Substs

variable (L)

noncomputable def substs (w p : V) : V := (construction L).result L w p

def substsGraph : ùö∫‚ÇÅ.Semisentence 3 := (blueprint L).result L

variable {L}

section

lemma substs.defined : ùö∫‚ÇÅ-Function‚ÇÇ[V] substs L via substsGraph L := (construction L).result_defined

instance substs.definable : ùö∫‚ÇÅ-Function‚ÇÇ[V] substs L := substs.defined.to_definable

instance substs.definable' : Œì-[m + 1]-Function‚ÇÇ[V] substs L := substs.definable.of_sigmaOne

end

variable {m w : V}

@[simp] lemma substs_rel {k R v : V} (hR : L.IsRel k R) (hv : IsUTermVec L k v) :
    substs L w (^relk R v) = ^rel k R (termSubstVec L k w v) := by simp [substs, hR, hv, construction]

@[simp] lemma substs_nrel {k R v : V} (hR : L.IsRel k R) (hv : IsUTermVec L k v) :
    substs L w (^nrelk R v) = ^nrel k R (termSubstVec L k w v) := by simp [substs, hR, hv, construction]

@[simp] lemma substs_verum (w : V) : substs L w ^‚ä§ = ^‚ä§ := by simp [substs, construction]

@[simp] lemma substs_falsum (w : V) : substs L w ^‚ä• = ^‚ä• := by simp [substs, construction]

@[simp] lemma substs_and {p q : V} (hp : IsUFormula L p) (hq : IsUFormula L q) :
    substs L w (p ^‚ãè q) = substs L w p ^‚ãè substs L w q := by simp [substs, hp, hq, construction]

@[simp] lemma substs_or {p q : V} (hp : IsUFormula L p) (hq : IsUFormula L q) :
    substs L w (p ^‚ãé q) = substs L w p ^‚ãé substs L w q := by simp [substs, hp, hq, construction]

@[simp] lemma substs_all {p} (hp : IsUFormula L p) :
    substs L w (^‚àÄ p) = ^‚àÄ (substs L (qVec L w) p) := by simp [substs, hp, construction]

@[simp] lemma substs_ex {p} (hp : IsUFormula L p) :
    substs L w (^‚àÉ p) = ^‚àÉ (substs L (qVec L w) p) := by simp [substs, hp, construction]

lemma isUFormula_subst_ISigma1.sigma1_succ_induction {P : V ‚Üí V ‚Üí V ‚Üí Prop} (hP : ùö∫‚ÇÅ-Relation‚ÇÉ P)
    (hRel : ‚àÄ w k R v, L.IsRel k R ‚Üí IsUTermVec L k v ‚Üí P w (^relk R v) (^rel k R (termSubstVec L k w v)))
    (hNRel : ‚àÄ w k R v, L.IsRel k R ‚Üí IsUTermVec L k v ‚Üí P w (^nrelk R v) (^nrel k R (termSubstVec L k w v)))
    (hverum : ‚àÄ w, P w ^‚ä§ ^‚ä§)
    (hfalsum : ‚àÄ w, P w ^‚ä• ^‚ä•)
    (hand : ‚àÄ w p q, IsUFormula L p ‚Üí IsUFormula L q ‚Üí
      P w p (substs L w p) ‚Üí P w q (substs L w q) ‚Üí P w (p ^‚ãè q) (substs L w p ^‚ãè substs L w q))
    (hor : ‚àÄ w p q, IsUFormula L p ‚Üí IsUFormula L q ‚Üí
      P w p (substs L w p) ‚Üí P w q (substs L w q) ‚Üí P w (p ^‚ãé q) (substs L w p ^‚ãé substs L w q))
    (hall : ‚àÄ w p, IsUFormula L p ‚Üí P (qVec L w) p (substs L (qVec L w) p) ‚Üí P w (^‚àÄ p) (^‚àÄ (substs L (qVec L w) p)))
    (hex : ‚àÄ w p, IsUFormula L p ‚Üí P (qVec L w) p (substs L (qVec L w) p) ‚Üí P w (^‚àÉ p) (^‚àÉ (substs L (qVec L w) p))) :
    ‚àÄ {w p}, IsUFormula L p ‚Üí P w p (substs L w p) := by
  suffices ‚àÄ param p, IsUFormula L p ‚Üí P param p ((construction L).result L param p) by
    intro w p hp; simpa using this w p hp
  apply (construction L).uformula_result_induction (P := fun param p y ‚Ü¶ P param p y)
  ¬∑ definability
  ¬∑ intro param k R v hkR hv; simpa using hRel param k R v hkR hv
  ¬∑ intro param k R v hkR hv; simpa using hNRel param k R v hkR hv
  ¬∑ intro param; simpa using hverum param
  ¬∑ intro param; simpa using hfalsum param
  ¬∑ intro param p q hp hq ihp ihq
    simpa [substs] using
      hand param p q hp hq (by simpa [substs] using ihp) (by simpa [substs] using ihq)
  ¬∑ intro param p q hp hq ihp ihq
    simpa [substs] using
      hor param p q hp hq (by simpa [substs] using ihp) (by simpa [substs] using ihq)
  ¬∑ intro param p hp ihp
    simpa using hall param p hp (by simpa [construction] using ihp)
  ¬∑ intro param p hp ihp
    simpa using hex param p hp (by simpa [construction] using ihp)

lemma semiformula_subst_induction {P : V ‚Üí V ‚Üí V ‚Üí V ‚Üí Prop} (hP : ùö∫‚ÇÅ-Relation‚ÇÑ P)
    (hRel : ‚àÄ n w k R v, L.IsRel k R ‚Üí IsSemitermVec L k n v ‚Üí P n w (^relk R v) (^rel k R (termSubstVec L k w v)))
    (hNRel : ‚àÄ n w k R v, L.IsRel k R ‚Üí IsSemitermVec L k n v ‚Üí P n w (^nrelk R v) (^nrel k R (termSubstVec L k w v)))
    (hverum : ‚àÄ n w, P n w ^‚ä§ ^‚ä§)
    (hfalsum : ‚àÄ n w, P n w ^‚ä• ^‚ä•)
    (hand : ‚àÄ n w p q, IsSemiformula L n p ‚Üí IsSemiformula L n q ‚Üí
      P n w p (substs L w p) ‚Üí P n w q (substs L w q) ‚Üí P n w (p ^‚ãè q) (substs L w p ^‚ãè substs L w q))
    (hor : ‚àÄ n w p q, IsSemiformula L n p ‚Üí IsSemiformula L n q ‚Üí
      P n w p (substs L w p) ‚Üí P n w q (substs L w q) ‚Üí P n w (p ^‚ãé q) (substs L w p ^‚ãé substs L w q))
    (hall : ‚àÄ n w p, IsSemiformula L (n + 1) p ‚Üí
      P (n + 1) (qVec L w) p (substs L (qVec L w) p) ‚Üí P n w (^‚àÄ p) (^‚àÄ (substs L (qVec L w) p)))
    (hex : ‚àÄ n w p, IsSemiformula L (n + 1) p ‚Üí
      P (n + 1) (qVec L w) p (substs L (qVec L w) p) ‚Üí P n w (^‚àÉ p) (^‚àÉ (substs L (qVec L w) p))) :
    ‚àÄ {n p w}, IsSemiformula L n p ‚Üí P n w p (substs L w p) := by
  suffices ‚àÄ param n p, IsSemiformula L n p ‚Üí P n param p ((construction L).result L param p) by
    intro n p w hp; simpa using this w n p hp
  apply (construction L).semiformula_result_induction (P := fun param n p y ‚Ü¶ P n param p y)
  ¬∑ definability
  ¬∑ intro n param k R v hkR hv; simpa using hRel n param k R v hkR hv
  ¬∑ intro n param k R v hkR hv; simpa using hNRel n param k R v hkR hv
  ¬∑ intro n param; simpa using hverum n param
  ¬∑ intro n param; simpa using hfalsum n param
  ¬∑ intro n param p q hp hq ihp ihq
    simpa [substs] using
      hand n param p q hp hq (by simpa [substs] using ihp) (by simpa [substs] using ihq)
  ¬∑ intro n param p q hp hq ihp ihq
    simpa [substs] using
      hor n param p q hp hq (by simpa [substs] using ihp) (by simpa [substs] using ihq)
  ¬∑ intro n param p hp ihp
    simpa using hall n param p hp (by simpa [construction] using ihp)
  ¬∑ intro n param p hp ihp
    simpa using hex n param p hp (by simpa [construction] using ihp)

@[simp] lemma IsSemiformula.substs {n p m w : V} :
    IsSemiformula L n p ‚Üí IsSemitermVec L n m w ‚Üí IsSemiformula L m (substs L w p) := by
  let fw : V ‚Üí V ‚Üí V ‚Üí V ‚Üí V := fun _ w _ _ ‚Ü¶ Max.max w (qVec L w)
  have hfw : ùö∫‚ÇÅ-Function‚ÇÑ fw := by definability
  let fn : V ‚Üí V ‚Üí V ‚Üí V ‚Üí V := fun _ _ n _ ‚Ü¶ n + 1
  have hfn : ùö∫‚ÇÅ-Function‚ÇÑ fn := by definability
  let fm : V ‚Üí V ‚Üí V ‚Üí V ‚Üí V := fun _ _ _ m ‚Ü¶ m + 1
  have hfm : ùö∫‚ÇÅ-Function‚ÇÑ fm := by definability
  apply bounded_all_sigma1_order_induction‚ÇÉ hfw hfn hfm ?_ ?_ p w n m
  ¬∑ definability
  intro p w n m ih hp hw
  rcases IsSemiformula.case_iff.mp hp with
    (‚ü®k, R, v, hR, hv, rfl‚ü© | ‚ü®k, R, v, hR, hv, rfl‚ü© | rfl | rfl | ‚ü®p‚ÇÅ, p‚ÇÇ, h‚ÇÅ, h‚ÇÇ, rfl‚ü© | ‚ü®p‚ÇÅ, p‚ÇÇ, h‚ÇÅ, h‚ÇÇ, rfl‚ü© | ‚ü®p‚ÇÅ, h‚ÇÅ, rfl‚ü© | ‚ü®p‚ÇÅ, h‚ÇÅ, rfl‚ü©)
  ¬∑ simp [hR, hv.isUTerm, hw.termSubstVec hv]
  ¬∑ simp [hR, hv.isUTerm, hw.termSubstVec hv]
  ¬∑ simp
  ¬∑ simp
  ¬∑ have ih‚ÇÅ : IsSemiformula L m (Metamath.substs L w p‚ÇÅ) := ih p‚ÇÅ (by simp) w (by simp [fw]) n (by simp [fn]) m (by simp [fm]) h‚ÇÅ hw
    have ih‚ÇÇ : IsSemiformula L m (Metamath.substs L w p‚ÇÇ) := ih p‚ÇÇ (by simp) w (by simp [fw]) n (by simp [fn]) m (by simp [fm]) h‚ÇÇ hw
    simp [h‚ÇÅ.isUFormula, h‚ÇÇ.isUFormula, ih‚ÇÅ, ih‚ÇÇ]
  ¬∑ have ih‚ÇÅ : IsSemiformula L m (Metamath.substs L w p‚ÇÅ) := ih p‚ÇÅ (by simp) w (by simp [fw]) n (by simp [fn]) m (by simp [fm]) h‚ÇÅ hw
    have ih‚ÇÇ : IsSemiformula L m (Metamath.substs L w p‚ÇÇ) := ih p‚ÇÇ (by simp) w (by simp [fw]) n (by simp [fn]) m (by simp [fm]) h‚ÇÇ hw
    simp [h‚ÇÅ.isUFormula, h‚ÇÇ.isUFormula, ih‚ÇÅ, ih‚ÇÇ]
  ¬∑ simpa [h‚ÇÅ.isUFormula] using ih p‚ÇÅ (by simp) (qVec L w) (by simp [fw]) (n + 1) (by simp [fn]) (m + 1) (by simp [fm]) h‚ÇÅ hw.qVec
  ¬∑ simpa [h‚ÇÅ.isUFormula] using ih p‚ÇÅ (by simp) (qVec L w) (by simp [fw]) (n + 1) (by simp [fn]) (m + 1) (by simp [fm]) h‚ÇÅ hw.qVec

lemma substs_not_uformula {w x : V} (h : ¬¨IsUFormula L x) :
    substs L w x = 0 := (construction L).result_prop_not _ h

lemma substs_neg {p} (hp : IsSemiformula L n p) :
    IsSemitermVec L n m w ‚Üí substs L w (neg L p) = neg L (substs L w p) := by
  revert m w
  apply IsSemiformula.pi1_structural_induction ?_ ?_ ?_ ?_ ?_ ?_ ?_ ?_ ?_ hp
  ¬∑ definability
  ¬∑ intros n k R v hR hv m w hw
    rw [neg_rel hR hv.isUTerm, substs_nrel hR hv.isUTerm, substs_rel hR hv.isUTerm, neg_rel hR (hw.termSubstVec hv).isUTerm]
  ¬∑ intros n k R v hR hv m w hw
    rw [neg_nrel hR hv.isUTerm, substs_rel hR hv.isUTerm, substs_nrel hR hv.isUTerm, neg_nrel hR (hw.termSubstVec hv).isUTerm]
  ¬∑ intros; simp [*]
  ¬∑ intros; simp [*]
  ¬∑ intro n p q hp hq ihp ihq m w hw
    rw [neg_and hp.isUFormula hq.isUFormula,
      substs_or hp.neg.isUFormula hq.neg.isUFormula,
      substs_and hp.isUFormula hq.isUFormula,
      neg_and (hp.substs hw).isUFormula (hq.substs hw).isUFormula,
      ihp hw, ihq hw]
  ¬∑ intro n p q hp hq ihp ihq m w hw
    rw [neg_or hp.isUFormula hq.isUFormula,
      substs_and hp.neg.isUFormula hq.neg.isUFormula,
      substs_or hp.isUFormula hq.isUFormula,
      neg_or (hp.substs hw).isUFormula (hq.substs hw).isUFormula,
      ihp hw, ihq hw]
  ¬∑ intro n p hp ih m w hw
    rw [neg_all hp.isUFormula, substs_ex hp.neg.isUFormula,
      substs_all hp.isUFormula, neg_all (hp.substs hw.qVec).isUFormula, ih hw.qVec]
  ¬∑ intro n p hp ih m w hw
    rw [neg_ex hp.isUFormula, substs_all hp.neg.isUFormula,
      substs_ex hp.isUFormula, neg_ex (hp.substs hw.qVec).isUFormula, ih hw.qVec]

lemma shift_substs {p} (hp : IsSemiformula L n p) :
    IsSemitermVec L n m w ‚Üí shift L (substs L w p) = substs L (termShiftVec L n w) (shift L p) := by
  revert m w
  apply IsSemiformula.pi1_structural_induction ?_ ?_ ?_ ?_ ?_ ?_ ?_ ?_ ?_ hp
  ¬∑ definability
  ¬∑ intro n k R v hR hv m w hw
    rw [substs_rel hR hv.isUTerm,
      shift_rel hR (hw.termSubstVec hv).isUTerm,
      shift_rel hR hv.isUTerm,
      substs_rel hR hv.termShiftVec.isUTerm]
    simp only [qqRel_inj, true_and]
    apply nth_ext' k
      (by rw [len_termShiftVec (hw.termSubstVec hv).isUTerm])
      (by rw [len_termSubstVec hv.termShiftVec.isUTerm])
    intro i hi
    rw [nth_termShiftVec (hw.termSubstVec hv).isUTerm hi,
      nth_termSubstVec hv.isUTerm hi,
      nth_termSubstVec hv.termShiftVec.isUTerm hi,
      nth_termShiftVec hv.isUTerm hi,
      termShift_termSubsts (hv.nth hi) hw]
  ¬∑ intro n k R v hR hv m w hw
    rw [substs_nrel hR hv.isUTerm,
      shift_nrel hR (hw.termSubstVec hv).isUTerm,
      shift_nrel hR hv.isUTerm,
      substs_nrel hR hv.termShiftVec.isUTerm]
    simp only [qqNRel_inj, true_and]
    apply nth_ext' k
      (by rw [len_termShiftVec (hw.termSubstVec hv).isUTerm])
      (by rw [len_termSubstVec hv.termShiftVec.isUTerm])
    intro i hi
    rw [nth_termShiftVec (hw.termSubstVec hv).isUTerm hi,
      nth_termSubstVec hv.isUTerm hi,
      nth_termSubstVec hv.termShiftVec.isUTerm hi,
      nth_termShiftVec hv.isUTerm hi,
      termShift_termSubsts (hv.nth hi) hw]
  ¬∑ intro n w hw; simp
  ¬∑ intro n w hw; simp
  ¬∑ intro n p q hp hq ihp ihq m w hw
    rw [substs_and hp.isUFormula hq.isUFormula,
      shift_and (hp.substs hw).isUFormula (hq.substs hw).isUFormula,
      shift_and hp.isUFormula hq.isUFormula,
      substs_and hp.shift.isUFormula hq.shift.isUFormula,
      ihp hw, ihq hw]
  ¬∑ intro n p q hp hq ihp ihq m w hw
    rw [substs_or hp.isUFormula hq.isUFormula,
      shift_or (hp.substs hw).isUFormula (hq.substs hw).isUFormula,
      shift_or hp.isUFormula hq.isUFormula,
      substs_or hp.shift.isUFormula hq.shift.isUFormula,
      ihp hw, ihq hw]
  ¬∑ intro n p hp ih m w hw
    rw [substs_all hp.isUFormula,
      shift_all (hp.substs hw.qVec).isUFormula,
      shift_all hp.isUFormula,
      substs_all hp.shift.isUFormula,
      ih hw.qVec,
      termShift_qVec hw]
  ¬∑ intro n p hp ih m w hw
    rw [substs_ex hp.isUFormula,
      shift_ex (hp.substs hw.qVec).isUFormula,
      shift_ex hp.isUFormula,
      substs_ex hp.shift.isUFormula,
      ih hw.qVec,
      termShift_qVec hw]

lemma substs_substs {p} (hp : IsSemiformula L l p) :
    IsSemitermVec L n m w ‚Üí IsSemitermVec L l n v ‚Üí substs L w (substs L v p) = substs L (termSubstVec L l w v) p := by
  revert m w n v
  apply IsSemiformula.pi1_structural_induction ?_ ?_ ?_ ?_ ?_ ?_ ?_ ?_ ?_ hp
  ¬∑ definability
  ¬∑ intro l k R ts hR hts m w n v _ hv
    rw [substs_rel hR hts.isUTerm,
      substs_rel hR (hv.termSubstVec hts).isUTerm,
      substs_rel hR hts.isUTerm]
    simp only [qqRel_inj, true_and]
    apply nth_ext' k (by rw [len_termSubstVec (hv.termSubstVec hts).isUTerm]) (by rw [len_termSubstVec hts.isUTerm])
    intro i hi
    rw [nth_termSubstVec (hv.termSubstVec hts).isUTerm hi,
      nth_termSubstVec hts.isUTerm hi,
      nth_termSubstVec hts.isUTerm hi,
      termSubst_termSubst hv (hts.nth hi)]
  ¬∑ intro l k R ts hR hts m w n v _ hv
    rw [substs_nrel hR hts.isUTerm,
      substs_nrel hR (hv.termSubstVec hts).isUTerm,
      substs_nrel hR hts.isUTerm]
    simp only [qqNRel_inj, true_and]
    apply nth_ext' k (by rw [len_termSubstVec (hv.termSubstVec hts).isUTerm]) (by rw [len_termSubstVec hts.isUTerm])
    intro i hi
    rw [nth_termSubstVec (hv.termSubstVec hts).isUTerm hi,
      nth_termSubstVec hts.isUTerm hi,
      nth_termSubstVec hts.isUTerm hi,
      termSubst_termSubst hv (hts.nth hi)]
  ¬∑ intros; simp
  ¬∑ intros; simp
  ¬∑ intro l p q hp hq ihp ihq m w n v hw hv
    rw [substs_and hp.isUFormula hq.isUFormula,
      substs_and (hp.substs hv).isUFormula (hq.substs hv).isUFormula,
      substs_and hp.isUFormula hq.isUFormula,
      ihp hw hv, ihq hw hv]
  ¬∑ intro l p q hp hq ihp ihq m w n v hw hv
    rw [substs_or hp.isUFormula hq.isUFormula,
      substs_or (hp.substs hv).isUFormula (hq.substs hv).isUFormula,
      substs_or hp.isUFormula hq.isUFormula,
      ihp hw hv, ihq hw hv]
  ¬∑ intro l p hp ih m w n v hw hv
    rw [substs_all hp.isUFormula,
      substs_all (hp.substs hv.qVec).isUFormula,
      substs_all hp.isUFormula,
      ih hw.qVec hv.qVec,
      termSubstVec_qVec_qVec hv hw]
  ¬∑ intro l p hp ih m w n v hw hv
    rw [substs_ex hp.isUFormula,
      substs_ex (hp.substs hv.qVec).isUFormula,
      substs_ex hp.isUFormula,
      ih hw.qVec hv.qVec,
      termSubstVec_qVec_qVec hv hw]

lemma subst_eq_self {n w : V} (hp : IsSemiformula L n p) (hw : IsSemitermVec L n n w) (H : ‚àÄ i < n, w.[i] = ^#i) :
    substs L w p = p := by
  revert w
  apply IsSemiformula.pi1_structural_induction ?_ ?_ ?_ ?_ ?_ ?_ ?_ ?_ ?_ hp
  ¬∑ definability
  ¬∑ intro n k R v hR hv w _ H
    simp only [substs_rel, qqRel_inj, true_and, hR, hv.isUTerm]
    apply nth_ext' k (by simp [*, hv.isUTerm]) (by simp [hv.lh])
    intro i hi
    rw [nth_termSubstVec hv.isUTerm hi, termSubst_eq_self (hv.nth hi) H]
  ¬∑ intro n k R v hR hv w _ H
    simp only [substs_nrel, qqNRel_inj, true_and, hR, hv.isUTerm]
    apply nth_ext' k (by simp [*, hv.isUTerm]) (by simp [hv.lh])
    intro i hi
    rw [nth_termSubstVec hv.isUTerm hi, termSubst_eq_self (hv.nth hi) H]
  ¬∑ intro n w _ _; simp
  ¬∑ intro n w _ _; simp
  ¬∑ intro n p q hp hq ihp ihq w hw H
    simp [*, hp.isUFormula, hq.isUFormula, ihp hw H, ihq hw H]
  ¬∑ intro n p q hp hq ihp ihq w hw H
    simp [*, hp.isUFormula, hq.isUFormula, ihp hw H, ihq hw H]
  ¬∑ intro n p hp ih w hw H
    have H : ‚àÄ i < n + 1, (qVec L w).[i] = ^#i := by
      intro i hi
      rcases zero_or_succ i with (rfl | ‚ü®i, rfl‚ü©)
      ¬∑ simp [qVec]
      ¬∑ have hi : i < n := by simpa using hi
        simp only [qVec, nth_adjoin_succ]
        rw [nth_termBShiftVec (by simpa [hw.lh] using hw.isUTerm) (by simp [hw.lh, hi])]
        simp [H i hi]
    simp [*, hp.isUFormula, ih hw.qVec H]
  ¬∑ intro n p hp ih w hw H
    have H : ‚àÄ i < n + 1, (qVec L w).[i] = ^#i := by
      intro i hi
      rcases zero_or_succ i with (rfl | ‚ü®i, rfl‚ü©)
      ¬∑ simp [qVec]
      ¬∑ have hi : i < n := by simpa using hi
        simp only [qVec, nth_adjoin_succ]
        rw [nth_termBShiftVec (by simpa [hw.lh] using hw.isUTerm) (by simp [hw.lh, hi])]
        simp [H i hi]
    simp [*, hp.isUFormula, ih hw.qVec H]

lemma subst_eq_self‚ÇÅ (hp : IsSemiformula L 1 p) :
    substs L (^#0 ‚à∑ 0) p = p := subst_eq_self hp (by simp) (by simp)

end substs

variable (L)

noncomputable def substs1 (t u : V) : V := substs L ?[t] u

def substs1Graph : ùö∫‚ÇÅ.Semisentence 3 := .mkSigma ‚Äú z t p. ‚àÉ v, !adjoinDef v t 0 ‚àß !(substsGraph L) z v p‚Äù

variable {L}

section substs1

section

lemma substs1.defined : ùö∫‚ÇÅ-Function‚ÇÇ[V] substs1 L via substs1Graph L := by
  intro v; simp [substs1Graph, substs.defined.df.iff]; rfl

instance substs1.definable : ùö∫‚ÇÅ-Function‚ÇÇ[V] substs1 L := substs1.defined.to_definable

instance substs1.definable' : Œì-[m + 1]-Function‚ÇÇ[V] substs1 L := substs1.definable.of_sigmaOne

end

lemma IsSemiformula.substs1 {n t p : V} (ht : IsSemiterm L n t) (hp : IsSemiformula L 1 p) : IsSemiformula L n (substs1 L t p) :=
  IsSemiformula.substs hp (by simp [ht])

end substs1

variable (L)

noncomputable def free (p : V) : V := substs1 L ^&0 (shift L p)

def freeGraph : ùö∫‚ÇÅ.Semisentence 2 := .mkSigma
  ‚Äúq p. ‚àÉ fz, !qqFvarDef fz 0 ‚àß ‚àÉ sp, !(shiftGraph L) sp p ‚àß !(substs1Graph L) q fz sp‚Äù

variable {L}

/-! ### free function -/

section free

section

lemma free.defined : ùö∫‚ÇÅ-Function‚ÇÅ[V] free L via freeGraph L := by
  intro v; simp [freeGraph, shift.defined.df.iff, substs1.defined.df.iff, free]

instance free.definable : ùö∫‚ÇÅ-Function‚ÇÅ[V] free L := free.defined.to_definable

instance free.definable' : Œì-[m + 1]-Function‚ÇÅ[V] free L := free.definable.of_sigmaOne

end

@[simp] lemma IsSemiformula.free {p : V} (hp : IsSemiformula L 1 p) : IsFormula L (free L p) :=
  IsSemiformula.substs1 (by simp) hp.shift

end free

section free1

variable (L)

noncomputable def free1 (p : V) : V := substs L ?[^&0, ^#0] (shift L p)

variable {L}

@[simp] lemma IsSemiformula.free1 {p : V} (hp : IsSemiformula L 2 p) : IsSemiformula L 1 (free1 L p) :=
  IsSemiformula.substs (m := 1) hp.shift (SemitermVec.adjoin (SemitermVec.adjoin (IsSemitermVec.empty _) (by simp)) (by simp))

end free1

/-! ### Complexity of formula -/

section complexity

namespace FormulaComplexity

def blueprint : UformulaRec1.Blueprint where
  rel := .mkSigma ‚Äúy param k R v. y = 0‚Äù
  nrel := .mkSigma ‚Äúy param k R v. y = 0‚Äù
  verum := .mkSigma ‚Äúy param. y = 0‚Äù
  falsum := .mkSigma ‚Äúy param. y = 0‚Äù
  and := .mkSigma ‚Äúy param p‚ÇÅ p‚ÇÇ y‚ÇÅ y‚ÇÇ. !Arithmetic.max y (y‚ÇÅ + 1) (y‚ÇÇ + 1)‚Äù
  or := .mkSigma ‚Äúy param p‚ÇÅ p‚ÇÇ y‚ÇÅ y‚ÇÇ. !Arithmetic.max y (y‚ÇÅ + 1) (y‚ÇÇ + 1)‚Äù
  all := .mkSigma ‚Äúy param p‚ÇÅ y‚ÇÅ. y = y‚ÇÅ + 1‚Äù
  ex := .mkSigma ‚Äúy param p‚ÇÅ y‚ÇÅ. y = y‚ÇÅ + 1‚Äù
  allChanges := .mkSigma ‚Äúparam' param. param' = 0‚Äù
  exChanges := .mkSigma ‚Äúparam' param. param' = 0‚Äù

noncomputable def construction : UformulaRec1.Construction V blueprint where
  rel {_} := fun k R v ‚Ü¶ 0
  nrel {_} := fun k R v ‚Ü¶ 0
  verum {_} := 0
  falsum {_} := 0
  and {_} := fun _ _ y‚ÇÅ y‚ÇÇ ‚Ü¶ max y‚ÇÅ y‚ÇÇ + 1
  or {_} := fun _ _ y‚ÇÅ y‚ÇÇ ‚Ü¶ max y‚ÇÅ y‚ÇÇ + 1
  all {_} := fun _ y‚ÇÅ ‚Ü¶ y‚ÇÅ + 1
  ex {_} := fun _ y‚ÇÅ ‚Ü¶ y‚ÇÅ + 1
  allChanges := fun _ ‚Ü¶ 0
  exChanges := fun _ ‚Ü¶ 0
  rel_defined := by intro v; simp [blueprint]
  nrel_defined := by intro v; simp [blueprint]
  verum_defined := by intro v; simp [blueprint]
  falsum_defined := by intro v; simp [blueprint]
  and_defined := by intro v; simp [blueprint, max_add_add_right]
  or_defined := by intro v; simp [blueprint, max_add_add_right]
  all_defined := by intro v; simp [blueprint]
  ex_defined := by intro v; simp [blueprint]
  allChanges_defined := by intro v; simp [blueprint]
  exChanges_defined := by intro v; simp [blueprint]

end FormulaComplexity

open FormulaComplexity

variable (L)

noncomputable def formulaComplexity (p : V) : V := construction.result L 0 p

def formulaComplexityGraph : ùö∫‚ÇÅ.Semisentence 2 := (blueprint.result L).rew (Rew.substs ![#0, ‚Äò0‚Äô, #1])

variable {L}

section

lemma formulaComplexity.defined : ùö∫‚ÇÅ-Function‚ÇÅ[V] formulaComplexity L via formulaComplexityGraph L  := fun v ‚Ü¶ by
  simpa [formulaComplexityGraph, Matrix.comp_vecCons', Matrix.constant_eq_singleton] using construction.result_defined ![v 0, 0, v 1]

instance formulaComplexity.definable : ùö∫‚ÇÅ-Function‚ÇÅ[V] formulaComplexity L := formulaComplexity.defined.to_definable

instance formulaComplexity.definable' : Œì-[m + 1]-Function‚ÇÅ[V] formulaComplexity L := .of_sigmaOne formulaComplexity.definable

end

@[simp] lemma formulaComplexity_rel {k R v : V} (hR : L.IsRel k R) (hv : IsUTermVec L k v) :
    formulaComplexity L (^rel k R v) = 0 := by simp [formulaComplexity, hR, hv, construction]

@[simp] lemma formulaComplexity_nrel {k R v : V} (hR : L.IsRel k R) (hv : IsUTermVec L k v) :
    formulaComplexity L (^nrel k R v) = 0 := by simp [formulaComplexity, hR, hv, construction]

@[simp] lemma formulaComplexity_verum :
    formulaComplexity L (^‚ä§ : V) = 0 := by simp [formulaComplexity, construction]

@[simp] lemma formulaComplexity_falsum :
    formulaComplexity L (^‚ä• : V) = 0 := by simp [formulaComplexity, construction]

@[simp] lemma formulaComplexity_and {p q : V} (hp : IsUFormula L p) (hq : IsUFormula L q) :
    formulaComplexity L (p ^‚ãè q) = max (formulaComplexity L p) (formulaComplexity L q) + 1 := by simp [formulaComplexity, hp, hq, construction]

@[simp] lemma formulaComplexity_or {p q : V} (hp : IsUFormula L p) (hq : IsUFormula L q) :
    formulaComplexity L (p ^‚ãé q) = max (formulaComplexity L p) (formulaComplexity L q) + 1 := by simp [formulaComplexity, hp, hq, construction]

@[simp] lemma formulaComplexity_all {p : V} (hp : IsUFormula L p) :
    formulaComplexity L (^‚àÄ p) = formulaComplexity L p + 1 := by simp [formulaComplexity, hp, construction]

@[simp] lemma formulaComplexity_ex {p : V} (hp : IsUFormula L p) :
    formulaComplexity L (^‚àÉ p) = formulaComplexity L p + 1 := by simp [formulaComplexity, hp, construction]

lemma formulaComplexity_not_uformula {x : V} (h : ¬¨IsUFormula L x) :
    formulaComplexity L x = 0 := construction.result_prop_not _ h

@[simp] lemma formulaComplexity_neg {p : V} : IsUFormula L p ‚Üí formulaComplexity L (neg L p) = formulaComplexity L p := by
  apply IsUFormula.ISigma1.sigma1_succ_induction
  ¬∑ definability
  ¬∑ intro k r v hr hv; simp [hr, hv]
  ¬∑ intro k r v hr hv; simp [hr, hv]
  ¬∑ simp
  ¬∑ simp
  ¬∑ intro p q hp hq ihp ihq; simp [hp, hq, ihp, ihq]
  ¬∑ intro p q hp hq ihp ihq; simp [hp, hq, ihp, ihq]
  ¬∑ intro p hp ihp; simp [hp, ihp]
  ¬∑ intro p hp ihp; simp [hp, ihp]

@[simp] lemma formulaComplexity_shift {p : V} : IsUFormula L p ‚Üí formulaComplexity L (shift L p) = formulaComplexity L p := by
  apply IsUFormula.ISigma1.sigma1_succ_induction
  ¬∑ definability
  ¬∑ intro k r v hr hv; simp [hr, hv]
  ¬∑ intro k r v hr hv; simp [hr, hv]
  ¬∑ simp
  ¬∑ simp
  ¬∑ intro p q hp hq ihp ihq
    simp [hp, hq, ihp, ihq]
  ¬∑ intro p q hp hq ihp ihq; simp [hp, hq, ihp, ihq]
  ¬∑ intro p hp ihp; simp [hp, ihp]
  ¬∑ intro p hp ihp; simp [hp, ihp]

lemma fomulaComplexity_substs {p : V} (hp : IsSemiformula L n p) :
    IsSemitermVec L n m w ‚Üí formulaComplexity L (substs L w p) = formulaComplexity L p := by
  revert m w
  apply IsSemiformula.pi1_structural_induction ?_ ?_ ?_ ?_ ?_ ?_ ?_ ?_ ?_ hp
  ¬∑ definability
  ¬∑ intro n k R v hR hv m w hw
    rw [formulaComplexity_rel hR hv.isUTerm, substs_rel hR hv.isUTerm, formulaComplexity_rel hR (hw.termSubstVec hv).isUTerm]
  ¬∑ intro n k R v hR hv m w hw
    rw [formulaComplexity_nrel hR hv.isUTerm, substs_nrel hR hv.isUTerm, formulaComplexity_nrel hR (hw.termSubstVec hv).isUTerm]
  ¬∑ intro n m w hw
    rw [substs_verum]
  ¬∑ intro n m w hw
    rw [substs_falsum]
  ¬∑ intro n p q hp hq ihp ihq m w hw
    rw [substs_and hp.isUFormula hq.isUFormula,
      formulaComplexity_and (hp.substs hw).isUFormula (hq.substs hw).isUFormula,
      ihp hw, ihq hw,
      formulaComplexity_and hp.isUFormula hq.isUFormula]
  ¬∑ intro n p q hp hq ihp ihq m w hw
    rw [substs_or hp.isUFormula hq.isUFormula,
      formulaComplexity_or (hp.substs hw).isUFormula (hq.substs hw).isUFormula,
      ihp hw, ihq hw,
      formulaComplexity_or hp.isUFormula hq.isUFormula]
  ¬∑ intro n p hp ihp m w hw
    rw [substs_all hp.isUFormula,
     formulaComplexity_all (hp.substs hw.qVec).isUFormula,
     ihp (hw.qVec),
     formulaComplexity_all hp.isUFormula]
  ¬∑ intro n p hp ihp m w hw
    rw [substs_ex hp.isUFormula,
     formulaComplexity_ex (hp.substs hw.qVec).isUFormula,
     ihp (hw.qVec),
     formulaComplexity_ex hp.isUFormula]

lemma fomulaComplexity_substs1 {p : V} (hp : IsSemiformula L 1 p) (ht : IsSemiterm L m t) :
    formulaComplexity L (substs1 L t p) = formulaComplexity L p := by
  unfold substs1
  rw [fomulaComplexity_substs hp (IsSemitermVec.singleton.mpr ht)]


lemma fomulaComplexity_free {p : V} (hp : IsSemiformula L 1 p) :
    formulaComplexity L (free L p) = formulaComplexity L p := by
  unfold free
  have : IsSemiterm (V := V) L 0 ^&0 := by simp
  rw [fomulaComplexity_substs1 hp.shift this,
    formulaComplexity_shift hp.isUFormula]

lemma fomulaComplexity_free1 {p : V} (hp : IsSemiformula L 2 p) :
    formulaComplexity L (free1 L p) = formulaComplexity L p := by
  unfold free1
  have : IsSemiterm (V := V) L 0 ^&0 := by simp
  rw [fomulaComplexity_substs (m := 1) (V := V) hp.shift]
  ¬∑ rw [formulaComplexity_shift hp.isUFormula]
  ¬∑ apply IsSemitermVec.adjoin ?_ (by simp)
    apply IsSemitermVec.adjoin ?_ (by simp)
    exact IsSemitermVec.nil _

end complexity

@[simp] lemma lt_max_succ_left (a b : V) : a < max a b + 1 := lt_succ_iff_le.mpr <| by simp

@[simp] lemma lt_max_succ_right (a b : V) : b < max a b + 1 := lt_succ_iff_le.mpr <| by simp

/-! A structural induction correspondence to `LO.FirstOrder.Semiformula.formulaRec`.  -/
lemma IsFormula.sigma1_structural_induction {P : V ‚Üí Prop} (hP : ùö∫‚ÇÅ-Predicate P)
    (hrel : ‚àÄ k r v, L.IsRel k r ‚Üí IsTermVec L k v ‚Üí P (^rel k r v))
    (hnrel : ‚àÄ k r v, L.IsRel k r ‚Üí IsTermVec L k v ‚Üí P (^nrel k r v))
    (hverum : P ^‚ä§)
    (hfalsum : P ^‚ä•)
    (hand : ‚àÄ p q, IsFormula L p ‚Üí IsFormula L q ‚Üí P p ‚Üí P q ‚Üí P (p ^‚ãè q))
    (hor : ‚àÄ p q, IsFormula L p ‚Üí IsFormula L q ‚Üí P p ‚Üí P q ‚Üí P (p ^‚ãé q))
    (hall : ‚àÄ p, IsSemiformula L 1 p ‚Üí P (free L p) ‚Üí P (^‚àÄ p))
    (hex : ‚àÄ p, IsSemiformula L 1 p ‚Üí P (free L p) ‚Üí P (^‚àÉ p)) {p} :
    IsFormula L p ‚Üí P p := by
  have hm : ùö∫‚ÇÅ-Function‚ÇÅ[V] formulaComplexity L := inferInstance
  let f : V ‚Üí V := fun p ‚Ü¶ max p (free L (œÄ‚ÇÇ (p - 1)))
  have hf : ùö∫‚ÇÅ-Function‚ÇÅ f := by unfold f; definability
  apply measured_bounded_sigma1_order_induction hm hf ?_ ?_ p
  ¬∑ definability
  intro p ih hp
  rcases IsSemiformula.case_iff.mp hp with
    (‚ü®k, R, v, hR, hv, rfl‚ü© | ‚ü®k, R, v, hR, hv, rfl‚ü©
      | rfl | rfl
      | ‚ü®p‚ÇÅ, p‚ÇÇ, h‚ÇÅ, h‚ÇÇ, rfl‚ü© | ‚ü®p‚ÇÅ, p‚ÇÇ, h‚ÇÅ, h‚ÇÇ, rfl‚ü©
      | ‚ü®p‚ÇÅ, h‚ÇÅ, rfl‚ü© | ‚ü®p‚ÇÅ, h‚ÇÅ, rfl‚ü©)
  ¬∑ exact hrel _ _ _ hR hv
  ¬∑ exact hnrel _ _ _ hR hv
  ¬∑ exact hverum
  ¬∑ exact hfalsum
  ¬∑ have ih‚ÇÅ : P p‚ÇÅ :=
      ih p‚ÇÅ (by simp only [le_sup_iff, f]; left; exact le_of_lt <| by simp) (by simp [h‚ÇÅ.isUFormula, h‚ÇÇ.isUFormula]) h‚ÇÅ
    have ih‚ÇÇ : P p‚ÇÇ :=
      ih p‚ÇÇ (by simp only [le_sup_iff, f]; left; exact le_of_lt <| by simp) (by simp [h‚ÇÅ.isUFormula, h‚ÇÇ.isUFormula]) h‚ÇÇ
    exact hand _ _ h‚ÇÅ h‚ÇÇ ih‚ÇÅ ih‚ÇÇ
  ¬∑ have ih‚ÇÅ : P p‚ÇÅ :=
      ih p‚ÇÅ (by simp only [le_sup_iff, f]; left; exact le_of_lt <| by simp) (by simp [h‚ÇÅ.isUFormula, h‚ÇÇ.isUFormula]) h‚ÇÅ
    have ih‚ÇÇ : P p‚ÇÇ :=
      ih p‚ÇÇ (by simp only [le_sup_iff, f]; left; exact le_of_lt <| by simp) (by simp [h‚ÇÅ.isUFormula, h‚ÇÇ.isUFormula]) h‚ÇÇ
    exact hor _ _ h‚ÇÅ h‚ÇÇ ih‚ÇÅ ih‚ÇÇ
  ¬∑ have h‚ÇÅ : IsSemiformula L 1 p‚ÇÅ := by simpa using h‚ÇÅ
    have : P (free L p‚ÇÅ) := ih (free L p‚ÇÅ) (by simp only [le_sup_iff, f]; right; simp [qqAll])
      (by simp [fomulaComplexity_free h‚ÇÅ, h‚ÇÅ.isUFormula])
      (h‚ÇÅ.free)
    exact hall _ h‚ÇÅ this
  ¬∑ have h‚ÇÅ : IsSemiformula L 1 p‚ÇÅ := by simpa using h‚ÇÅ
    have : P (free L p‚ÇÅ) := ih (free L p‚ÇÅ) (by simp only [le_sup_iff, f]; right; simp [qqEx])
      (by simp [fomulaComplexity_free h‚ÇÅ, h‚ÇÅ.isUFormula])
      (h‚ÇÅ.free)
    exact hex _ h‚ÇÅ this

lemma IsFormula.sigma1_structural_induction‚ÇÇ {P : V ‚Üí Prop} (hP : ùö∫‚ÇÅ-Predicate P)
    (hrel : ‚àÄ k r v, L.IsRel k r ‚Üí IsSemitermVec L k 1 v ‚Üí P (^rel k r v))
    (hnrel : ‚àÄ k r v, L.IsRel k r ‚Üí IsSemitermVec L k 1 v ‚Üí P (^nrel k r v))
    (hverum : P ^‚ä§)
    (hfalsum : P ^‚ä•)
    (hand : ‚àÄ p q, IsSemiformula L 1 p ‚Üí IsSemiformula L 1 q ‚Üí P p ‚Üí P q ‚Üí P (p ^‚ãè q))
    (hor : ‚àÄ p q, IsSemiformula L 1 p ‚Üí IsSemiformula L 1 q ‚Üí P p ‚Üí P q ‚Üí P (p ^‚ãé q))
    (hall : ‚àÄ p, IsSemiformula L 2 p ‚Üí P (free1 L p) ‚Üí P (^‚àÄ p))
    (hex : ‚àÄ p, IsSemiformula L 2 p ‚Üí P (free1 L p) ‚Üí P (^‚àÉ p)) {p} :
    IsSemiformula L 1 p ‚Üí P p := by
  have hm : ùö∫‚ÇÅ-Function‚ÇÅ[V] formulaComplexity L := inferInstance
  let f : V ‚Üí V := fun p ‚Ü¶ max p (free1 L (œÄ‚ÇÇ (p - 1)))
  have hf : ùö∫‚ÇÅ-Function‚ÇÅ f := by unfold f; definability
  apply measured_bounded_sigma1_order_induction hm hf ?_ ?_ p
  ¬∑ definability
  intro p ih hp
  rcases IsSemiformula.case_iff.mp hp with
    (‚ü®k, R, v, hR, hv, rfl‚ü© | ‚ü®k, R, v, hR, hv, rfl‚ü©
      | rfl | rfl
      | ‚ü®p‚ÇÅ, p‚ÇÇ, h‚ÇÅ, h‚ÇÇ, rfl‚ü© | ‚ü®p‚ÇÅ, p‚ÇÇ, h‚ÇÅ, h‚ÇÇ, rfl‚ü©
      | ‚ü®p‚ÇÅ, h‚ÇÅ, rfl‚ü© | ‚ü®p‚ÇÅ, h‚ÇÅ, rfl‚ü©)
  ¬∑ exact hrel _ _ _ hR hv
  ¬∑ exact hnrel _ _ _ hR hv
  ¬∑ exact hverum
  ¬∑ exact hfalsum
  ¬∑ have ih‚ÇÅ : P p‚ÇÅ :=
      ih p‚ÇÅ (by simp only [le_sup_iff, f]; left; exact le_of_lt <| by simp) (by simp [h‚ÇÅ.isUFormula, h‚ÇÇ.isUFormula]) h‚ÇÅ
    have ih‚ÇÇ : P p‚ÇÇ :=
      ih p‚ÇÇ (by simp only [le_sup_iff, f]; left; exact le_of_lt <| by simp) (by simp [h‚ÇÅ.isUFormula, h‚ÇÇ.isUFormula]) h‚ÇÇ
    exact hand _ _ h‚ÇÅ h‚ÇÇ ih‚ÇÅ ih‚ÇÇ
  ¬∑ have ih‚ÇÅ : P p‚ÇÅ :=
      ih p‚ÇÅ (by simp only [le_sup_iff, f]; left; exact le_of_lt <| by simp) (by simp [h‚ÇÅ.isUFormula, h‚ÇÇ.isUFormula]) h‚ÇÅ
    have ih‚ÇÇ : P p‚ÇÇ :=
      ih p‚ÇÇ (by simp only [le_sup_iff, f]; left; exact le_of_lt <| by simp) (by simp [h‚ÇÅ.isUFormula, h‚ÇÇ.isUFormula]) h‚ÇÇ
    exact hor _ _ h‚ÇÅ h‚ÇÇ ih‚ÇÅ ih‚ÇÇ
  ¬∑ have h‚ÇÅ : IsSemiformula L 2 p‚ÇÅ := by simpa [one_add_one_eq_two] using h‚ÇÅ
    have : P (free1 L p‚ÇÅ) := ih (free1 L p‚ÇÅ) (by simp only [le_sup_iff, f]; right; simp [qqAll])
      (by simp [fomulaComplexity_free1 h‚ÇÅ, h‚ÇÅ.isUFormula])
      h‚ÇÅ.free1
    exact hall _ h‚ÇÅ this
  ¬∑ have h‚ÇÅ : IsSemiformula L 2 p‚ÇÅ := by simpa  [one_add_one_eq_two] using h‚ÇÅ
    have : P (free1 L p‚ÇÅ) := ih (free1 L p‚ÇÅ) (by simp only [le_sup_iff, f]; right; simp [qqEx])
      (by simp [fomulaComplexity_free1 h‚ÇÅ, h‚ÇÅ.isUFormula])
      h‚ÇÅ.free1
    exact hex _ h‚ÇÅ this

lemma IsFormula.sigma1_structural_induction‚ÇÇ_ss {P : V ‚Üí Prop} (hP : ùö∫‚ÇÅ-Predicate P)
    (hrel : ‚àÄ k r v, L.IsRel k r ‚Üí IsSemitermVec L k 1 v ‚Üí P (^rel k r v))
    (hnrel : ‚àÄ k r v, L.IsRel k r ‚Üí IsSemitermVec L k 1 v ‚Üí P (^nrel k r v))
    (hverum : P ^‚ä§)
    (hfalsum : P ^‚ä•)
    (hand : ‚àÄ p q, IsSemiformula L 1 p ‚Üí IsSemiformula L 1 q ‚Üí P p ‚Üí P q ‚Üí P (p ^‚ãè q))
    (hor : ‚àÄ p q, IsSemiformula L 1 p ‚Üí IsSemiformula L 1 q ‚Üí P p ‚Üí P q ‚Üí P (p ^‚ãé q))
    (hall : ‚àÄ p, IsSemiformula L 2 p ‚Üí P (free1 L <| shift L <| shift L <| p) ‚Üí P (^‚àÄ p))
    (hex : ‚àÄ p, IsSemiformula L 2 p ‚Üí P (free1 L <| shift L <| shift L <| p) ‚Üí P (^‚àÉ p)) {p} :
    IsSemiformula L 1 p ‚Üí P p := by
  have hm : ùö∫‚ÇÅ-Function‚ÇÅ[V] formulaComplexity L := inferInstance
  let f : V ‚Üí V := fun p ‚Ü¶ max p (free1 L <| shift L <| shift L <| (œÄ‚ÇÇ (p - 1)))
  have hf : ùö∫‚ÇÅ-Function‚ÇÅ f := by unfold f; definability
  apply measured_bounded_sigma1_order_induction hm hf ?_ ?_ p
  ¬∑ definability
  intro p ih hp
  rcases IsSemiformula.case_iff.mp hp with
    (‚ü®k, R, v, hR, hv, rfl‚ü© | ‚ü®k, R, v, hR, hv, rfl‚ü©
      | rfl | rfl
      | ‚ü®p‚ÇÅ, p‚ÇÇ, h‚ÇÅ, h‚ÇÇ, rfl‚ü© | ‚ü®p‚ÇÅ, p‚ÇÇ, h‚ÇÅ, h‚ÇÇ, rfl‚ü©
      | ‚ü®p‚ÇÅ, h‚ÇÅ, rfl‚ü© | ‚ü®p‚ÇÅ, h‚ÇÅ, rfl‚ü©)
  ¬∑ exact hrel _ _ _ hR hv
  ¬∑ exact hnrel _ _ _ hR hv
  ¬∑ exact hverum
  ¬∑ exact hfalsum
  ¬∑ have ih‚ÇÅ : P p‚ÇÅ :=
      ih p‚ÇÅ (by simp only [le_sup_iff, f]; left; exact le_of_lt <| by simp) (by simp [h‚ÇÅ.isUFormula, h‚ÇÇ.isUFormula]) h‚ÇÅ
    have ih‚ÇÇ : P p‚ÇÇ :=
      ih p‚ÇÇ (by simp only [le_sup_iff, f]; left; exact le_of_lt <| by simp) (by simp [h‚ÇÅ.isUFormula, h‚ÇÇ.isUFormula]) h‚ÇÇ
    exact hand _ _ h‚ÇÅ h‚ÇÇ ih‚ÇÅ ih‚ÇÇ
  ¬∑ have ih‚ÇÅ : P p‚ÇÅ :=
      ih p‚ÇÅ (by simp only [le_sup_iff, f]; left; exact le_of_lt <| by simp) (by simp [h‚ÇÅ.isUFormula, h‚ÇÇ.isUFormula]) h‚ÇÅ
    have ih‚ÇÇ : P p‚ÇÇ :=
      ih p‚ÇÇ (by simp only [le_sup_iff, f]; left; exact le_of_lt <| by simp) (by simp [h‚ÇÅ.isUFormula, h‚ÇÇ.isUFormula]) h‚ÇÇ
    exact hor _ _ h‚ÇÅ h‚ÇÇ ih‚ÇÅ ih‚ÇÇ
  ¬∑ have h‚ÇÅ : IsSemiformula L 2 p‚ÇÅ := by simpa [one_add_one_eq_two] using h‚ÇÅ
    have : P (free1 L <| shift L <| shift L <| p‚ÇÅ) :=
      ih (free1 L <| shift L <| shift L <| p‚ÇÅ) (by simp only [le_sup_iff, f]; right; simp [qqAll])
      (by rw [fomulaComplexity_free1 h‚ÇÅ.shift.shift, formulaComplexity_shift h‚ÇÅ.shift.isUFormula,
          formulaComplexity_shift h‚ÇÅ.isUFormula]; simp [h‚ÇÅ.isUFormula])
      h‚ÇÅ.shift.shift.free1
    exact hall _ h‚ÇÅ this
  ¬∑ have h‚ÇÅ : IsSemiformula L 2 p‚ÇÅ := by simpa [one_add_one_eq_two] using h‚ÇÅ
    have : P (free1 L <| shift L <| shift L <| p‚ÇÅ) :=
      ih (free1 L <| shift L <| shift L <| p‚ÇÅ) (by simp only [le_sup_iff, f]; right; simp [qqEx])
      (by rw [fomulaComplexity_free1 h‚ÇÅ.shift.shift, formulaComplexity_shift h‚ÇÅ.shift.isUFormula,
          formulaComplexity_shift h‚ÇÅ.isUFormula]; simp [h‚ÇÅ.isUFormula])
      h‚ÇÅ.shift.shift.free1
    exact hex _ h‚ÇÅ this

/-
section fvfree

variable (L)

def Language.IsFVFree (n p : V) : Prop := IsSemiformula L n p ‚àß shift L p = p

section

def _root_.LO.FirstOrder.Arithmetic.LDef.isFVFreeDef (pL : LDef) : ùö∫‚ÇÅ.Semisentence 2 :=
  .mkSigma ‚Äún p | !(isSemiformula L).sigma n p ‚àß !pshift LDef p p‚Äù

lemma isFVFree_defined : ùö∫‚ÇÅ-Relation L.IsFVFree via pL.isFVFreeDef := by
  intro v; simp [LDef.isFVFreeDef, HierarchySymbol.Semiformula.val_sigma, (semiformula_defined L).df.iff, (shift_defined L).df.iff]
  simp [Language.IsFVFree, eq_comm]

end

variable {L}

@[simp] lemma Language.IsFVFree.verum (n : V) : L.IsFVFree n ^‚ä§[n] := by simp [Language.IsFVFree]

@[simp] lemma Language.IsFVFree.falsum (n : V) : L.IsFVFree n ^‚ä•[n] := by simp [Language.IsFVFree]

lemma Language.IsFVFree.and {n p q : V} (hp : L.IsFVFree n p) (hq : L.IsFVFree n q) :
    L.IsFVFree n (p ^‚ãè[n] q) := by simp [Language.IsFVFree, hp.1, hq.1, hp.2, hq.2]

lemma Language.IsFVFree.or {n p q : V} (hp : L.IsFVFree n p) (hq : L.IsFVFree n q) :
    L.IsFVFree n (p ^‚ãé[n] q) := by simp [Language.IsFVFree, hp.1, hq.1, hp.2, hq.2]

lemma Language.IsFVFree.all {n p : V} (hp : L.IsFVFree (n + 1) p) :
    L.IsFVFree n (^‚àÄ[n] p) := by simp [Language.IsFVFree, hp.1, hp.2]

lemma Language.IsFVFree.ex {n p : V} (hp : L.IsFVFree (n + 1) p) :
    L.IsFVFree n (^‚àÉ[n] p) := by simp [Language.IsFVFree, hp.1, hp.2]

@[simp] lemma Language.IsFVFree.neg_iff : L.IsFVFree n (neg L p) ‚Üî L.IsFVFree n p := by
  constructor
  ¬∑ intro h
    have hp : Semiformula L n p := IsSemiformula.neg_iff.mp h.1
    have : shift L (neg L p) = neg L p := h.2
    simp [shift_neg hp, neg_inj_iff hp.shift hp] at this
    exact ‚ü®hp, this‚ü©
  ¬∑ intro h; exact ‚ü®by simp [h.1], by rw [shift_neg h.1, h.2]‚ü©

end fvfree
-/

namespace InternalArithmetic

noncomputable def qqEQ (x y : V) : V := ^rel 2 (eqIndex : V) ?[x, y]

noncomputable def qqNEQ (x y : V) : V := ^nrel 2 (eqIndex : V) ?[x, y]

noncomputable def qqLT (x y : V) : V := ^rel 2 (ltIndex : V) ?[x, y]

noncomputable def qqNLT (x y : V) : V := ^nrel 2 (ltIndex : V) ?[x, y]

notation:75 x:75 " ^= " y:76 => qqEQ x y

notation:75 x:75 " ^‚â† " y:76 => qqNEQ x y

notation:78 x:78 " ^< " y:79 => qqLT x y

notation:78 x:78 " ^<Ã∏ " y:79 => qqNLT x y

@[simp] lemma lt_qqEQ_left (x y : V) : x < x ^= y := by
  simpa using nth_lt_qqRel_of_lt (i := 0) (k := 2) (r := (eqIndex : V)) (v := ?[x, y]) (by simp)

@[simp] lemma lt_qqEQ_right (x y : V) : y < x ^= y := by
  simpa using nth_lt_qqRel_of_lt (i := 1) (k := 2) (r := (eqIndex : V)) (v := ?[x, y]) (by simp)

@[simp] lemma lt_qqLT_left (x y : V) : x < x ^< y := by
  simpa using nth_lt_qqRel_of_lt (i := 0) (k := 2) (r := (ltIndex : V)) (v := ?[x, y]) (by simp)

@[simp] lemma lt_qqLT_right (x y : V) : y < x ^< y := by
  simpa using nth_lt_qqRel_of_lt (i := 1) (k := 2) (r := (ltIndex : V)) (v := ?[x, y]) (by simp)

@[simp] lemma lt_qqNEQ_left (x y : V) : x < x ^‚â† y := by
  simpa using nth_lt_qqNRel_of_lt (i := 0) (k := 2) (r := (eqIndex : V)) (v := ?[x, y]) (by simp)

@[simp] lemma lt_qqNEQ_right (x y : V) : y < x ^‚â† y := by
  simpa using nth_lt_qqNRel_of_lt (i := 1) (k := 2) (r := (eqIndex : V)) (v := ?[x, y]) (by simp)

@[simp] lemma lt_qqNLT_left (x y : V) : x < x ^<Ã∏ y := by
  simpa using nth_lt_qqNRel_of_lt (i := 0) (k := 2) (r := (ltIndex : V)) (v := ?[x, y]) (by simp)

@[simp] lemma lt_qqNLT_right (x y : V) : y < x ^<Ã∏ y := by
  simpa using nth_lt_qqNRel_of_lt (i := 1) (k := 2) (r := (ltIndex : V)) (v := ?[x, y]) (by simp)

def _root_.LO.FirstOrder.Arithmetic.qqEQDef : ùö∫‚ÇÅ.Semisentence 3 :=
  .mkSigma ‚Äúp x y. ‚àÉ v, !mkVec‚ÇÇDef v x y ‚àß !qqRelDef p 2 ‚ÜëeqIndex v‚Äù

def _root_.LO.FirstOrder.Arithmetic.qqNEQDef : ùö∫‚ÇÅ.Semisentence 3 :=
  .mkSigma ‚Äúp x y. ‚àÉ v, !mkVec‚ÇÇDef v x y ‚àß !qqNRelDef p 2 ‚ÜëeqIndex v‚Äù

def _root_.LO.FirstOrder.Arithmetic.qqLTDef : ùö∫‚ÇÅ.Semisentence 3 :=
  .mkSigma ‚Äúp x y. ‚àÉ v, !mkVec‚ÇÇDef v x y ‚àß !qqRelDef p 2 ‚ÜëltIndex v‚Äù

def _root_.LO.FirstOrder.Arithmetic.qqNLTDef : ùö∫‚ÇÅ.Semisentence 3 :=
  .mkSigma ‚Äúp x y. ‚àÉ v, !mkVec‚ÇÇDef v x y ‚àß !qqNRelDef p 2 ‚ÜëltIndex v‚Äù

lemma qqEQ_defined : ùö∫‚ÇÅ-Function‚ÇÇ (qqEQ : V ‚Üí V ‚Üí V) via qqEQDef := by
  intro v; simp [qqEQDef, numeral_eq_natCast, qqEQ]

lemma qqNEQ_defined : ùö∫‚ÇÅ-Function‚ÇÇ (qqNEQ : V ‚Üí V ‚Üí V) via qqNEQDef := by
  intro v; simp [qqNEQDef, numeral_eq_natCast, qqNEQ]

lemma qqLT_defined : ùö∫‚ÇÅ-Function‚ÇÇ (qqLT : V ‚Üí V ‚Üí V) via qqLTDef := by
  intro v; simp [qqLTDef, numeral_eq_natCast, qqLT]

lemma qqNLT_defined : ùö∫‚ÇÅ-Function‚ÇÇ (qqNLT : V ‚Üí V ‚Üí V) via qqNLTDef := by
  intro v; simp [qqNLTDef, numeral_eq_natCast, qqNLT]

instance (Œì m) : Œì-[m + 1]-Function‚ÇÇ (qqEQ : V ‚Üí V ‚Üí V) := .of_sigmaOne qqEQ_defined.to_definable

instance (Œì m) : Œì-[m + 1]-Function‚ÇÇ (qqNEQ : V ‚Üí V ‚Üí V) := .of_sigmaOne qqNEQ_defined.to_definable

instance (Œì m) : Œì-[m + 1]-Function‚ÇÇ (qqLT : V ‚Üí V ‚Üí V) := .of_sigmaOne qqLT_defined.to_definable

instance (Œì m) : Œì-[m + 1]-Function‚ÇÇ (qqNLT : V ‚Üí V ‚Üí V) := .of_sigmaOne qqNLT_defined.to_definable

@[simp] lemma eval_qqEQDef (v) : Semiformula.Evalbm V v qqEQDef.val ‚Üî v 0 = v 1 ^= v 2 := qqEQ_defined.df.iff v

@[simp] lemma eval_qqNEQDef (v) : Semiformula.Evalbm V v qqNEQDef.val ‚Üî v 0 = v 1 ^‚â† v 2 := qqNEQ_defined.df.iff v

@[simp] lemma eval_qqLTDef (v) : Semiformula.Evalbm V v qqLTDef.val ‚Üî v 0 = v 1 ^< v 2 := qqLT_defined.df.iff v

@[simp] lemma eval_qqNLTDef (v) : Semiformula.Evalbm V v qqNLTDef.val ‚Üî v 0 = v 1 ^<Ã∏ v 2 := qqNLT_defined.df.iff v

lemma neg_eq {t u : V} (ht : IsUTerm ‚Ñí‚Çí·µ£ t) (hu : IsUTerm ‚Ñí‚Çí·µ£ u) : neg ‚Ñí‚Çí·µ£ (t ^= u) = t ^‚â† u := by
  simp only [qqEQ, qqNEQ]
  rw [neg_rel (L := ‚Ñí‚Çí·µ£) (by simp) (by simp [ht, hu])]

lemma neg_neq {t u : V} (ht : IsUTerm ‚Ñí‚Çí·µ£ t) (hu : IsUTerm ‚Ñí‚Çí·µ£ u) : neg ‚Ñí‚Çí·µ£ (t ^‚â† u) = t ^= u := by
  simp only [qqNEQ, qqEQ]
  rw [neg_nrel (L := ‚Ñí‚Çí·µ£) (by simp) (by simp [ht, hu])]

lemma neg_lt {t u : V} (ht : IsUTerm ‚Ñí‚Çí·µ£ t) (hu : IsUTerm ‚Ñí‚Çí·µ£ u) : neg ‚Ñí‚Çí·µ£ (t ^< u) = t ^<Ã∏ u := by
  simp only [qqLT, qqNLT]
  rw [neg_rel (L := ‚Ñí‚Çí·µ£) (by simp) (by simp [ht, hu])]

lemma neg_nlt {t u : V} (ht : IsUTerm ‚Ñí‚Çí·µ£ t) (hu : IsUTerm ‚Ñí‚Çí·µ£ u) : neg ‚Ñí‚Çí·µ£ (t ^<Ã∏ u) = t ^< u := by
  simp only [qqNLT, qqLT]
  rw [neg_nrel (L := ‚Ñí‚Çí·µ£) (by simp) (by simp [ht, hu])]

lemma substs_eq {t u : V} (ht : IsUTerm ‚Ñí‚Çí·µ£ t) (hu : IsUTerm ‚Ñí‚Çí·µ£ u) :
    substs ‚Ñí‚Çí·µ£ w (t ^= u) = (termSubst ‚Ñí‚Çí·µ£ w t) ^= (termSubst ‚Ñí‚Çí·µ£ w u) := by
  simp only [qqEQ]
  rw [substs_rel (L := ‚Ñí‚Çí·µ£) (by simp) (by simp [ht, hu])]
  simp [termSubstVec_cons‚ÇÇ ht hu]

end InternalArithmetic

end LO.ISigma1.Metamath
