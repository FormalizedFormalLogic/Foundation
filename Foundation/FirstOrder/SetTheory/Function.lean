import Foundation.FirstOrder.SetTheory.Z

/-!
# Basic definitions and lemmata for relations and functions
-/

namespace LO.FirstOrder.SetTheory

variable {V : Type*} [SetStructure V] [Nonempty V] [V ‚äß‚Çò* ùó≠]

/-! ### Relations -/

noncomputable def domain (R : V) : V := {x ‚àà ‚ãÉÀ¢ ‚ãÉÀ¢ R ; ‚àÉ y, ‚ü®x, y‚ü©‚Çñ ‚àà R}

noncomputable def range (R : V) : V := {y ‚àà ‚ãÉÀ¢ ‚ãÉÀ¢ R ; ‚àÉ x, ‚ü®x, y‚ü©‚Çñ ‚àà R}

section domain

lemma mem_sUnion_sUnion_of_kpair_mem_left {x y R : V} (h : ‚ü®x, y‚ü©‚Çñ ‚àà R) : x ‚àà ‚ãÉÀ¢ ‚ãÉÀ¢ R := by
  simp only [mem_sUnion_iff]
  refine ‚ü®{x, y}, ‚ü®‚ü®x, y‚ü©‚Çñ, h, by simp [kpair]‚ü©, by simp‚ü©

lemma mem_domain_iff {R x : V} : x ‚àà domain R ‚Üî ‚àÉ y, ‚ü®x, y‚ü©‚Çñ ‚àà R := by
  simpa [domain] using fun _ ‚Ü¶  mem_sUnion_sUnion_of_kpair_mem_left

def domain.dfn : Semisentence ‚Ñí‚Çõ‚Çë‚Çú 2 := f‚Äúd R. ‚àÄ x, x ‚àà d ‚Üî ‚àÉ y, !kpair.dfn x y ‚àà R‚Äù

instance domain.defined : ‚Ñí‚Çõ‚Çë‚Çú-function‚ÇÅ[V] domain via domain.dfn := ‚ü®fun v ‚Ü¶ by simp [dfn, mem_ext_iff (y := domain _), mem_domain_iff]‚ü©

instance domain.definable : ‚Ñí‚Çõ‚Çë‚Çú-function‚ÇÅ[V] domain := domain.defined.to_definable

lemma mem_domain_of_kpair_mem {R x y : V} (h : ‚ü®x, y‚ü©‚Çñ ‚àà R) : x ‚àà domain R := mem_domain_iff.mpr ‚ü®y, h‚ü©

@[simp] lemma domain_empty : domain (‚àÖ : V) = ‚àÖ := by ext; simp [mem_domain_iff]

@[simp] lemma domain_prod (x y : V) [IsNonempty y] : domain (x √óÀ¢ y) = x := by
  ext z
  suffices z ‚àà x ‚Üí ‚àÉ x, x ‚àà y by simpa [mem_domain_iff]
  intro _
  exact IsNonempty.nonempty

lemma domain_subset_of_subset_prod {R X Y : V} (h : R ‚äÜ X √óÀ¢ Y) : domain R ‚äÜ X := by
  intro x hx
  have : ‚àÉ y, ‚ü®x, y‚ü©‚Çñ ‚àà R := by simpa [mem_domain_iff] using hx
  rcases this with ‚ü®y, hy‚ü©
  have : x ‚àà X ‚àß y ‚àà Y := by simpa using h _ hy
  exact this.1

@[simp, grind =] lemma domain_insert {x y R : V} : domain (insert (‚ü®x, y‚ü©‚Çñ) R) = insert x (domain R) := by
  ext z; simp only [mem_domain_iff, mem_insert, kpair_iff]; grind

end domain

section range

lemma mem_sUnion_sUnion_of_kpair_mem_right {x y R : V} (h : ‚ü®x, y‚ü©‚Çñ ‚àà R) : y ‚àà ‚ãÉÀ¢ ‚ãÉÀ¢ R := by
  simp only [mem_sUnion_iff]
  refine ‚ü®{x, y}, ‚ü®‚ü®x, y‚ü©‚Çñ, h, by simp [kpair]‚ü©, by simp‚ü©

lemma mem_range_iff {R y : V} : y ‚àà range R ‚Üî ‚àÉ x, ‚ü®x, y‚ü©‚Çñ ‚àà R := by
  simpa [range] using fun _ ‚Ü¶ mem_sUnion_sUnion_of_kpair_mem_right

def range.dfn : Semisentence ‚Ñí‚Çõ‚Çë‚Çú 2 := f‚Äúr R. ‚àÄ y, y ‚àà r ‚Üî ‚àÉ x, !kpair.dfn x y ‚àà R‚Äù

instance range.defined : ‚Ñí‚Çõ‚Çë‚Çú-function‚ÇÅ[V] range via range.dfn := ‚ü®fun v ‚Ü¶ by simp [dfn, mem_ext_iff (y := range _), mem_range_iff]‚ü©

instance range.definable : ‚Ñí‚Çõ‚Çë‚Çú-function‚ÇÅ[V] range := range.defined.to_definable

lemma mem_range_of_kpair_mem {R x y : V} (h : ‚ü®x, y‚ü©‚Çñ ‚àà R) : y ‚àà range R := mem_range_iff.mpr ‚ü®x, h‚ü©

@[simp] lemma range_empty : range (‚àÖ : V) = ‚àÖ := by ext; simp [mem_range_iff]

@[simp] lemma range_prod (x y : V) [IsNonempty x] : range (x √óÀ¢ y) = y := by
  ext z
  suffices z ‚àà y ‚Üí ‚àÉ v, v ‚àà x by simpa [mem_range_iff]
  intro _
  exact IsNonempty.nonempty

lemma range_subset_of_subset_prod {R X Y : V} (h : R ‚äÜ X √óÀ¢ Y) : range R ‚äÜ Y := by
  intro y hy
  have : ‚àÉ x, ‚ü®x, y‚ü©‚Çñ ‚àà R := by simpa [mem_range_iff] using hy
  rcases this with ‚ü®x, hx‚ü©
  have : x ‚àà X ‚àß y ‚àà Y := by simpa using h _ hx
  exact this.2

@[simp, grind =] lemma range_insert {x y R : V} : range (insert (‚ü®x, y‚ü©‚Çñ) R) = insert y (range R) := by
  ext z; simp only [mem_range_iff, mem_insert, kpair_iff]; grind

end range

/-! ### Functions -/

noncomputable def function (Y X : V) : V := {f ‚àà ‚Ñò (X √óÀ¢ Y) ; ‚àÄ x ‚àà X, ‚àÉ! y, ‚ü®x, y‚ü©‚Çñ ‚àà f}

noncomputable instance : Pow V V := ‚ü®fun Y X ‚Ü¶ function Y X‚ü©

lemma function_def {Y X : V} : Y ^ X = function Y X := rfl

lemma mem_function_iff {f Y X : V} : f ‚àà Y ^ X ‚Üî f ‚äÜ X √óÀ¢ Y ‚àß ‚àÄ x ‚àà X, ‚àÉ! y, ‚ü®x, y‚ü©‚Çñ ‚àà f := by simp [function, function_def]

def function.dfn : Semisentence ‚Ñí‚Çõ‚Çë‚Çú 3 := f‚ÄúF Y X. ‚àÄ f, f ‚àà F ‚Üî f ‚äÜ !prod.dfn X Y ‚àß ‚àÄ x ‚àà X, ‚àÉ! y, !kpair.dfn x y ‚àà f‚Äù

instance function.defined : ‚Ñí‚Çõ‚Çë‚Çú-function‚ÇÇ[V] (¬∑^¬∑) via function.dfn :=
  ‚ü®fun v ‚Ü¶ by simp [function.dfn, mem_ext_iff (y := (v 1)^(v 2)), mem_function_iff]‚ü©

instance function.definable : ‚Ñí‚Çõ‚Çë‚Çú-function‚ÇÇ[V] (¬∑^¬∑) := function.defined.to_definable

lemma mem_function.intro {f X Y : V} (prod : f ‚äÜ X √óÀ¢ Y) (total : ‚àÄ x ‚àà X, ‚àÉ! y, ‚ü®x, y‚ü©‚Çñ ‚àà f) : f ‚àà Y ^ X :=
  mem_function_iff.mpr ‚ü®prod, total‚ü©

lemma subset_prod_of_mem_function {f X Y : V} (h : f ‚àà Y ^ X) : f ‚äÜ X √óÀ¢ Y := mem_function_iff.mp h |>.1

lemma mem_of_mem_functions {f X Y : V} (h : f ‚àà Y ^ X) (hx : ‚ü®x, y‚ü©‚Çñ ‚àà f) : x ‚àà X ‚àß y ‚àà Y := by
  simpa using subset_prod_of_mem_function h _ hx

lemma function_subset_power_prod (X Y : V) : Y ^ X ‚äÜ ‚Ñò (X √óÀ¢ Y) := fun f hf ‚Ü¶ by simpa using subset_prod_of_mem_function hf

lemma exists_unique_of_mem_function {f X Y : V} (h : f ‚àà Y ^ X) : ‚àÄ x ‚àà X, ‚àÉ! y, ‚ü®x, y‚ü©‚Çñ ‚àà f := mem_function_iff.mp h |>.2

lemma exists_of_mem_function {f X Y : V} (h : f ‚àà Y ^ X) : ‚àÄ x ‚àà X, ‚àÉ y ‚àà Y, ‚ü®x, y‚ü©‚Çñ ‚àà f := by
  intro x hx
  rcases (exists_unique_of_mem_function h x hx).exists with ‚ü®y, hy‚ü©
  have : x ‚àà X ‚àß y ‚àà Y := mem_of_mem_functions h hy
  exact ‚ü®y, this.2, hy‚ü©

lemma domain_eq_of_mem_function {f X Y : V} (h : f ‚àà Y ^ X) : domain f = X := by
  ext x
  suffices (‚àÉ y, ‚ü®x, y‚ü©‚Çñ ‚àà f) ‚Üî x ‚àà X by simpa [mem_domain_iff]
  constructor
  ¬∑ rintro ‚ü®y, hxy‚ü©
    have : x ‚àà X ‚àß y ‚àà Y := mem_of_mem_functions h hxy
    exact this.1
  ¬∑ intro hx
    rcases exists_of_mem_function h x hx with ‚ü®y, hy‚ü©
    exact ‚ü®y, hy.2‚ü©

lemma range_subset_of_mem_function {f X Y : V} (h : f ‚àà Y ^ X) : range f ‚äÜ Y := by
  intro y hy
  have : ‚àÉ x, ‚ü®x, y‚ü©‚Çñ ‚àà f := by simpa [mem_range_iff] using hy
  rcases this with ‚ü®x, hxy‚ü©
  have : x ‚àà X ‚àß y ‚àà Y := mem_of_mem_functions h hxy
  exact this.2

lemma mem_function_range_of_mem_function {f X Y : V} (h : f ‚àà Y ^ X) : f ‚àà range f ^ X := by
  have : f ‚äÜ X √óÀ¢ range f := by
    intro p hp
    have : ‚àÉ x ‚àà X, ‚àÉ y ‚àà Y, p = ‚ü®x, y‚ü©‚Çñ := by
      simpa [mem_prod_iff] using subset_prod_of_mem_function h _ hp
    rcases this with ‚ü®x, hx, y, hy, rfl‚ü©
    simpa [hx, mem_range_iff] using ‚ü®x, hp‚ü©
  apply mem_function.intro this
  intro x hx
  rcases exists_unique_of_mem_function h x hx |>.exists with ‚ü®y, hf‚ü©
  apply ExistsUnique.intro y hf
  intro y' hf'
  have : y' = y := exists_unique_of_mem_function h x hx |>.unique hf' hf
  assumption

lemma mem_function_of_mem_function_of_subset {f X Y‚ÇÅ Y‚ÇÇ : V} (h : f ‚àà Y‚ÇÅ ^ X) (hY : Y‚ÇÅ ‚äÜ Y‚ÇÇ) : f ‚àà Y‚ÇÇ ^ X := by
  have : f ‚äÜ X √óÀ¢ Y‚ÇÇ := calc
    f ‚äÜ X √óÀ¢ Y‚ÇÅ := subset_prod_of_mem_function h
    _ ‚äÜ X √óÀ¢ Y‚ÇÇ := prod_subset_prod_of_subset (by rfl) hY
  apply mem_function.intro this
  intro x hx
  rcases exists_unique_of_mem_function h x hx |>.exists with ‚ü®y, hf‚ü©
  apply ExistsUnique.intro y hf
  intro y' hf'
  have : y' = y := exists_unique_of_mem_function h x hx |>.unique hf' hf
  assumption

lemma function_subset_function_of_subset {Y‚ÇÅ Y‚ÇÇ : V} (hY : Y‚ÇÅ ‚äÜ Y‚ÇÇ) (X : V) : Y‚ÇÅ ^ X ‚äÜ Y‚ÇÇ ^ X :=
  fun _ hf ‚Ü¶ mem_function_of_mem_function_of_subset hf hY

@[simp] lemma empty_function_empty : (‚àÖ : V) ^ (‚àÖ : V) = {‚àÖ} := by ext z; simp [mem_function_iff]

/-- Functions over arbitrary domain and range -/
class IsFunction (f : V) : Prop where
  mem_func : ‚àÉ X Y : V, f ‚àà Y ^ X

lemma isFunction_def {f : V} : IsFunction f ‚Üî ‚àÉ X Y : V, f ‚àà Y ^ X := ‚ü®fun h ‚Ü¶ h.mem_func, fun h ‚Ü¶ ‚ü®h‚ü©‚ü©

def IsFunction.dfn : Semisentence ‚Ñí‚Çõ‚Çë‚Çú 1 := f‚Äúf. ‚àÉ X Y, f ‚àà !function.dfn Y X‚Äù

instance IsFunction.defined : ‚Ñí‚Çõ‚Çë‚Çú-predicate[V] IsFunction via dfn := ‚ü®fun v ‚Ü¶ by simp [isFunction_def, dfn]‚ü©

instance IsFunction.definable : ‚Ñí‚Çõ‚Çë‚Çú-predicate[V] IsFunction := defined.to_definable

lemma isFunction_iff {f : V} : IsFunction f ‚Üî f ‚àà range f ^ domain f := by
  constructor
  ¬∑ rintro ‚ü®X, Y, hf‚ü©
    simpa [domain_eq_of_mem_function hf] using mem_function_range_of_mem_function hf
  ¬∑ intro h
    exact ‚ü®_, _, h‚ü©

namespace IsFunction

lemma of_mem {f X Y : V} (h : f ‚àà Y ^ X) : IsFunction f := ‚ü®X, Y, h‚ü©

lemma mem_function (f : V) [hf : IsFunction f] : f ‚àà range f ^ domain f := isFunction_iff.mp hf

lemma unique {f : V} [hf : IsFunction f] {x y‚ÇÅ y‚ÇÇ} (h‚ÇÅ : ‚ü®x, y‚ÇÅ‚ü©‚Çñ ‚àà f) (h‚ÇÇ : ‚ü®x, y‚ÇÇ‚ü©‚Çñ ‚àà f) : y‚ÇÅ = y‚ÇÇ := by
  have : ‚àÉ! y, ‚ü®x, y‚ü©‚Çñ ‚àà f := exists_unique_of_mem_function (isFunction_iff.mp hf) x (mem_domain_of_kpair_mem h‚ÇÅ)
  exact this.unique h‚ÇÅ h‚ÇÇ

@[simp] instance empty : IsFunction (‚àÖ : V) := ‚ü®‚àÖ, ‚àÖ, by simp‚ü©

protected def insert (f x y : V) (hx : x ‚àâ domain f) [hf : IsFunction f] : IsFunction (insert ‚ü®x, y‚ü©‚Çñ f) := by
  refine ‚ü®insert x (domain f), insert y (range f), ?_‚ü©
  apply mem_function.intro
  ¬∑ have : f ‚äÜ domain f √óÀ¢ range f := subset_prod_of_mem_function hf.mem_function
    exact insert_kpair_subset_insert_prod_insert_of_subset_prod this x y
  ¬∑ intro z hz
    rcases show z = x ‚à® z ‚àà domain f by simpa using hz with (rfl | hz)
    ¬∑ apply ExistsUnique.intro y (by simp)
      rintro y' H'
      rcases show y' = y ‚à® ‚ü®z, y'‚ü©‚Çñ ‚àà f by simpa using H' with (rfl | H')
      ¬∑ rfl
      have : z ‚àà domain f := mem_domain_of_kpair_mem H'
      contradiction
    ¬∑ rcases mem_domain_iff.mp hz with ‚ü®v, hzv‚ü©
      have : v ‚àà range f := mem_range_of_kpair_mem hzv
      apply ExistsUnique.intro v (by simp [hzv])
      rintro w Hw
      rcases show z = x ‚àß w = y ‚à® ‚ü®z, w‚ü©‚Çñ ‚àà f by simpa using Hw with (‚ü®rfl, rfl‚ü© | Hw)
      ¬∑ have : z ‚àà domain f := mem_domain_of_kpair_mem hzv
        contradiction
      exact hf.unique Hw hzv

@[simp] instance (x y : V) : IsFunction ({‚ü®x, y‚ü©‚Çñ} : V) := by simpa using IsFunction.insert ‚àÖ x y (by simp)

end IsFunction

lemma function_eq_of_subset {X Y f g : V} (hf : f ‚àà Y ^ X) (hg : g ‚àà Y ^ X) (h : f ‚äÜ g) : f = g := by
  have : IsFunction f := IsFunction.of_mem hf
  have : IsFunction g := IsFunction.of_mem hg
  apply subset_antisymm h
  intro p hp
  rcases show ‚àÉ x ‚àà X, ‚àÉ y ‚àà Y, p = ‚ü®x, y‚ü©‚Çñ from by
    simpa [mem_prod_iff] using subset_prod_of_mem_function hg _ hp with ‚ü®x, hx, y, hy, rfl‚ü©
  rcases show ‚àÉ y' ‚àà Y, ‚ü®x, y'‚ü©‚Çñ ‚àà f from exists_of_mem_function hf x hx with ‚ü®y', hy', Hf‚ü©
  have : ‚ü®x, y'‚ü©‚Çñ ‚àà g := h _ Hf
  rcases show y = y' from IsFunction.unique hp (h _ Hf)
  assumption

lemma function_ext {X Y f g : V} (hf : f ‚àà Y ^ X) (hg : g ‚àà Y ^ X)
    (h : ‚àÄ x ‚àà X, ‚àÄ y ‚àà Y, ‚ü®x, y‚ü©‚Çñ ‚àà f ‚Üí ‚ü®x, y‚ü©‚Çñ ‚àà g) : f = g := by
  apply function_eq_of_subset hf hg
  intro p hp
  rcases show ‚àÉ x ‚àà X, ‚àÉ y ‚àà Y, p = ‚ü®x, y‚ü©‚Çñ from by
    simpa [mem_prod_iff] using subset_prod_of_mem_function hf _ hp with ‚ü®x, hx, y, hy, rfl‚ü©
  exact h x hx y hy hp

@[grind] lemma two_val_function_mem_iff_not {X f x : V} (hf : f ‚àà (2 ^ X : V)) (hx : x ‚àà X) : ‚ü®x, 0‚ü©‚Çñ ‚àà f ‚Üî ‚ü®x, 1‚ü©‚Çñ ‚àâ f := by
  have : IsFunction f := IsFunction.of_mem hf
  constructor
  ¬∑ intro h0 h1
    have : (0 : V) = 1 := IsFunction.unique h0 h1
    simp_all
  ¬∑ intro h1
    rcases exists_of_mem_function hf x hx with ‚ü®i, hi, hf‚ü©
    rcases show i = 0 ‚à® i = 1 by simpa using hi with (rfl | rfl)
    ¬∑ assumption
    ¬∑ contradiction

def Injective (R : V) : Prop := ‚àÄ x‚ÇÅ x‚ÇÇ y, ‚ü®x‚ÇÅ, y‚ü©‚Çñ ‚àà R ‚Üí ‚ü®x‚ÇÇ, y‚ü©‚Çñ ‚àà R ‚Üí x‚ÇÅ = x‚ÇÇ

def Injective.dfn : Semisentence ‚Ñí‚Çõ‚Çë‚Çú 1 := f‚Äúf. ‚àÄ x‚ÇÅ x‚ÇÇ y, !kpair.dfn x‚ÇÅ y ‚àà f ‚Üí !kpair.dfn x‚ÇÇ y ‚àà f ‚Üí x‚ÇÅ = x‚ÇÇ‚Äù

instance Injective.defined : ‚Ñí‚Çõ‚Çë‚Çú-predicate[V] Injective via dfn := ‚ü®fun v ‚Ü¶ by simp [Injective, dfn]‚ü©

instance Injective.definable : ‚Ñí‚Çõ‚Çë‚Çú-predicate[V] Injective := defined.to_definable

lemma Injective.empty : Injective (‚àÖ : V) := fun x‚ÇÅ x‚ÇÇ y ‚Ü¶ by simp

/-- Identity -/
noncomputable def identity (X : V) : V := {p ‚àà X √óÀ¢ X ; ‚àÉ x ‚àà X, p = ‚ü®x, x‚ü©‚Çñ}

lemma mem_identity_iff {X p : V} : p ‚àà identity X ‚Üî ‚àÉ x ‚àà X, p = ‚ü®x, x‚ü©‚Çñ := by
  suffices ‚àÄ x ‚àà X, p = ‚ü®x, x‚ü©‚Çñ ‚Üí p ‚àà X √óÀ¢ X by simpa [identity]
  rintro x hx rfl
  simp [hx]

def identity.dfn : Semisentence ‚Ñí‚Çõ‚Çë‚Çú 2 := f‚Äúi X. ‚àÄ p, p ‚àà i ‚Üî ‚àÉ x ‚àà X, p = !kpair.dfn x x‚Äù

instance identity.defined : ‚Ñí‚Çõ‚Çë‚Çú-function‚ÇÅ[V] identity via dfn := ‚ü®fun v ‚Ü¶ by simp [dfn, mem_ext_iff (y := identity (v 1)), mem_identity_iff]‚ü©

instance identity.definable : ‚Ñí‚Çõ‚Çë‚Çú-function‚ÇÅ[V] identity := defined.to_definable

@[simp] lemma kpair_mem_identity_iff {X x : V} : ‚ü®x, y‚ü©‚Çñ ‚àà identity X ‚Üî x ‚àà X ‚àß x = y := by
  simp only [mem_identity_iff, kpair_iff, exists_eq_right_right', and_congr_left_iff]
  grind

@[simp] lemma identity_mem_function (X : V) : identity X ‚àà X ^ X := by
  refine mem_function.intro ?_ ?_
  ¬∑ intro p hp
    have : ‚àÉ x ‚àà X, p = ‚ü®x, x‚ü©‚Çñ := by simpa [mem_identity_iff] using hp
    rcases this with ‚ü®x, hx, rfl‚ü©
    simp_all
  ¬∑ intro x hx
    apply ExistsUnique.intro x (by simp [hx])
    simp only [kpair_mem_identity_iff, and_imp]
    grind

instance IsFunction.identity (X : V) : IsFunction (identity X) := IsFunction.of_mem (identity_mem_function X)

@[simp] lemma identity_injective (X : V) : Injective (identity X) := by
  intro x‚ÇÅ x‚ÇÇ y h‚ÇÅ h‚ÇÇ
  rcases show x‚ÇÅ ‚àà X ‚àß x‚ÇÅ = y by simpa using h‚ÇÅ with ‚ü®hx‚ÇÅ, rfl‚ü©
  rcases show x‚ÇÇ ‚àà X ‚àß x‚ÇÇ = x‚ÇÅ by simpa using h‚ÇÇ with ‚ü®hx‚ÇÇ, rfl‚ü©
  rfl

/-- Composition -/
noncomputable def compose (R S : V) : V := {p ‚àà domain R √óÀ¢ range S ; ‚àÉ x y z, ‚ü®x, y‚ü©‚Çñ ‚àà R ‚àß ‚ü®y, z‚ü©‚Çñ ‚àà S ‚àß p = ‚ü®x, z‚ü©‚Çñ}

lemma mem_compose_iff {R S p : V} : p ‚àà compose R S ‚Üî ‚àÉ x y z, ‚ü®x, y‚ü©‚Çñ ‚àà R ‚àß ‚ü®y, z‚ü©‚Çñ ‚àà S ‚àß p = ‚ü®x, z‚ü©‚Çñ := by
  simp only [compose, exists_and_left, mem_sep_iff, and_iff_right_iff_imp, forall_exists_index, and_imp]
  rintro x y hxy z hyz rfl
  simp [mem_domain_of_kpair_mem hxy, mem_range_of_kpair_mem hyz]

@[simp] lemma kpair_mem_compose_iff {R S x z : V} :
    ‚ü®x, z‚ü©‚Çñ ‚àà compose R S ‚Üî ‚àÉ y, ‚ü®x, y‚ü©‚Çñ ‚àà R ‚àß ‚ü®y, z‚ü©‚Çñ ‚àà S := by
  simp only [mem_compose_iff, kpair_iff, exists_and_left, exists_eq_right_right']
  grind

lemma compose_subset_prod {X Y Z R S : V} (hR : R ‚äÜ X √óÀ¢ Y) (hS : S ‚äÜ Y √óÀ¢ Z) : compose R S ‚äÜ X √óÀ¢ Z := by
  intro p hp
  rcases mem_compose_iff.mp hp with ‚ü®x, y, z, hxy, hyz, rfl‚ü©
  have : x ‚àà X ‚àß y ‚àà Y := by simpa using hR _ hxy
  have : y ‚àà Y ‚àß z ‚àà Z := by simpa using hS _ hyz
  simp_all

lemma compose_function {X Y Z f g : V} (hf : f ‚àà Y ^ X) (hg : g ‚àà Z ^ Y) : compose f g ‚àà Z ^ X := by
  have : IsFunction f := IsFunction.of_mem hf
  have : IsFunction g := IsFunction.of_mem hg
  apply mem_function.intro ?_ ?_
  ¬∑ exact compose_subset_prod (subset_prod_of_mem_function hf) (subset_prod_of_mem_function hg)
  ¬∑ intro x hx
    have : ‚àÉ y ‚àà Y, ‚ü®x, y‚ü©‚Çñ ‚àà f := exists_of_mem_function hf x hx
    rcases this with ‚ü®y, hy, hxy‚ü©
    have : ‚àÉ z ‚àà Z, ‚ü®y, z‚ü©‚Çñ ‚àà g := exists_of_mem_function hg y hy
    rcases this with ‚ü®z, hz, hyz‚ü©
    apply ExistsUnique.intro z (by simpa using ‚ü®y, hxy, hyz‚ü©)
    intro z' hz'
    have : ‚àÉ y', ‚ü®x, y'‚ü©‚Çñ ‚àà f ‚àß ‚ü®y', z'‚ü©‚Çñ ‚àà g := by simpa using hz'
    rcases this with ‚ü®y', hxy', hy'z'‚ü©
    rcases IsFunction.unique hxy hxy'
    rcases IsFunction.unique hyz hy'z'
    rfl

lemma compose_injective {R S : V} (hR : Injective R) (hS : Injective S) : Injective (compose R S) := by
  intro x‚ÇÅ x‚ÇÇ z h‚ÇÅ h‚ÇÇ
  have : ‚àÉ y‚ÇÅ, ‚ü®x‚ÇÅ, y‚ÇÅ‚ü©‚Çñ ‚àà R ‚àß ‚ü®y‚ÇÅ, z‚ü©‚Çñ ‚àà S := by simpa using h‚ÇÅ
  rcases this with ‚ü®y‚ÇÅ, hx‚ÇÅy‚ÇÅ, hy‚ÇÅz‚ü©
  have : ‚àÉ y‚ÇÇ, ‚ü®x‚ÇÇ, y‚ÇÇ‚ü©‚Çñ ‚àà R ‚àß ‚ü®y‚ÇÇ, z‚ü©‚Çñ ‚àà S := by simpa using h‚ÇÇ
  rcases this with ‚ü®y‚ÇÇ, hx‚ÇÇy‚ÇÇ, hy‚ÇÇz‚ü©
  have : y‚ÇÅ = y‚ÇÇ := hS y‚ÇÅ y‚ÇÇ z hy‚ÇÅz hy‚ÇÇz
  rcases this
  exact hR x‚ÇÅ x‚ÇÇ y‚ÇÅ hx‚ÇÅy‚ÇÅ hx‚ÇÇy‚ÇÇ

/-! ### Cardinality comparison -/

def CardLE (X Y : V) : Prop := ‚àÉ f ‚àà Y ^ X, Injective f

infix:50 " ‚â§# " => CardLE

lemma cardLE_of_subset {X Y : V} (h : X ‚äÜ Y) : X ‚â§# Y :=
  ‚ü®identity X, mem_function_of_mem_function_of_subset (identity_mem_function X) h, by simp‚ü©

@[simp] lemma cardLE_empty (X : V) : ‚àÖ ‚â§# X := cardLE_of_subset (by simp)

@[simp, refl] lemma CardLE.refl (X : V) : X ‚â§# X := cardLE_of_subset (by simp)

@[trans] lemma CardLE.trans {X Y Z : V} : X ‚â§# Y ‚Üí Y ‚â§# Z ‚Üí X ‚â§# Z := by
  rintro ‚ü®f, hf, f_inj‚ü©
  rintro ‚ü®g, hg, g_inj‚ü©
  refine ‚ü®compose f g, compose_function hf hg, compose_injective f_inj g_inj‚ü©

def CardLT (X Y : V) : Prop := X ‚â§# Y ‚àß ¬¨Y ‚â§# X

infix:50 " <# " => CardLT

def CardLE.dfn : Semisentence ‚Ñí‚Çõ‚Çë‚Çú 2 := f‚ÄúX Y. ‚àÉ f ‚àà !function.dfn Y X, !Injective.dfn f‚Äù

instance CardLE.defined : ‚Ñí‚Çõ‚Çë‚Çú-relation[V] CardLE via dfn := ‚ü®fun v ‚Ü¶ by simp [CardLE, dfn]‚ü©

instance CardLE.definable : ‚Ñí‚Çõ‚Çë‚Çú-relation[V] CardLE := defined.to_definable

def CardLT.dfn : Semisentence ‚Ñí‚Çõ‚Çë‚Çú 2 := ‚ÄúX Y. !CardLE.dfn X Y ‚àß ¬¨!CardLE.dfn Y X‚Äù

instance CardLT.defined : ‚Ñí‚Çõ‚Çë‚Çú-relation[V] CardLT via dfn := ‚ü®fun v ‚Ü¶ by simp [CardLT, dfn]‚ü©

instance CardLT.definable : ‚Ñí‚Çõ‚Çë‚Çú-relation[V] CardLT := defined.to_definable

def CardEQ (X Y : V) : Prop := X ‚â§# Y ‚àß Y ‚â§# X

infix:60 " ‚âã " => CardEQ

def CardEQ.dfn : Semisentence ‚Ñí‚Çõ‚Çë‚Çú 2 := ‚ÄúX Y. !CardLE.dfn X Y ‚àß !CardLE.dfn Y X‚Äù

instance CardEQ.defined : ‚Ñí‚Çõ‚Çë‚Çú-relation[V] CardEQ via dfn := ‚ü®fun v ‚Ü¶ by simp [CardEQ, dfn]‚ü©

instance CardEQ.definable : ‚Ñí‚Çõ‚Çë‚Çú-relation[V] CardEQ := defined.to_definable

lemma CardEQ.le {X Y : V} (h : X ‚âã Y) : X ‚â§# Y := h.1

lemma CardEQ.ge {X Y : V} (h : X ‚âã Y) : Y ‚â§# X := h.2

@[simp, refl] lemma CardEQ.refl (X : V) : X ‚âã X := ‚ü®by rfl, by rfl‚ü©

@[symm] lemma CardEQ.symm {X Y : V} : X ‚âã Y ‚Üí Y ‚âã X := fun e ‚Ü¶ ‚ü®e.2, e.1‚ü©

@[trans] lemma CardEQ.trans {X Y Z : V} : X ‚âã Y ‚Üí Y ‚âã Z ‚Üí X ‚âã Z := fun eXY eYZ ‚Ü¶
  ‚ü®eXY.le.trans eYZ.le, eYZ.ge.trans eXY.ge‚ü©

lemma cardLT_power (X : V) : X <# ‚Ñò X := by
  have : X ‚â§# ‚Ñò X := by
    let F : V := {p ‚àà X √óÀ¢ ‚Ñò X ; ‚àÉ x ‚àà X, p = ‚ü®x, {x}‚ü©‚Çñ}
    have : F ‚àà ‚Ñò X ^ X := by
      apply mem_function.intro
      ¬∑ simp [F]
      ¬∑ intro x hx
        apply ExistsUnique.intro {x} (by simp [F, hx])
        intro y hy
        have : y ‚äÜ X ‚àß y = {x} := by simpa [hx, F] using hy
        simp [this]
    have : Injective F := by
      intro x‚ÇÅ x‚ÇÇ s h‚ÇÅ h‚ÇÇ
      rcases show (x‚ÇÅ ‚àà X ‚àß s ‚äÜ X) ‚àß x‚ÇÅ ‚àà X ‚àß s = {x‚ÇÅ} by simpa [F] using h‚ÇÅ with ‚ü®_, _, rfl‚ü©
      have : (x‚ÇÇ ‚àà X ‚àß x‚ÇÅ ‚àà X) ‚àß x‚ÇÅ ‚àà X ‚àß x‚ÇÇ = x‚ÇÅ := by simpa [F] using h‚ÇÇ
      simp [this.2.2]
    refine ‚ü®F, by assumption, by assumption‚ü©
  have : ¬¨‚Ñò X ‚â§# X := by
    rintro ‚ü®F, hF, injF‚ü©
    have : IsFunction F := IsFunction.of_mem hF
    let D : V := {x ‚àà X ; ‚àÉ s ‚àà ‚Ñò X, ‚ü®s, x‚ü©‚Çñ ‚àà F ‚àß x ‚àâ s}
    have : ‚àÉ d ‚àà X, ‚ü®D, d‚ü©‚Çñ ‚àà F := exists_of_mem_function hF D (by simp [D])
    rcases this with ‚ü®d, hd, Hd‚ü©
    have : d ‚àà D ‚Üî d ‚àâ D := calc
      d ‚àà D ‚Üî ‚àÉ s ‚äÜ X, ‚ü®s, d‚ü©‚Çñ ‚àà F ‚àß d ‚àâ s := by simp [hd, D]
      _     ‚Üî d ‚àâ D := ?_
    ¬∑ grind
    constructor
    ¬∑ rintro ‚ü®S, hS, hSF, hdS‚ü©
      rcases show D = S from injF _ _ _ Hd hSF
      assumption
    ¬∑ intro h
      refine ‚ü®D, by simpa [hd] using mem_of_mem_functions hF Hd, Hd, h‚ü©
  refine ‚ü®by assumption, by assumption‚ü©

lemma two_pow_cardEQ_power (X : V) : 2 ^ X ‚âã ‚Ñò X := by
  constructor
  ¬∑ let F : V := {p ‚àà (2 ^ X) √óÀ¢ ‚Ñò X ; ‚àÉ f s, p = ‚ü®f, s‚ü©‚Çñ ‚àß ‚àÄ x, x ‚àà s ‚Üî ‚ü®x, 1‚ü©‚Çñ ‚àà f}
    refine ‚ü®F, ?_, ?_‚ü©
    ¬∑ apply mem_function.intro
      ¬∑ simp [F]
      ¬∑ intro f hf
        let s : V := {x ‚àà X ; ‚ü®x, 1‚ü©‚Çñ ‚àà f}
        have ss_s : s ‚äÜ X := by simp [s]
        have mem_s : ‚àÄ x, x ‚àà s ‚Üî ‚ü®x, 1‚ü©‚Çñ ‚àà f := by
          simp only [mem_sep_iff, and_iff_right_iff_imp, s]
          intro x hx
          exact mem_of_mem_functions hf hx |>.1
        apply ExistsUnique.intro s ?_ ?_
        ¬∑ simp [F, hf, ss_s, mem_s]
        ¬∑ intro t ht
          ext x
          have ht : (f ‚àà ((2 : V) ^ X) ‚àß t ‚äÜ X) ‚àß ‚àÄ x, x ‚àà t ‚Üî ‚ü®x, 1‚ü©‚Çñ ‚àà f := by simpa [F] using ht
          simp [ht, mem_s]
    ¬∑ intro f‚ÇÅ f‚ÇÇ s h‚ÇÅ h‚ÇÇ
      have : (f‚ÇÅ ‚àà (2 ^ X : V) ‚àß s ‚äÜ X) ‚àß ‚àÄ x, x ‚àà s ‚Üî ‚ü®x, 1‚ü©‚Çñ ‚àà f‚ÇÅ := by simpa [F] using h‚ÇÅ
      rcases this with ‚ü®‚ü®f‚ÇÅfunc, hs‚ü©, H‚ÇÅ‚ü©
      have : (f‚ÇÇ ‚àà (2 ^ X : V) ‚àß s ‚äÜ X) ‚àß ‚àÄ x, x ‚àà s ‚Üî ‚ü®x, 1‚ü©‚Çñ ‚àà f‚ÇÇ := by simpa [F] using h‚ÇÇ
      rcases this with ‚ü®‚ü®f‚ÇÇfunc, _‚ü©, H‚ÇÇ‚ü©
      apply function_ext f‚ÇÅfunc f‚ÇÇfunc
      intro x hx i hi
      rcases show i = 0 ‚à® i = 1 by simpa using hi with (rfl | rfl)
      ¬∑ contrapose
        suffices ‚ü®x, 1‚ü©‚Çñ ‚àà f‚ÇÇ ‚Üí ‚ü®x, 1‚ü©‚Çñ ‚àà f‚ÇÅ by grind
        grind
      ¬∑ grind
  ¬∑ let F : V := {p ‚àà ‚Ñò X √óÀ¢ (2 ^ X) ; ‚àÉ f s, p = ‚ü®s, f‚ü©‚Çñ ‚àß ‚àÄ x, ‚ü®x, 1‚ü©‚Çñ ‚àà f ‚Üî x ‚àà s}
    refine ‚ü®F, ?_, ?_‚ü©
    ¬∑ apply mem_function.intro
      ¬∑ simp [F]
      ¬∑ intro s hs
        have hs : s ‚äÜ X := by simpa using hs
        let f : V := {p ‚àà X √óÀ¢ 2 ; ‚àÉ x, (x ‚àà s ‚Üí p = ‚ü®x, 1‚ü©‚Çñ) ‚àß (x ‚àâ s ‚Üí p = ‚ü®x, 0‚ü©‚Çñ)}
        have kp1_mem_f : ‚àÄ x, ‚ü®x, 1‚ü©‚Çñ ‚àà f ‚Üî x ‚àà s := by
          intro x
          have : x ‚àà s ‚Üí x ‚àà X := fun hx ‚Ü¶ hs _ hx
          simp only [mem_sep_iff, kpair_mem_iff, mem_two_iff, one_ne_zero, or_true, and_true,
            kpair_iff, and_false, imp_false, not_not, f]; grind
        have f_func : f ‚àà (2 ^ X : V) := by
          apply mem_function.intro (by simp [f])
          intro x hx
          by_cases hxS : x ‚àà s
          ¬∑ apply ExistsUnique.intro 1
            ¬∑ simp only [mem_sep_iff, kpair_mem_iff, hx, mem_two_iff, one_ne_zero, or_true, and_self,
              kpair_iff, and_true, and_false, imp_false, not_not, true_and, f]; grind
            ¬∑ intro i hi
              simp [f, hx] at hi
              grind only
          ¬∑ apply ExistsUnique.intro 0
            ¬∑ simp only [mem_sep_iff, kpair_mem_iff, hx, mem_two_iff, zero_ne_one, or_false,
              and_self, kpair_iff, and_false, imp_false, and_true, true_and, f]; grind
            ¬∑ intro i hi
              simp [f, hx] at hi
              grind
        apply ExistsUnique.intro f ?_ ?_
        ¬∑ simp [F, hs, kp1_mem_f, f_func]
        ¬∑ intro g hg
          have : (s ‚äÜ X ‚àß g ‚àà (2 ^ X : V)) ‚àß ‚àÄ x, ‚ü®x, 1‚ü©‚Çñ ‚àà g ‚Üî x ‚àà s := by simpa [F] using hg
          rcases this with ‚ü®‚ü®_, g_func‚ü©, Hg‚ü©
          apply function_ext g_func f_func
          intro x hx i hi
          rcases show i = 0 ‚à® i = 1 by simpa using hi with (rfl | rfl)
          ¬∑ suffices ‚ü®x, 1‚ü©‚Çñ ‚àà f ‚Üí ‚ü®x, 1‚ü©‚Çñ ‚àà g by grind
            grind
          ¬∑ grind
    ¬∑ intro s‚ÇÅ s‚ÇÇ f h‚ÇÅ h‚ÇÇ
      have : (s‚ÇÅ ‚äÜ X ‚àß f ‚àà (2 ^ X : V)) ‚àß ‚àÄ x, ‚ü®x, 1‚ü©‚Çñ ‚àà f ‚Üî x ‚àà s‚ÇÅ := by simpa [F] using h‚ÇÅ
      have : (s‚ÇÇ ‚äÜ X ‚àß f ‚àà (2 ^ X : V)) ‚àß ‚àÄ x, ‚ü®x, 1‚ü©‚Çñ ‚àà f ‚Üî x ‚àà s‚ÇÇ := by simpa [F] using h‚ÇÇ
      ext z; grind

end LO.FirstOrder.SetTheory
