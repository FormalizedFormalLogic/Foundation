import Foundation.IntFO.Basic.Deduction

namespace LO.FirstOrder

namespace Semiterm

variable {L : Language} [L.Relational]

lemma bvar_or_fvar_of_relational (t : Semiterm L Œæ n) : (‚àÉ x, t = #x) ‚à® (‚àÉ x, t = &x) :=
  match t with
  |        #x => by simp
  |        &x => by simp
  | .func f _ => Language.Relational.func_empty _ |>.elim' f

lemma fvar_of_relational (t : Term L Œæ) : ‚àÉ x, t = &x := by
  rcases bvar_or_fvar_of_relational t with (‚ü®x, rfl‚ü© | ‚ü®x, rfl‚ü©)
  ¬∑ exact finZeroElim (Œ± := fun _ ‚Ü¶ _) x
  ¬∑ exact ‚ü®x, rfl‚ü©

variable {M : Type*} (bv : Fin n ‚Üí M) (fv : Œæ ‚Üí M)

def relationalVal : Semiterm L Œæ n ‚Üí M
  |        #x => bv x
  |        &x => fv x
  | .func f _ => Language.Relational.func_empty _ |>.elim' f

variable {bv fv}

@[simp] lemma relationalVal_bvar : (#x : Semiterm L Œæ n).relationalVal bv fv = bv x := rfl

@[simp] lemma relationalVal_fvar : (&x : Semiterm L Œæ n).relationalVal bv fv = fv x := rfl

lemma relationalVal_rew {bv : Fin n‚ÇÇ ‚Üí M} {fv : Œæ‚ÇÇ ‚Üí M} (œâ : Rew L Œæ‚ÇÅ n‚ÇÅ Œæ‚ÇÇ n‚ÇÇ) (t : Semiterm L Œæ‚ÇÅ n‚ÇÅ) :
    relationalVal bv fv (œâ t) = relationalVal (relationalVal bv fv ‚àò œâ ‚àò bvar) (relationalVal bv fv ‚àò œâ ‚àò fvar) t := by
  rcases bvar_or_fvar_of_relational t with (‚ü®x, rfl‚ü© | ‚ü®x, rfl‚ü©) <;> simp

@[simp] lemma relationalVal_bShift (x : M) (t : Semiterm L Œæ n) :
    relationalVal (x :> bv) fv (Rew.bShift t) = relationalVal bv fv t := by
  simp [relationalVal_rew, Function.comp_def]

end Semiterm

open Frame

structure RelationalKripkeModel (L : Language) [L.Relational] where
  World : Type*
  [preorder : Preorder World]
  Carrier : Type*
  Domain : World ‚Üí Set Carrier
  domain_nonempty : ‚àÄ w, ‚àÉ x, x ‚àà Domain w
  domain_antimonotone : w ‚â• v ‚Üí Domain w ‚äÜ Domain v
  Rel (w : World) {k : ‚Ñï} (R : L.Rel k) : (Fin k ‚Üí Carrier) ‚Üí Prop
  rel_monotone : w ‚â• v ‚Üí Rel w R t ‚Üí Rel v R t

instance (L : Language) [L.Relational] : CoeSort (RelationalKripkeModel L) (Type _) := ‚ü®fun ùìö ‚Ü¶ ùìö.World‚ü©

instance {L : Language} [L.Relational] (ùìö : RelationalKripkeModel L) : CoeSort ùìö.World (Type _) := ‚ü®fun w ‚Ü¶ ùìö.Domain w‚ü©

instance {L : Language} [L.Relational] (ùìö : RelationalKripkeModel L) : Preorder ùìö.World := ùìö.preorder

namespace RelationalKripkeModel

variable {L : Language} [L.Relational] {ùìö : RelationalKripkeModel L}

def Val {n} (w : ùìö) (bv : Fin n ‚Üí Carrier ùìö) (fv : Œæ ‚Üí Carrier ùìö) : Semiformula·µ¢ L Œæ n ‚Üí Prop
  | .rel R t => ùìö.Rel w R fun i ‚Ü¶ (t i).relationalVal bv fv
  |        ‚ä§ => True
  |        ‚ä• => False
  |    œÜ ‚ãè œà => Val w bv fv œÜ ‚àß Val w bv fv œà
  |    œÜ ‚ãé œà => Val w bv fv œÜ ‚à® Val w bv fv œà
  |    œÜ ‚ûù œà => ‚àÄ v ‚â§ w, Val v bv fv œÜ ‚Üí Val v bv fv œà
  |     ‚àÄ' œÜ => ‚àÄ v ‚â§ w, ‚àÄ x : v, Val v (x.val :> bv) fv œÜ
  |     ‚àÉ' œÜ => ‚àÉ x : w, Val w (x.val :> bv) fv œÜ

local notation:45 w " ‚ä©[" bv "|" fv "] " œÜ:46 => Val w bv fv œÜ

abbrev Valb {n} (w : ùìö) (bv : Fin n ‚Üí Carrier ùìö) : Semisentence·µ¢ L n ‚Üí Prop := ùìö.Val w bv Empty.elim

scoped notation:45 w " ‚ä©/" bv œÜ:46 => Valb w bv œÜ

variable (w : ùìö) (bv : Fin n ‚Üí Carrier ùìö) (fv : Œæ ‚Üí Carrier ùìö)

@[simp] lemma val_verum : w ‚ä©[bv|fv] ‚ä§ := by trivial

@[simp] lemma val_falsum : ¬¨w ‚ä©[bv|fv] ‚ä• := by rintro ‚ü®‚ü©

variable {w bv fv}

@[simp] lemma val_rel {k} {R : L.Rel k} {t} :
    w ‚ä©[bv|fv] .rel R t ‚Üî ùìö.Rel w R fun i ‚Ü¶ (t i).relationalVal bv fv := by rfl

@[simp] lemma val_and {œÜ œà : Semiformula·µ¢ L Œæ n} : w ‚ä©[bv|fv] œÜ ‚ãè œà ‚Üî w ‚ä©[bv|fv] œÜ ‚àß w ‚ä©[bv|fv] œà := by rfl

@[simp] lemma val_or {œÜ œà : Semiformula·µ¢ L Œæ n} : w ‚ä©[bv|fv] œÜ ‚ãé œà ‚Üî w ‚ä©[bv|fv] œÜ ‚à® w ‚ä©[bv|fv] œà := by rfl

@[simp] lemma val_imply {œÜ œà : Semiformula·µ¢ L Œæ n} :
    w ‚ä©[bv|fv] œÜ ‚ûù œà ‚Üî ‚àÄ v ‚â§ w, Val v bv fv œÜ ‚Üí Val v bv fv œà := by rfl

@[simp] lemma val_all {œÜ : Semiformula·µ¢ L Œæ (n + 1)} :
    w ‚ä©[bv|fv] ‚àÄ' œÜ ‚Üî ‚àÄ v ‚â§ w, ‚àÄ x : v, Val v (x.val :> bv) fv œÜ := by rfl

@[simp] lemma val_ex {œÜ : Semiformula·µ¢ L Œæ (n + 1)} :
    w ‚ä©[bv|fv] ‚àÉ' œÜ ‚Üî ‚àÉ x : w, w ‚ä©[x :> bv|fv] œÜ := by rfl

@[simp] lemma val_neg {œÜ : Semiformula·µ¢ L Œæ n} :
    w ‚ä©[bv|fv] ‚àºœÜ ‚Üî ‚àÄ v ‚â§ w, ¬¨v ‚ä©[bv|fv] œÜ := by rfl

@[simp] lemma val_conj {Œì : List (Semiformula·µ¢ L Œæ n)} :
    w ‚ä©[bv|fv] ‚ãÄŒì ‚Üî ‚àÄ œÜ ‚àà Œì, w ‚ä©[bv|fv] œÜ :=
  match Œì with
  |          [] => by simp
  |         [œÜ] => by simp
  | œÜ :: œà :: Œì => by simp [val_conj (Œì := œà :: Œì)]

@[simp] lemma val_disj {Œì : List (Semiformula·µ¢ L Œæ n)} :
    w ‚ä©[bv|fv] ‚ãÅŒì ‚Üî ‚àÉ œÜ ‚àà Œì, w ‚ä©[bv|fv] œÜ :=
  match Œì with
  |          [] => by simp
  |         [œÜ] => by simp
  | œÜ :: œà :: Œì => by simp [val_disj (Œì := œà :: Œì)]

lemma val_rew {bv : Fin n‚ÇÇ ‚Üí Carrier ùìö} {fv : Œæ‚ÇÇ ‚Üí Carrier ùìö} {œâ : Rew L Œæ‚ÇÅ n‚ÇÅ Œæ‚ÇÇ n‚ÇÇ} {œÜ : Semiformula·µ¢ L Œæ‚ÇÅ n‚ÇÅ} :
    w ‚ä©[bv|fv] (œâ ‚ñπ œÜ) ‚Üî
    w ‚ä©[fun x ‚Ü¶ (œâ #x).relationalVal bv fv|fun x ‚Ü¶ (œâ &x).relationalVal bv fv] œÜ := by
  induction œÜ using Semiformula·µ¢.rec' generalizing n‚ÇÇ w
  case hRel k R t =>
    simp only [Semiformula·µ¢.rew_rel, val_rel]
    apply iff_of_eq; congr; funext x
    simp [Semiterm.relationalVal_rew œâ (t x), Function.comp_def]
  case hImp œÜ œà ihœÜ ihœà =>
    simp [*]
  case hAnd œÜ œà ihœÜ ihœà => simp [ihœÜ, ihœà]
  case hOr œÜ œà ihœÜ ihœà => simp [ihœÜ, ihœà]
  case hVerum => simp
  case hFalsum => simp
  case hAll œÜ ih =>
    have (x : Carrier ùìö) : (fun i ‚Ü¶ (œâ.q #i).relationalVal (x :> bv) fv) = (x :> fun i ‚Ü¶ (œâ #i).relationalVal bv fv) := by
      funext i; cases i using Fin.cases <;> simp
    simp [ih, this]
  case hEx œÜ ih =>
    have (x : Carrier ùìö) : (fun i ‚Ü¶ (œâ.q #i).relationalVal (x :> bv) fv) = (x :> fun i ‚Ü¶ (œâ #i).relationalVal bv fv) := by
      funext i; cases i using Fin.cases <;> simp
    simp [ih, this]

@[simp] lemma val_free {fv : ‚Ñï ‚Üí ùìö.Carrier} {œÜ : SyntacticSemiformula·µ¢ L (n + 1)} :
    v ‚ä©[bv|‚Üëx :>‚Çô fv] Rewriting.free œÜ ‚Üî v ‚ä©[bv <: x|fv] œÜ := by
  have : (fun i ‚Ü¶ Semiterm.relationalVal (L := L) bv (x :>‚Çô fv) (Rew.free #i)) = (bv <: x) := by
    ext i; cases i using Fin.lastCases <;> simp
  simp [Rewriting.free, val_rew, this]

lemma val_subst (w : Fin k ‚Üí Semiterm L Œæ n) (œÜ : Semiformula·µ¢ L Œæ k) :
    v ‚ä©[bv|fv] (œÜ ‚áú w) ‚Üî v ‚ä©[fun i ‚Ü¶ (w i).relationalVal bv fv|fv] œÜ := by
  simp [Rewriting.subst, val_rew]

@[simp] lemma val_subst‚ÇÄ (œÜ : Formula·µ¢ L Œæ) :
    v ‚ä©[bv|fv] œÜ/[] ‚Üî v ‚ä©[![]|fv] œÜ := by
  simp [val_subst, Matrix.empty_eq]

@[simp] lemma val_subst‚ÇÅ (t : Semiterm L Œæ n) (œÜ : Semiformula·µ¢ L Œæ 1) :
    v ‚ä©[bv|fv] œÜ/[t] ‚Üî v ‚ä©[![t.relationalVal bv fv]|fv] œÜ := by
  simp [val_subst, Matrix.constant_eq_singleton]

@[simp] lemma val_emb {œÜ : Semisentence·µ¢ L n} :
    v ‚ä©[bv|fv] (Rewriting.emb œÜ) ‚Üî v ‚ä©[bv|Empty.elim] œÜ := by
  simp [Rewriting.emb, val_rew, Empty.eq_elim]

lemma Val.monotone
    {n} {bv : Fin n ‚Üí Carrier ùìö} {fv : Œæ ‚Üí Carrier ùìö}
    (h : v ‚â§ w) {œÜ} : w ‚ä©[bv|fv] œÜ ‚Üí v ‚ä©[bv|fv] œÜ :=
  match œÜ with
  | .rel R v => ùìö.rel_monotone h
  |        ‚ä§ => id
  |        ‚ä• => id
  |    œÜ ‚ãè œà => by
    rintro ‚ü®hl, hr‚ü©
    exact ‚ü®hl.monotone h, hr.monotone h‚ü©
  |    œÜ ‚ãé œà => by
    rintro (hl | hr)
    ¬∑ left; exact hl.monotone h
    ¬∑ right; exact hr.monotone h
  |    œÜ ‚ûù œà => fun Hw v' hvv' Hv' ‚Ü¶
    Hw v' (le_trans hvv' h) Hv'
  |    ‚àÄ' œÜ => fun Hw v' hvv' x ‚Ü¶ Hw v' (le_trans hvv' h) x
  |    ‚àÉ' œÜ => by
    rintro ‚ü®x, Hw‚ü©
    exact ‚ü®‚ü®x, ùìö.domain_antimonotone h x.prop‚ü©, Hw.monotone h‚ü©

variable (ùìö)

def Force (œÜ : Sentence·µ¢ L) : Prop := ‚àÄ w : ùìö, w ‚ä©[![]|Empty.elim] œÜ

instance : Semantics (Sentence·µ¢ L) (RelationalKripkeModel L) := ‚ü®fun ùìö œÜ ‚Ü¶ ùìö.Force œÜ‚ü©

variable {ùìö}

variable {Œõ : Hilbert·µ¢ L}

open HilbertProof·µ¢ Semantics

lemma sound!_forces (w : ùìö) (fv : ‚Ñï ‚Üí ùìö.Carrier) (hfv : ‚àÄ i, fv i ‚àà ùìö.Domain w) {œÜ} : ùóúùóªùòÅ¬π ‚ä¢! œÜ ‚Üí w ‚ä©[![]|fv] œÜ
  |     eaxm h => by
    have : ‚àÉ œà, Axioms.EFQ œà = œÜ := by simpa [Hilbert·µ¢.Intuitionistic] using h
    rcases this with ‚ü®œà, rfl‚ü©
    rintro v hvw ‚ü®‚ü©
  | mdp bœÜœà bœÜ => by simpa using sound!_forces w fv hfv bœÜœà w (by simp) (sound!_forces w fv hfv bœÜ)
  |      gen b => fun v hwv x ‚Ü¶ by
    simpa using sound!_forces v (x :>‚Çô fv) (by rintro (i | i) <;> simp [fun i ‚Ü¶ ùìö.domain_antimonotone hwv (hfv i)]) b
  | verum => by simp
  | imply‚ÇÅ œÜ œà => by
    intro w‚ÇÅ hw‚ÇÅw‚ÇÄ hw‚ÇÅœÜ w‚ÇÇ hw‚ÇÅw‚ÇÇ hw‚ÇÇœÜ
    exact hw‚ÇÅœÜ.monotone hw‚ÇÅw‚ÇÇ
  | imply‚ÇÇ œÜ œà œá => by
    intro w‚ÇÅ hw‚ÇÅw‚ÇÄ hw‚ÇÅ w‚ÇÇ hw‚ÇÇw‚ÇÅ hw‚ÇÇ w‚ÇÉ hw‚ÇÉw‚ÇÇ hw‚ÇÉ
    have : w‚ÇÉ ‚ä©[![]|fv] œà := hw‚ÇÇ w‚ÇÉ hw‚ÇÉw‚ÇÇ hw‚ÇÉ
    exact hw‚ÇÅ w‚ÇÉ (le_trans hw‚ÇÉw‚ÇÇ hw‚ÇÇw‚ÇÅ) hw‚ÇÉ w‚ÇÉ (by rfl) this
  | and‚ÇÅ œÜ œà => by
    rintro v hvw ‚ü®hœÜ, hœà‚ü©
    exact hœÜ
  | and‚ÇÇ œÜ œà => by
    rintro v hvw ‚ü®hœÜ, hœà‚ü©
    exact hœà
  | and‚ÇÉ œÜ œà => by
    intro v‚ÇÅ hv‚ÇÅw hœÜ v‚ÇÇ hv‚ÇÇv‚ÇÅ hœà
    exact ‚ü®hœÜ.monotone hv‚ÇÇv‚ÇÅ, hœà‚ü©
  | or‚ÇÅ œÜ œà => by
    intro v hvw hœÜ
    left; exact hœÜ
  | or‚ÇÇ œÜ œà => by
    intro v hvw hœà
    right; exact hœà
  | or‚ÇÉ œÜ œà œá => by
    rintro w‚ÇÅ hw‚ÇÅw hœÜœá w‚ÇÇ hw‚ÇÇw‚ÇÅ hœàœá w‚ÇÉ hw‚ÇÉw‚ÇÇ (hœÜ | hœà)
    ¬∑ exact hœÜœá w‚ÇÉ (le_trans hw‚ÇÉw‚ÇÇ hw‚ÇÇw‚ÇÅ) hœÜ
    ¬∑ exact hœàœá w‚ÇÉ hw‚ÇÉw‚ÇÇ hœà
  | all‚ÇÅ œÜ t => by
    rcases t.fvar_of_relational with ‚ü®x, rfl‚ü©
    intro v hvw hœÜ
    suffices v ‚ä©[![fv x]|fv] œÜ by simpa [val_subst, Matrix.constant_eq_singleton]
    simpa using hœÜ v (by rfl) ‚ü®fv x, ùìö.domain_antimonotone hvw (hfv x)‚ü©
  | all‚ÇÇ œÜ œà => by
    intro w‚ÇÅ hw‚ÇÅ H w‚ÇÇ hw‚ÇÇ‚ÇÅ hœÜ w‚ÇÉ hw‚ÇÉ‚ÇÇ x
    exact H w‚ÇÉ (le_trans hw‚ÇÉ‚ÇÇ hw‚ÇÇ‚ÇÅ) x w‚ÇÉ (by rfl) (by simpa using hœÜ.monotone hw‚ÇÉ‚ÇÇ)
  | ex‚ÇÅ t œÜ => by
    rcases t.fvar_of_relational with ‚ü®x, rfl‚ü©
    intro v hvw hœÜ
    have : v ‚ä©[![fv x]|fv] œÜ := by simpa using hœÜ
    exact ‚ü®‚ü®fv x, ùìö.domain_antimonotone hvw (hfv x)‚ü©, by simpa using this‚ü©
  | ex‚ÇÇ œÜ œà => by
    rintro w‚ÇÅ hw‚ÇÅ H w‚ÇÇ hw‚ÇÇ‚ÇÅ ‚ü®x, hœÜ‚ü©
    simpa using H w‚ÇÇ hw‚ÇÇ‚ÇÅ x w‚ÇÇ (by rfl) hœÜ

lemma sound {T : Theory·µ¢ (ùóúùóªùòÅ¬π : Hilbert·µ¢ L)} (b : T ‚ä¢ œÜ) : ùìö ‚äß* T ‚Üí ùìö ‚äß œÜ := fun H w ‚Ü¶ by
  rcases ùìö.domain_nonempty w with ‚ü®x, hx‚ü©
  have : (Rewriting.emb '' T.theory) *‚ä¢[ùóúùóªùòÅ¬π] ‚ÜëœÜ := b
  rcases Entailment.Context.provable_iff.mp this with ‚ü®Œì, HŒì, b‚ü©
  have : w ‚ä©[![]|fun _ ‚Ü¶ x] ‚ãÄŒì ‚ûù ‚ÜëœÜ := sound!_forces (L := L) w (fun _ ‚Ü¶ x) (by simp [hx]) b.get
  have : w ‚ä©[![]|fun _ : ‚Ñï ‚Ü¶ x] ‚ÜëœÜ := by
    apply this w (by rfl)
    suffices ‚àÄ œÜ ‚àà Œì, w ‚ä©[![]|fun _ ‚Ü¶ x] œÜ by simpa
    intro œÜ hœÜ
    rcases show ‚àÉ x ‚àà T.theory, ‚Üëx = œÜ by simpa using HŒì œÜ hœÜ with ‚ü®œÜ, hœÜ', rfl‚ü©
    simpa using H.RealizeSet hœÜ' w
  simpa using this

instance (T : Theory·µ¢ (ùóúùóªùòÅ¬π : Hilbert·µ¢ L)) : Sound T (Semantics.models (RelationalKripkeModel L) T) := ‚ü®fun b _ H ‚Ü¶ sound b H‚ü©

end RelationalKripkeModel

end LO.FirstOrder
